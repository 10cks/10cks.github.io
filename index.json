[{"content":"在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\u0026#34;/usr/bin/echo\u0026#34;, [\u0026#34;echo\u0026#34;, \u0026#34;evilpan\u0026#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \u0026#34;/etc/ld.so.preload\u0026#34;, R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=19285, ...}) = 0 mmap(NULL, 19285, PROT_READ, MAP_PRIVATE, 3, 0) = 0x79aecf8000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib/aarch64-linux-gnu/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\267\\0\\1\\0\\0\\0p\\16\\2\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 fstat(3, {st_mode=S_IFREG|0777, st_size=1439544, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79aecf6000 mmap(NULL, 1511520, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79aeb5e000 mprotect(0x79aecb7000, 61440, PROT_NONE) = 0 mmap(0x79aecc6000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x158000) = 0x79aecc6000 mmap(0x79aeccc000, 12384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79aeccc000 close(3) = 0 mprotect(0x79aecc6000, 16384, PROT_READ) = 0 mprotect(0x5787f5f000, 4096, PROT_READ) = 0 mprotect(0x79aecff000, 4096, PROT_READ) = 0 munmap(0x79aecf8000, 19285) = 0 brk(NULL) = 0x57b1bd2000 brk(0x57b1bf3000) = 0x57b1bf3000 fstat(1, {st_mode=S_IFCHR|0600, st_rdev=makedev(0x88, 0x2), ...}) = 0 write(1, \u0026#34;evilpan\\n\u0026#34;, 8evilpan ) = 8 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++   对于需要监控系统调用的场景，strace 是个非常合适的工具，因为它基于 PTRACE_SYSCALL 去跟踪并基于中断的方式去接管所有系统调用，因此即便目标使用了不依赖 libc 的内联 svc 也可以被识别到。不过这个缺点也很明显，从名称也看出来，本质上该程序是基于 ptrace 对目标进行跟踪，因此如果对方代码中有反调试措施，那么就很有可能被检测到。\n另外在 Android 系统中，APP 进程都是由 zygote fork 而出，因此使用 strace 比较不容易确定跟踪时机，而且由于许多应用有多个进程，就需要对输出结果进行额外的过滤和清洗。\n 更多关于 strace 的实现原理可以参考: How does strace work?\n jtrace 在早期 strace 程序还不支持 arm64，因此 Jonathan Levin 在编写 Android Internal 一书时就写了 jtrace 这个工具，旨在用于对 Android 应用的跟踪。虽然现在 Google 也在 AOSP 中支持了 strace，但 jtrace 仍然有其独特的优点:\n 支持系统属性的访问监控 (setprop/getprop) 支持输入事件的监控 (InputReader) 支持 Binder 信息的解析 支持 AIDL 的解析 ……  虽然 jtrace 是闭源的，但提供了独特的插件功能，用户可以根据其提供的接口去编写一个插件(动态库)，并使用 --plugin 参数或者 JTRACE_EXT_PATH 环境变量指定的路径加载插件，从而实现自定义的系统调用参数解析处理。\n虽然优点比 strace 多了不少，但其缺点并没有解决，jtrace 本身依然是基于 PTRACE_SYSCALL 进行系统调用跟踪的，因此还是很容易被应用的反调试检测到。\n 详见: http://newandroidbook.com/tools/jtrace.html\n Frida frida 是目前全球最为知名的动态跟踪工具集 (Instrumentation)，支持使用 js 脚本来对目标应用程序进行动态跟踪。相信读者对于 frida 已经不陌生，这里也就不再过多介绍。其功能之丰富毋庸置疑，但也有一些硬伤，比如:\n frida-gum 基于 inline-hook 对目标跟踪代码进行实时重编译 (JIT)，对于应用本身有较大的侵入性； frida-inject 需要依赖 ptrace 对目标应用进行第一次注入并加载 agent，有一个较短的注入窗口可能会被反调试应用检测到； frida 目前尚不支持系统调用事件级别的追踪，虽然 frida-stalker 可以做到汇编级别，但是开销过大； frida 太过知名，以至于有很多针对 frida 的特征检测； ……  类似的 Instrumentation 工具还有 QDBI，hookzz 等等。\n其他 除了上面提到的这些工具，还有很多其他工具可以进行动态监控，比如 ltrace、gdb 等但这些工具都不能完美实现我的需求。既要马儿跑得快(开销小)，又要马儿不吃草(无侵入)，那我们就只有把眼光放向内核了。\nKernel Tracing 101 如果目标是为了实现系统调用监控，以及部分系统调用参数的修改(例如 IO 重定向)，那么一个直观的想法是修改内核源码，在我们感兴趣的系统调用入口插入自己的代码实现具体功能。但是这样非常低效，一来我们要在不同的系统调用相关函数中增加代码，引入过多修改后会导致更新内核合并上游提交变得困难；二来我们每次修改后都需要重新编译内核以及对应的 AOSP 代码(因为内核在 boot.img 中，详见后文)，再烧写到手机或模拟器中，流程过于复杂。\n另外一个想法是通过在内核代码中引入一次性的 trampoline，然后在后续增加或者减少系统调用监控入口时通过内核模块的方式去进行修改。这样似乎稍微合理一些，但其实内核中已经有了许多类似的监控方案，这样做纯属重复造轮子，效率低不说还可能随时引入 kernel panic。\n大局观 那么，内核中都有哪些监控方案？这其实不是一个容易回答的问题，我们在日常运维时听说过 kprobe、jprobe、uprobe、eBPF、tracefs、systemtab、perf，……到底他们之间的的关系是什么，分别都有什么用呢？\n这里推荐一篇文章: Linux tracing systems \u0026amp; how they fit together，根据其中的介绍，这些内核监控方案/工具可以分为三类:\n 数据: 根据监控数据的来源划分 采集: 根据内核提供给用户态的原始事件回调接口进行划分 前端: 获取和解析监控事件数据的用户工具  后面对这些监控方案分别进行简要的介绍。\nkprobe 简单来说，kprobe 可以实现动态内核的注入，基于中断的方法在任意指令中插入追踪代码，并且通过 pre_handler/post_handler/fault_handler 去接收回调。\n使用 参考 Linux 源码中的 samples/kprobes/kprobe_example.c，一个简单的 kprobe 内核模块实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kprobes.h\u0026gt; #define MAX_SYMBOL_LEN 64 static char symbol[MAX_SYMBOL_LEN] = \u0026#34;_do_fork\u0026#34;; module_param_string(symbol, symbol, sizeof(symbol), 0644); /* For each probe you need to allocate a kprobe structure */ static struct kprobe kp = { .symbol_name = symbol, }; /* kprobe pre_handler: called just before the probed instruction is executed */ static int handler_pre(struct kprobe *p, struct pt_regs *regs) { pr_info(\u0026#34;\u0026lt;%s\u0026gt; pre_handler: p-\u0026gt;addr = 0x%p, pc = 0x%lx\\n\u0026#34;, p-\u0026gt;symbol_name, p-\u0026gt;addr, (long)regs-\u0026gt;pc); /* A dump_stack() here will give a stack backtrace */ return 0; } /* kprobe post_handler: called after the probed instruction is executed */ static void handler_post(struct kprobe *p, struct pt_regs *regs, unsigned long flags) { pr_info(\u0026#34;\u0026lt;%s\u0026gt; post_handler: p-\u0026gt;addr = 0x%p\\n\u0026#34;, p-\u0026gt;symbol_name, p-\u0026gt;addr); } /* * fault_handler: this is called if an exception is generated for any * instruction within the pre- or post-handler, or when Kprobes * single-steps the probed instruction. */ static int handler_fault(struct kprobe *p, struct pt_regs *regs, int trapnr) { pr_info(\u0026#34;fault_handler: p-\u0026gt;addr = 0x%p, trap #%dn\u0026#34;, p-\u0026gt;addr, trapnr); /* Return 0 because we don\u0026#39;t handle the fault. */ return 0; } static int __init kprobe_init(void) { int ret; kp.pre_handler = handler_pre; kp.post_handler = handler_post; kp.fault_handler = handler_fault; ret = register_kprobe(\u0026amp;kp); if (ret \u0026lt; 0) { pr_err(\u0026#34;register_kprobe failed, returned %d\\n\u0026#34;, ret); return ret; } pr_info(\u0026#34;Planted kprobe at %p\\n\u0026#34;, kp.addr); return 0; } static void __exit kprobe_exit(void) { unregister_kprobe(\u0026amp;kp); pr_info(\u0026#34;kprobe at %p unregistered\\n\u0026#34;, kp.addr); } module_init(kprobe_init) module_exit(kprobe_exit) MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   安装该内核模块后，每当系统中的进程调用 fork，就会触发我们的 handler，从而在 dmesg 中输出对应的日志信息。值得注意的是，kprobe 模块依赖于具体的系统架构，上述 pre_handler 中我们打印指令地址使用的是 regs-\u0026gt;pc，这是 ARM64 的情况，如果是 X86 环境，则对应 regs-\u0026gt;ip，可查看对应 arch 的 struct pt_regs 实现。\n原理 kprobe 框架基于中断实现。当 kprobe 被注册后，内核会将对应地址的指令进行拷贝并替换为断点指令(比如 X86 中的 int 3)，随后当内核执行到对应地址时，中断会被触发从而执行流程会被重定向到我们注册的 pre_handler 函数；当对应地址的原始指令执行完后，内核会再次执行 post_handler (可选)，从而实现指令级别的内核动态监控。也就是说，kprobe 不仅可以跟踪任意带有符号的内核函数，也可以跟踪函数中间的任意指令。\n另一个 kprobe 的同族是 kretprobe，只不过是针对函数级别的内核监控，根据用户注册时提供的 entry_handler 和 ret_handler 来分别在函数进入时和返回前进行回调。当然实现上和 kprobe 也有所不同，不是通过断点而是通过 trampoline 进行实现，可以略为减少运行开销。\n 有人可能听说过 Jprobe，那是早期 Linux 内核的的一个监控实现，现已被 Kprobe 替代。\n 拓展阅读:\n An introduction to KProbes Documentation/trace/kprobetrace.rst samples/kprobes/kprobe_example.c samples/kprobes/kretprobe_example.c  uprobe uprobe 顾名思义，相对于内核函数/地址的监控，主要用于用户态函数/地址的监控。听起来是不是有点神奇，内核怎么监控用户态函数的调用呢？\n使用 站在用户视角，我们先看个简单的例子，假设有这么个一个用户程序:\n1 2 3 4 5 6 7 8 9  // test.c #include \u0026lt;stdio.h\u0026gt;void foo() { printf(\u0026#34;hello, uprobe!\\n\u0026#34;); } int main() { foo(); return 0; }   编译好之后，查看某个符号的地址，然后告诉内核我要监控这个地址的调用:\n1 2 3 4 5 6  $ gcc test.c -o test $ readelf -s test | grep foo 87: 0000000000000764 32 FUNC GLOBAL DEFAULT 13 foo $ echo \u0026#39;p /root/test:0x764\u0026#39; \u0026gt; /sys/kernel/debug/tracing/uprobe_events $ echo 1 \u0026gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo 1 \u0026gt; /sys/kernel/debug/tracing/tracing_on   然后运行用户程序并检查内核的监控返回:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ ./test \u0026amp;\u0026amp; ./test hello, uprobe! hello, uprobe! $ cat /sys/kernel/debug/tracing/trace # tracer: nop # # WARNING: FUNCTION TRACING IS CORRUPTED # MAY BE MISSING FUNCTION EVENTS # entries-in-buffer/entries-written: 3/3 #P:8 # # _-----=\u0026gt; irqs-off # / _----=\u0026gt; need-resched # | / _---=\u0026gt; hardirq/softirq # || / _--=\u0026gt; preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | test-7958 [006] .... 34213.780750: p_test_0x764: (0x6236218764) test-7966 [006] .... 34229.054039: p_test_0x764: (0x5f586cb764)   当然，最后别忘了关闭监控:\n1 2 3  $ echo 0 \u0026gt; /sys/kernel/debug/tracing/tracing_on $ echo 0 \u0026gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo \u0026gt; /sys/kernel/debug/tracing/uprobe_events   原理 上面的接口是基于 debugfs (在较新的内核中使用 tracefs)，即读写文件的方式去与内核交互实现 uprobe 监控。其中写入 uprobe_events 时会经过一系列内核调用:\n probes_write create_trace_uprobe kern_path: 打开目标 ELF 文件； alloc_trace_uprobe: 分配 uprobe 结构体； register_trace_uprobe: 注册 uprobe； regiseter_uprobe_event: 将 probe 添加到全局列表中，并创建对应的 uprobe debugfs 目录，即上文示例中的 p_test_0x764；  当已经注册了 uprobe 的 ELF 程序被执行时，可执行文件会被 mmap 映射到进程的地址空间，同时内核会将该进程虚拟地址空间中对应的 uprobe 地址替换成断点指令。当目标程序指向到对应的 uprobe 地址时，会触发断点，从而触发到 uprobe 的中断处理流程 (arch_uprobe_exception_notify)，进而在内核中打印对应的信息。\n与 kprobe 类似，我们可以在触发 uprobe 时候根据对应寄存器去提取当前执行的上下文信息，比如函数的调用参数等。同时 uprobe 也有类似的同族: uretprobe。使用 uprobe 的好处是我们可以获取许多对于内核态比较抽象的信息，比如 bash 中 readline 函数的返回、SSL_read/write 的明文信息等。\n拓展阅读:\n Linux uprobe: User-Level Dynamic Tracing Documentation/trace/uprobetracer.rst Linux tracing - kprobe, uprobe and tracepoint  tracepoints tracepont 是内核中提供的一种轻量级代码监控方案，可以实现动态调用用户提供的监控函数，但需要子系统的维护者根据需要自行添加到自己的代码中。\n使用 tracepoint 的使用和 uprobe 类似，主要基于 debugfs/tracefs 的文件读写去进行实现。一个区别在于 uprobe 使用的的用户自己定义的观察点(event)，而 tracepoint 使用的是内核代码中预置的观察点。\n查看内核(或者驱动)中定义的所有观察点:\n1 2 3 4 5 6 7 8  $ cat /sys/kernel/debug/tracing/available_events sctp:sctp_probe sctp:sctp_probe_path sde:sde_perf_uidle_status .... random:random_read random:urandom_read ...   在 events 对应目录下包含了以子系统结构组织的观察点目录:\n1 2 3 4 5 6 7  $ ls /sys/kernel/debug/tracing/events/random/ add_device_randomness credit_entropy_bits extract_entropy get_random_bytes mix_pool_bytes_nolock urandom_read add_disk_randomness debit_entropy extract_entropy_user get_random_bytes_arch push_to_pool xfer_secondary_pool add_input_randomness enable filter mix_pool_bytes random_read $ ls /sys/kernel/debug/tracing/events/random/random_read/ enable filter format id trigger   以 urandom 为例，这是内核的伪随机数生成函数，对其开启追踪:\n1 2 3 4 5  $ echo 1 \u0026gt; /sys/kernel/debug/tracing/events/random/urandom_read/enable $ echo 1 \u0026gt; /sys/kernel/debug/tracing/tracing_on $ head -c1 /dev/urandom $ cat /sys/kernel/debug/tracing/trace_pipe head-9949 [006] .... 101453.641087: urandom_read: got_bits 40 nonblocking_pool_entropy_left 0 input_entropy_left 2053   其中 trace_pipe 是输出的管道，以阻塞的方式进行读取，因此需要先开始读取再获取 /dev/urandom，然后就可以看到类似上面的输出。这里输出的格式是在内核中定义的，我们下面会看到。\n 当然，最后记得把 trace 关闭。\n 原理 根据内核文档介绍，子系统的维护者如果想在他们的内核函数中增加跟踪点，需要执行两步操作:\n 定义跟踪点 使用跟踪点  内核为跟踪点的定义提供了 TRACE_EVENT 宏。还是以 urandom_read 这个跟踪点为例，其在内核中的定义在 include/trace/events/random.h:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #undef TRACE_SYSTEM #define TRACE_SYSTEM random  TRACE_EVENT(random_read, TP_PROTO(int got_bits, int need_bits, int pool_left, int input_left), TP_ARGS(got_bits, need_bits, pool_left, input_left), TP_STRUCT__entry( __field( int, got_bits ) __field( int, need_bits ) __field( int, pool_left ) __field( int, input_left ) ), TP_fast_assign( __entry-\u0026gt;got_bits = got_bits; __entry-\u0026gt;need_bits = need_bits; __entry-\u0026gt;pool_left = pool_left; __entry-\u0026gt;input_left = input_left; ), TP_printk(\u0026#34;got_bits %d still_needed_bits %d \u0026#34; \u0026#34;blocking_pool_entropy_left %d input_entropy_left %d\u0026#34;, __entry-\u0026gt;got_bits, __entry-\u0026gt;got_bits, __entry-\u0026gt;pool_left, __entry-\u0026gt;input_left) );   其中:\n random_read: trace 事件的名称，不一定要内核函数名称一致，但通常为了易于识别会和某个关键的内核函数相关联。隶属于 random 子系统(由 TRACE_SYSTEM 宏定义)； TP_PROTO: 定义了跟踪点的原型，可以理解为入参类型; TP_ARGS: 定义了”函数“的调用参数； TP_STRUCT__entry: 用于 fast binary tracing，可以理解为一个本地 C 结构体的定义； TP_fast_assign: 上述本地 C 结构体的初始化; TP_printk: 类似于 printk 的结构化输出定义，上节中 trace_pipe 的输出结果就是这里定义的；  TRACE_EVENT 宏并不会自动插入对应函数，而是通过展开定义了一个名为 trace_urandom_read 的函数，需要内核开发者自行在代码中进行调用。 上述跟踪点实际上是在 drivers/char/random.c 文件中进行了调用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  static ssize_t urandom_read_nowarn(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { int ret; nbytes = min_t(size_t, nbytes, INT_MAX \u0026gt;\u0026gt; (ENTROPY_SHIFT + 3)); ret = extract_crng_user(buf, nbytes); trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(\u0026amp;input_pool)); // \u0026lt;-- 这里  return ret; } static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { unsigned long flags; static int maxwarn = 10; if (!crng_ready() \u0026amp;\u0026amp; maxwarn \u0026gt; 0) { maxwarn--; if (__ratelimit(\u0026amp;urandom_warning)) pr_notice(\u0026#34;%s: uninitialized urandom read (%zd bytes read)\\n\u0026#34;, current-\u0026gt;comm, nbytes); spin_lock_irqsave(\u0026amp;primary_crng.lock, flags); crng_init_cnt = 0; spin_unlock_irqrestore(\u0026amp;primary_crng.lock, flags); } return urandom_read_nowarn(file, buf, nbytes, ppos); }   值得注意的是实际上是在 urandom_read_nowarn 函数中而不是 urandom_read 函数中调用的，因此也可见注入点名称和实际被调用的内核函数名称没有直接关系，只需要便于识别和定位即可。\n根据上面的介绍我们可以了解到，tracepoint 相对于 probe 来说各有利弊:\n 缺点是需要开发者自己定义并且加入到内核代码中，对代码略有侵入性； 优点是对于参数格式有明确定义，并且在不同内核版本中相对稳定，kprobe 跟踪的内核函数可能在下个版本就被改名或者优化掉了；  另外，tracepoint 除了在内核代码中直接定义，还可以在驱动中进行动态添加，用于方便驱动开发者进行动态调试，复用已有的 debugfs 最终架构。这里有一个简单的自定义 tracepoint 示例，可用于加深对 tracepoint 使用的理解。\n拓展阅读:\n LWN: Using the TRACE_EVENT() macro (Part 1) Documentation/trace/tracepoints.rst Taming Tracepoints in the Linux Kernel  USDT USDT 表示 Userland Statically Defined Tracing，即用户静态定义追踪 (币圈同志先退下)。最早源于 Sun 的 Dtrace 工具，因此 USDT probe 也常被称为 Dtrace probe。可以理解为 kernel tracepoint 的用户层版本，由应用开发者在自己的程序中关键函数加入自定义的跟踪点，有点类似于 printf 调试法(误)。\n下面是一个简单的示例:\n1 2 3 4 5 6  #include \u0026#34;sys/sdt.h\u0026#34;int main() { DTRACE_PROBE(\u0026#34;hello_usdt\u0026#34;, \u0026#34;enter\u0026#34;); int reval = 0; DTRACE_PROBE1(\u0026#34;hello_usdt\u0026#34;, \u0026#34;exit\u0026#34;, reval); }   DTRACE_PROBEn 是 UDST (systemtap) 提供的追踪点定义+插入辅助宏，n 表示参数个数。编译上述代码后就可以看到被注入的 USDT probe 信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ apt-get install systemtap-sdt-dev $ gcc hello-usdt.c -o hello-usdt $ readelf -n ./hello-usdt ... Displaying notes found in: .note.stapsdt Owner Data size Description stapsdt 0x0000002e NT_STAPSDT (SystemTap probe descriptors) Provider: \u0026#34;hello_usdt\u0026#34; Name: \u0026#34;enter\u0026#34; Location: 0x0000000000001131, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: stapsdt 0x00000038 NT_STAPSDT (SystemTap probe descriptors) Provider: \u0026#34;hello_usdt\u0026#34; Name: \u0026#34;exit\u0026#34; Location: 0x0000000000001139, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: -4@-4(%rbp)   readelf -n 表示输出 ELF 中 NOTE 段的信息。\n在使用 trace 工具(如 BCC、SystemTap、dtrace) 对该应用进行追踪时，会在启动过程中修改目标进程的对应地址，将其替换为 probe ，在触发调用时候产生对应事件，供数据收集端使用。通常添加 probe 的方式是 基于 uprobe 实现的。\n使用 USDT 的一个好处是应用开发者可以在自己的程序中定义更加上层的追踪点，方便对于功能级别监控和分析，比如 node.js server 就自带了 USDT probe 点可用于追踪 HTTP 请求，并输出请求的路径等信息。由于 USDT 需要开发者配合使用，不符合我们最初的逆向分析需要，因此就不过多介绍了。(其实是懒得搭环境)\n拓展阅读:\n Exploring USDT Probes on Linux LWN: Using user-space tracepoints with BPF  小结 上述介绍的四种常见内核监控方案，根据静态/动态类型以及面向内核还是用户应用来划分的话，可以用下表进行概况:\n   监控方案 静态 动态 内核 用户     Kprobes  ✔ ✔    Uprobes  ✔  ✔   Tracepoints ✔  ✔    USDT ✔   ✔    准确来说 USDT 不算是一种独立的内核监控数据源，因为其实现还是依赖于 uprobe，不过为了对称还是放在这里，而且这样目录比较好看。\n采集 \u0026amp; 前端 上面我们介绍了几种当今内核中主要的监控数据来源，基本上可以涵盖所有的监控需求。不过从易用性上来看，只是实现了基本的架构，使用上有的是基于内核提供的系统调用/驱动接口，有的是基于 debugfs/tracefs，对用户而言不太友好，因此就有了许多封装再封装的监控前端，本节对这些主要的工具进行简要介绍。\nftrace ftrace 是内核中用于实现内部追踪的一套框架，这么说有点抽象，但实际上我们前面已经用过了，就是 tracefs 中的使用的方法。\n 在旧版本中内核中(4.1 之前)使用 debugfs，一般挂载到 /sys/kernel/debug/tracing；在新版本中使用独立的 tracefs，挂载到 /sys/kernel/tracing。但出于兼容性原因，原来的路径仍然保留，所以我们将其统一称为 tracefs。\n ftrace 通常被叫做 function tracer，但除了函数跟踪，还支持许多其他事件信息的追踪:\n hwlat: 硬件延时追踪 irqsoff: 中断延时追踪 preemptoff: 追踪指定时间片内的 CPU 抢占事件 wakeup: 追踪最高优先级的任务唤醒的延时 branch: 追踪内核中的 likely/unlikely 调用 mmiotrace: 追踪某个二进制模块所有对硬件的读写事件 ……  Android 中提供了一个简略的文档指导如何为内核增加 ftrace 支持，详见: Using ftrace。\nperf perf 是 Linux 发行版中提供的一个性能监控程序，基于内核提供的 perf_event_open 系统调用来对进程进行采样并获取信息。Linux 中的 perf 子系统可以实现对 CPU 指令进行追踪和计数，以及收集 kprobe、uprobe 和 tracepoints 的信息，实现对系统性能的分析。\n在 Android 中提供了一个简单版的 perf 程序 simpleperf，接口和 perf 类似。\n虽然可以监测到系统调用，但缺点是无法获取系统调用的参数，更不可以动态地修改内核。因此对于安全测试而言作用不大，更多是给 APP 开发者和手机厂商用于性能热点分析。值得一提的是，perf 子系统曾经出过不少漏洞，在 Android 内核提权史中也曾经留下过一点足迹 :D\neBPF eBPF 为 extended Berkeley Packet Filter 的缩写，BPF 最早是用于包过滤的精简虚拟机，拥有自己的一套指令集，我们常用的 tcpdump 工具内部就会将输入的过滤规则转换为 BPF 指令，比如:\n1 2 3 4 5 6 7  $ tcpdump -i lo0 \u0026#39;src 1.2.3.4\u0026#39; -d (000) ld [0] (001) jeq #0x2000000 jt 2\tjf 5 (002) ld [16] (003) jeq #0x1020304 jt 4\tjf 5 (004) ret #262144 (005) ret #0   该汇编指令表示令过滤器只接受 IP 包，并且来源 IP 地址为 1.2.3.4。其中的指令集可以参考 Linux Socket Filtering aka Berkeley Packet Filter (BPF)。eBPF 在 BPF 指令集上做了许多增强(extend):\n 寄存器个数从 2 个增加为 10 个 (R0 - R9)； 寄存器大小从 32 位增加为 64 位； 条件指令 jt/jf 的目标替换为 jt/fall-through，简单来说就是 else 分支可以默认忽略； 增加了 bpf_call 指令以及对应的调用约定，减少内核调用的开销； ……  内核存在一个 eBPF 解释器，同时也支持实时编译(JIT)增加其执行速度，但很重要的一个限制是 eBPF 程序不能影响内核正常运行，在 内核加载 eBPF 程序前会对其进行一次语义检查，确保代码的安全性，主要限制为:\n 不能包含循环，这是为了防止 eBPF 程序过度消耗系统资源(5.3 中增加了部分循环支持)； 不能反向跳转，其实也就是不能包含循环； BPF 程序的栈大小限制为 512 字节； ……  具体的限制策略都在内核的 eBPF verifier 中，不同版本略有差异。值得一提的是，最近几年 Linux 内核出过很多 eBPF 的漏洞，大多是 verifier 的验证逻辑错误，其中不少还上了 Pwn2Own，但是由于权限的限制在 Android 中普通应用无法执行 bpf(2) 系统调用，因此并不受影响。\neBPF 和 perf_event 类似，通过内核虚拟机的方式实现监控代码过滤的动态插拔，这在许多场景下十分奏效。对于普通用户而言，基本上不会直接编写 eBPF 的指令去进行监控，虽然内核提供了一些宏来辅助 eBPF 程序的编写，但实际上更多的是使用上层的封装框架去调用，其中最著名的一个就是 BCC。\nBCC BCC (BPF Compiler Collection) 包含了一系列工具来协助运维人员编写监控代码，其中使用较多的是其 Python 绑定。一个简单的示例程序如下:\n1 2 3 4 5 6 7 8  from bcc import BPF prog=\u0026#34;\u0026#34;\u0026#34; int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\u0026#34;Hello, World!\\\\n\u0026#34;); return 0; } \u0026#34;\u0026#34;\u0026#34; BPF(text=prog).trace_print()   执行该 python 代码后，每当系统中的进程调用 clone 系统调用，该程序就会打印 “Hello World” 输出信息。 可以看到这对于动态监控代码非常有用，比如我们可以通过 python 传入参数指定打印感兴趣的系统调用及其参数，而无需频繁修改代码。\neBPF 可以获取到内核中几乎所有的监控数据源，包括 kprobes、uprobes、tracepoints 等等，官方 repo 中给出了许多示例程序，比如 opensnoop 监控文件打开行为、execsnoop 监控程序的执行。后文我们会在 Android 系统进行实际演示来感受其威力。\nbpftrace bpftrace 是 eBPF 框架的另一个上层封装，与 BCC 不同的是 bpftrace 定义了一套自己的 DSL 脚本语言，语法(也)类似于 awk，从而可以方便用户直接通过命令行实现丰富的功能，截取几条官方给出的示例:\n1 2 3 4 5  # 监控系统所有的打开文件调用(open/openat)，并打印打开文件的进程以及被打开的文件路径 bpftrace -e \u0026#39;tracepoint:syscalls:sys_enter_open { printf(\u0026#34;%s %s\\n\u0026#34;, comm, str(args-\u0026gt;filename)); }\u0026#39; # 统计系统中每个进程执行的系统调用总数 bpftrace -e \u0026#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }\u0026#39;   官方同样也给出了许多 .bt 脚本示例，可以通过其代码进行学习和编写。\n拓展阅读:\n LWN: A thorough introduction to eBPF Extending the Kernel with eBPF https://www.opersys.com/downloads/cc-slides/android-debug/slides-main-211122.html#/ http://www.caveman.work/2019/01/29/eBPF-on-Android/  SystemTap SystemTap(stab) 是 Linux 中的一个命令行工具，可以对各种内核监控源信息进行结构化输出。同时也实现了自己的一套 DSL 脚本，语法类似于 awk，可实现系统监控命令的快速编程。\n使用 systemtap 需要包含内核源代码，因为需要动态编译和加载内核模块。在 Android 中还没有官方的支持，不过有一些开源的 systemtap 移植。\n拓展阅读: Comparing SystemTap and bpftrace\n其他 除了上面介绍的这些，还有许多开源的内核监控前端，比如 LTTng、trace-cmd、kernelshark等，内核监控输出以结构化的方式进行保存、处理和可视化，对于大量数据而言是非常实用的。限于篇幅不再对这些工具进行一一介绍，而且笔者使用的也不多，后续有机会再进行研究。\nAndroid 移植 上面说了那么多，终究只是 Linux 发行版上的热闹，那么这些 trace 方法在 Android 上行得通吗？理论上 AOSP 的代码是开源的，内核也是开源的，编译一下不就好了。但实践起来我们会遇到几个方面的困难:\n 许多工具需要编译代码，BCC 工具还需要 Python 运行，这在默认的 Android 环境中不存在； 原厂提供的预编译内核镜像不带有 kprobe 等监控功能支持，需要自行修改配置，烧写和编译内核； Linux 旧版本对于 eBPF 的支持不完善，许多新功能都是在 5.x 后才引进，而 Android 的 Linux 内核都比较旧，需要进行 cherry-pick 甚至手动 backport； AOSP 较新版本引入了 GKI(Generic Kernel Image)，需要保持内核驱动接口的兼容性，因此内核代码不能引入过多修改； ……  由于我们主要目的是进行安卓应用逆向分析，因此最好在真机环境运行，因为许多应用并不支持 x86 环境。当然 ARM 模拟器也可以，但在攻防对抗的时可能需要进行额外的模拟器检测绕过。\n笔者使用的是 Google Pixel 5，使用其他手机的话需要适当进行调整。\n1. Debian over Android Android 系统本身并不是为了开发而设计的，因此只内置了简单的 busybox(toybox) 工具，以及一些包管理相关的程序如 pm/am/dumpsys/input 等。为了在上面构建完整的开发环境，我们需要能在安卓中运行 gcc/clang、python、Makefile 等，一个直观的想法是通过沙盒等方式在上面运行一个常见的 Linux 发行版，比如 Ubuntu 或者 Debian。\nandrodeb 正是这个想法的一个实现，其核心是基于 chroot 在 Android 中运行了一个 Debian aarch64 镜像，并可以通过 apt 等包管理工具安装所需要的编译工具链，从而在上面编译和运行 bcc 等 Linux 项目。\n在 Android 上运行 Debian 系统的示例如下:\nRunning Debian on Android\n其中的关键之处在于正确挂载原生 Android 中的映射，比如 procfs、devfs、debugfs 等。\n2. 自定义内核 解决了在 Android 上运行开发工具的问题之后，我们还需要一个支持动态调试的内核环境。在绝大多数官方固件中自带的内核都没有开启 KPROBES 的支持，这意味着我们自行编译和加载内核。为了能够支持 KPROBES、UPROBES、TRACEPOINTS 等功能，需要在内核的配置中添加以下选项:\n禁用内核的安全特性，开启调试支持:\n-d CONFIG_LTO \\\r-d CONFIG_LTO_CLANG \\\r-d CONFIG_CFI_CLANG \\\r-d CFI_PERMISSIVE \\\r-d CFI_CLANG \\\r-e CONFIG_IRQSOFF_TRACER \\\r-e CONFIG_PREEMPT_TRACER \\\r-e CONFIG_DEBUG_FS \\\r-e CONFIG_CHECKPOINT_RESTORE \\\r-d CONFIG_RANDOMIZE_BASE \\ 开启 eBPF 支持:\n-e CONFIG_BPF \\\r-e CONFIG_BPF_SYSCALL \\\r-e CONFIG_BPF_JIT \\\r-e CONFIG_HAVE_EBPF_JIT \\\r-e CONFIG_IKHEADERS \\ 开启 kprobes 支持:\n-e CONFIG_HAVE_KPROBES \\\r-e CONFIG_KPROBES \\\r-e CONFIG_KPROBE_EVENT \\ 开启 kretprobe 支持:\n-e CONFIG_KRETPROBES \\\r-e CONFIG_HAVE_KRETPROBES \\\r-d CONFIG_SHADOW_CALL_STACK \\\r-e CONFIG_ROP_PROTECTION_NONE \\ 开启 ftrace 支持:\n-e CONFIG_FTRACE_SYSCALLS \\\r-e CONFIG_FUNCTION_TRACER \\\r-e CONFIG_HAVE_DYNAMIC_FTRACE \\\r-e CONFIG_DYNAMIC_FTRACE \\ 开启 uprobes 支持:\n-e CONFIG_UPROBES \\\r-e CONFIG_UPROBE_EVENT \\\r-e CONFIG_BPF_EVENTS BCC 建议设置的选项:\n-e CONFIG_DEBUG_PREEMPT \\\r-e CONFIG_PREEMPTIRQ_EVENTS \\\r-d CONFIG_PROVE_LOCKING \\\r-d CONFIG_LOCKDEP 为了避免各类环境问题，我建议编译环境最好选择干净的虚拟机英文环境，或者直接使用 Docker 镜像，根据官方的指导去编译，见: Building Kernels。\n编译内核常见的依赖:\n1 2 3 4 5 6 7 8 9  $ pkg --add-architecture i386 $ apt install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip   拓展阅读:\n Building a Pixel kernel with KASAN+KCOV eBPF/BCC - A better low-level Instrumentation tool on Android  3. 内核移植 当你成功编译好内核并启动后，很可能会发现有一些内核分析工具比如 BCC 在使用上会出现各种问题，这通常是内核版本的原因。由于 eBPF 目前在内核中也在频繁更新，因此许多新的特性并没有增加到当前内核上。\n例如，在 Pixel 5 最新的支持的内核是 4.19 版本，在这个版本中，bpf_probe_read_user (issue#3175) 函数还没添加进内核，因此使用 BCC 会回退到 bpf_probe_read_kernel，这在内核直接读取用户空间的数据(比如系统调用的参数)时会出现错误，因此我们需要手动去 cherry-pick 对应的 commit，即在 Linux 5.5 中添加的 6ae08ae3dea2。\nBCC 所需的所有内核特性及其引进的版本列表可以参考: BCC/kernel-versions.md，部分列表如下所示:\n因此为了减少可能遇到的兼容性问题，尽量使用最新版本的内核，当然通常厂商都只维护一个较旧的 LTS 版本，只进行必要的安全性更新，如果买机不淑的话就需要自食其力了。\n实战测试 通过在上述 Android Debian 环境编译好 BCC 之后，我们就可以使用 Python 编写对应的应用跟踪分析脚本了。一般是通过应用名去过滤系统调用，但是在 Android 中还有个特别的过滤方式就是通过用户 ID，因为应用是根据动态安装获取的 UID 去进行沙盒隔离的。\n以某个层层加固的恶意 APK 为例，安装后获取其 UID 为 u0_a142，转换成数字是 10142，对其进行 exec 系统调用的监控:\n可以看到目标应用调用了 ps、getprop、pm 等程序，用来检测当前系统的 adb 状态以及所安装的应用，比如其中通过 pm path com.topjohnwu.magisk 来判断 Magisk 工具是否存在，因此存在 root 检测行为。上图中 pm 实际调用了 cmd 程序进行查找，因为 pm 本质上只是一个 shell 脚本:\n1 2 3  $ cat `which pm` #!/system/bin/sh cmd package \u0026#34;$@\u0026#34;   使用 UID 进行过滤的好处是可以跟踪所有 fork 的子进程和孙子进程，这是基于 PID 或者进程名跟踪所无法比拟的。除了 exec，我们还可以跟踪其他内核函数，比如 root 检测经常用到的 openat 或 access，如下所示:\n基于内核级别的监控，让应用中所有的加固/隐藏/内联汇编等防御措施形同虚设，而且可以在应用启动的初期进行观察，让应用的一切行为在我们眼中无所遁形。\nPS: 如果在使用 BCC 的过程中发现没有过滤 UID 的选项，那可能需要切换到最新的 release 版本或者 master 分支，因为这个选项是笔者最近才加上去的。\n:D\n拓展阅读:\n eBPF super powers on ARM64 and Android (slides) eBPF - Android Reverse Engineering Superpowers  总结 本文总结并分析了几种内核主要的监控方案，它们通常用于性能监控和内核调试，但我们也可以将其用做安全分析，并在 Android 中进行了实际的移植和攻防测试，并且获得了超出预期的实战效果。除了内核级别监控，我们还可以基于 uprobes 实现应用内任意地址的监控，如在 SSL_read/write 地址处获取所有 SSL 加密的数据。得益于内核提供的丰富监控原语，我们可以实现内核级别移动端沙盒，全面监控移动应用行为，也可以通过内核读写原语去实现系统调用参数修改，从而实现应用运行环境的模拟和伪造。\n","permalink":"https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\u0026#34;/usr/bin/echo\u0026#34;, [\u0026#34;echo\u0026#34;, \u0026#34;evilpan\u0026#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \u0026#34;/etc/ld.","title":"Linux 内核监控在 Android 攻防中的应用"},{"content":"前言 很久之前就用过安卓的termux，最近在使用Telegam的API，想做一个追踪丢失手机的功能。不过在我的小米8（root）上从Google Play下载的termux无法进行pkg update，会出现502报错，百思不得其解。\n后来在官方论坛找到原因，Google Play上的termux已经好久没有更新了，现在要从F-Droid上下载最新版本。我也懒得更换源了，换源的话就直接按照清华源的教程操作即可。如下：\n1 2  sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@\u0026#39; $PREFIX/etc/apt/sources.list apt update \u0026amp;\u0026amp; apt upgrade   目标 开发一款APP，能够实现强制打开GPS并根据telegram指令定时发送GPS数据到指定用户。\n实施 ","permalink":"https://10cks.top/posts/termux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","summary":"前言 很久之前就用过安卓的termux，最近在使用Telegam的API，想做一个追踪丢失手机的功能。不过在我的小米8（root）上从Google Play下载的termux无法进行pkg update，会出现502报错，百思不得其解。\n后来在官方论坛找到原因，Google Play上的termux已经好久没有更新了，现在要从F-Droid上下载最新版本。我也懒得更换源了，换源的话就直接按照清华源的教程操作即可。如下：\n1 2  sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@\u0026#39; $PREFIX/etc/apt/sources.list apt update \u0026amp;\u0026amp; apt upgrade   目标 开发一款APP，能够实现强制打开GPS并根据telegram指令定时发送GPS数据到指定用户。\n实施 ","title":"Termux使用指南"},{"content":"Botconf 2021/22 重新回到线下举办，并且回到了第一届的举办地——法国西海岸的南特。尽管是线下举办，但由于各国的政策要求不一，仍有部分议题的主讲人未能到场进行分享。作为一个在专业领域内比较受认可的会议，本届 Botconf 有来自世界各地的三百多名安全研究人员注册参加。此前，360 Netlab 与绿盟等国内安全公司也有议题在该会议上进行分享，本届也有一个来自阿里云的工作。\n下面只挑选部分议题进行介绍，感兴趣的同学可以去官网查看全部议题进一步了解。\nPS：Botconf 要求参与会议的人员不要录制视频，只有官方能够录制视频。并且每个主讲人都会对内容做出说明，如果表明是机密信息的情况下，请不要拍照或者对外进行相关内容的讨论。所以在遵守该要求的情况下，在公开议题中选取了部分议题进行简要介绍，完整、详细的内容请查看官网或者联系作者。\n监控多个 P2P 僵尸网络的经验见解 来自德国达姆施塔特工业大学、美国马里兰大学和马来西亚理科大学关于监控僵尸网络的研究。研究人员认为监控僵尸网络就像盲人摸象：\nP2P 僵尸网络的三个典型模式：非结构化、结构化、寄生。\n利用爬虫和传感器构建僵尸网络监控系统，以下是一些系统截图（公众号会对图片进行压缩，原图是非常清晰的）：\n该研究监控了 Mozi、Hajime、DDG 等比较大规模的 P2P 僵尸网络，跟踪失陷主机的相关统计信息（如国家、自治系统、地理分布等）。\n研究人员通过双队列并行两万个爬虫获取信息。\n后续研究人员还会增加对 Bot 生命周期的自动测量、对反监控的措施加以完善等其他功能，该项目也欢迎其他研究人员的合作。\n根据通信模式检测利用合法服务进行 C\u0026amp;C 的失陷主机 来自 Akamai 的工作一向扎实。这次内容提到 Akamai 正在努力跟踪发现失陷痕迹，提醒相关用户存在可疑行为。因为很多犯罪分子都会使用合法的 Web 服务来进行攻击。例如 HAMMERTOSS 使用 Twitter、GitHub 和云存储服务进行 C\u0026amp;C 通信。\n典型的三类恶意流量模式：Beacon、DGA 与多信道。\n研究人员发现，使用功率谱密度（PSD）将时域数据转向频域处理，可能会很有效果。清华在 CCS 2021 上也发表了一篇利用频域分析检测恶意流量的工作《Realtime Robust Malicious Traffic Detection via Frequency Domain Analysis》，利用频域分析可能是有潜力的工作方向，感兴趣的同学可以尝试研究。\n正常的设备流量模式与失陷主机的流量模式存在显著差异：\nAkamai 使用 DNS 数据来进行检测：\n在 Akamai 在应用中发现了许多正常情况下难以发现的恶意攻击，例如 uBlock 恶意插件（仿冒合法广告拦截插件的恶意插件）：\nKashmirBlack 僵尸网络的来龙去脉 Imperva 跟踪 PHPUnit 远程代码执行（CVE-2017-9841）漏洞的在野传播，该漏洞影响波及 Drupal、WordPress、PrestaShop 与 Magento 等知名框架。\n整体流程如上所示，当然攻击者也利用了很多其他漏洞。\n该僵尸网络是根据 GitHub 的仓库名称命名的：\n最早从 2016 年该僵尸网络就开始活跃：\n早于 VirusTotal 在云上检测恶意软件 来自阿里云与达摩院的工作。依托阿里自己的云安全产品，利用 ssdeep 构建超过一亿文件的关系图。新发现的样本和已知的样本进行比对，升级得到样本标签：\n由于样本量很大，工程应用上的优化其实是核心。其中的 tips 如下所示：\n方法上也很明晰，和前人做的很多工作一脉相承。例如 Brian Wallace 在 Virus Bulletin 分享过应对大规模样本场景下高性能使用 ssdeep 的方法、Intezer 也分享过类似的工作。这部分在此前的文章中也提到过，可以进一步阅读。本项工作在各处都加以优化，希望在海量样本场景下提供更好的应用性能。\n 狩猎样本可用的哈希函数介绍\nAvenger，公众号：威胁棱镜狩猎样本的哈希游戏\n 有线索的情况下可以直接在图里查询，没有线索的情况下可以看聚类的情况。\n例如 21.1 万个 XorDDoS 样本，Avira 引擎能够检出 15.3 万，总有一些样本在 ViursTotal 上是不能被检出的，就可以通过这种方法发现。\n从大视角来看，勒索软件聚类：\n挖矿软件聚类：\nMirai 聚类：\nAgent Tesla 聚类：\n最后，研究人员指出，该方法并不局限于使用 ssdeep，其他算法也可以使用，原理是共通的。\nPS：这个报告因为超时一直被催促，比较遗憾最后由于时间原因取消了提问环节。\n恶意软件市场中私密论坛的形态研究 研究人员从 2020 年 6 月 1 日到 2021 年 2 月 10 日，跟踪了一个超过六万成员、100 万帖子的私密论坛和一个超过 18.5 万成员、34.5 万帖子的公开论坛。公开论坛中有 86 个恶意软件提供方、私密论坛中有 136 个恶意软件提供方。\n恶意软件中，控制类恶意软件占据了半壁江山。\n控制类恶意软件中，私密论坛上近四分之三都是远控：\n窃密类恶意软件中，私密论坛百花齐放，各种类型的窃密恶意软件都有一席之地。\n从目标上看，移动端仍然只是一小部分，计算机终端还是主流。\n恶意软件价格跨度极大，从免费到一万美元以上都有。\nQbot 进化之路 从 2007 年开始，Qbot 就持续活跃，是目前最活跃的恶意软件之一。\n研究人员分析了 Qbot 近十年的进化之路。\n内容十分硬核，本届 Botconf 其实还有一个议题是讲 Qbot 的《Behind The Scenes Of Qbot》，但该议题是 Amber 的，也没有对外放 PPT，就不做表述了。\n十五年来高级攻击者对气隙网络的觊觎 ESET 梳理了过往 15 年中 17 个针对气隙网络进行攻击的案例，发现攻击的一些特点，例如所有的恶意软件框架都使用 USB 设备作为物理介质将数据摆渡出目标网络中。\n去年 ESET 披露的白皮书已经讲了很多，感兴趣可以参考查看。\n ESET 分析白皮书\nhttps://www.welivesecurity.com/wp-content/uploads/2021/12/eset_jumping_the_air_gap_wp.pdf\n  ESET 博客内容\nhttps://www.welivesecurity.com/2021/12/01/jumping-air-gap-15-years-nation-state-effort/\n 安天此前也对外分享过关于《高级威胁组织渗透隔离网络能力与年度案例》，感兴趣可以自行查阅。\n针对赌博行业攻击的犯罪团伙 趋势科技的研究人员发现了一个专门攻击赌博网站的 APT 组织 GamblingPuppet。该组织全平台通吃，Windows、Linux 和 macOS 都不放过。\n该攻击组织被认为是一个说中文的团伙，使用了 PlugX、Gh0st RAT 等被认为是与中文攻击者有关的恶意软件，从很多攻击基础设施的命名中也可以发现（实在是太脏，打了码 \u0026hellip; \u0026hellip;）。\n趋势科技也在陆续披露相关研究内容，六月末在 FIRST 2022 上也要讲这一议题。\n 趋势科技博客内容\nhttps://www.trendmicro.com/en_hk/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html\n 期望 Yara 性能再提升 Yara 目前在分析应用中已经越来越普及，当样本量一大，性能又会变成问题。Avast 的研究人员举了一个例子，一个耗时 45 分钟的 Yara 规则优化后甚至可以提升至 3 秒钟，不好的 Yara 规则对系统资源的占用是巨大的。\nAvast 在 Yara 上下了许多功夫，例如开发了将 Yara 规则解析为 AST 的工具 yaramod。还改进了字符串的模式匹配方案，比特币地址匹配可以提速十倍，普通场景下也能提升超过四分之一，这个 PR 日后应该也会被合并进来。\n为了提高效率，尽可能快地得到匹配结果，在性能上有一些需要注意的问题。例如：\n 尽量不要使用正则表达式，消耗大量内存而且拖慢性能 必须要使用正则表达式，避免使用贪婪匹配，且尽量确定匹配上限 元数据也占内存，如果内存并不宽裕，尽量缩减元数据  比较完整的表述可以查看 Neo23x0 大神的文章作为参考。笔者以前翻过旧版本的没有发，日后应该也会把更新过的版本翻出来发在公众号上，着急的同学则可以自行查看原文。\n Yara 性能指南\nhttps://github.com/Neo23x0/YARA-Performance-Guidelines/\n PS：Twitter 上今年年初开启了一个名为 #100DaysofYARA 的话题，本来进行的如火如荼，可惜俄乌冲突后大家都无心看这个了，后续应该也会整理一下这个话题有什么值得分享的内容。 水坑 RTM 僵尸网络 Group-IB 针对 RTM 僵尸网络的分析与水坑方式的介绍。RTM 僵尸网络的攻击概览如下：\n攻击者甚至把 C\u0026amp;C 服务器的地址藏在了比特币交易里：\n研究人员仍然通过极其精巧的方式进行了水坑：\n持续跟踪了受害者的情况，为执法机关的处置提供了依据：\n","permalink":"https://10cks.top/posts/botconf-2022-%E8%AE%AE%E9%A2%98%E9%80%9F%E9%80%92/","summary":"Botconf 2021/22 重新回到线下举办，并且回到了第一届的举办地——法国西海岸的南特。尽管是线下举办，但由于各国的政策要求不一，仍有部分议题的主讲人未能到场进行分享。作为一个在专业领域内比较受认可的会议，本届 Botconf 有来自世界各地的三百多名安全研究人员注册参加。此前，360 Netlab 与绿盟等国内安全公司也有议题在该会议上进行分享，本届也有一个来自阿里云的工作。\n下面只挑选部分议题进行介绍，感兴趣的同学可以去官网查看全部议题进一步了解。\nPS：Botconf 要求参与会议的人员不要录制视频，只有官方能够录制视频。并且每个主讲人都会对内容做出说明，如果表明是机密信息的情况下，请不要拍照或者对外进行相关内容的讨论。所以在遵守该要求的情况下，在公开议题中选取了部分议题进行简要介绍，完整、详细的内容请查看官网或者联系作者。\n监控多个 P2P 僵尸网络的经验见解 来自德国达姆施塔特工业大学、美国马里兰大学和马来西亚理科大学关于监控僵尸网络的研究。研究人员认为监控僵尸网络就像盲人摸象：\nP2P 僵尸网络的三个典型模式：非结构化、结构化、寄生。\n利用爬虫和传感器构建僵尸网络监控系统，以下是一些系统截图（公众号会对图片进行压缩，原图是非常清晰的）：\n该研究监控了 Mozi、Hajime、DDG 等比较大规模的 P2P 僵尸网络，跟踪失陷主机的相关统计信息（如国家、自治系统、地理分布等）。\n研究人员通过双队列并行两万个爬虫获取信息。\n后续研究人员还会增加对 Bot 生命周期的自动测量、对反监控的措施加以完善等其他功能，该项目也欢迎其他研究人员的合作。\n根据通信模式检测利用合法服务进行 C\u0026amp;C 的失陷主机 来自 Akamai 的工作一向扎实。这次内容提到 Akamai 正在努力跟踪发现失陷痕迹，提醒相关用户存在可疑行为。因为很多犯罪分子都会使用合法的 Web 服务来进行攻击。例如 HAMMERTOSS 使用 Twitter、GitHub 和云存储服务进行 C\u0026amp;C 通信。\n典型的三类恶意流量模式：Beacon、DGA 与多信道。\n研究人员发现，使用功率谱密度（PSD）将时域数据转向频域处理，可能会很有效果。清华在 CCS 2021 上也发表了一篇利用频域分析检测恶意流量的工作《Realtime Robust Malicious Traffic Detection via Frequency Domain Analysis》，利用频域分析可能是有潜力的工作方向，感兴趣的同学可以尝试研究。\n正常的设备流量模式与失陷主机的流量模式存在显著差异：\nAkamai 使用 DNS 数据来进行检测：\n在 Akamai 在应用中发现了许多正常情况下难以发现的恶意攻击，例如 uBlock 恶意插件（仿冒合法广告拦截插件的恶意插件）：\nKashmirBlack 僵尸网络的来龙去脉 Imperva 跟踪 PHPUnit 远程代码执行（CVE-2017-9841）漏洞的在野传播，该漏洞影响波及 Drupal、WordPress、PrestaShop 与 Magento 等知名框架。","title":"Botconf 2022 议题速递"},{"content":"build aosp   安装aosp需要的编译依赖 https://source.android.com/setup/build/initializing\n  下载源码 https://source.android.com/setup/build/downloading\n  sudo apt-get update\rsudo apt-get install repo\rmkdir aosp_workdir\rcd aosp_workdir\rrepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b master\rrepo sync 要下很久，可以用sudo iftop来看一下下载速度。\n 编译aosp  source build/envsetup.sh\rlunch aosp_x86_64-eng\rmake -j32 build codeql database 到这里首先我们选择我们想看的目录，这里我选择frameworks/av/media，然后递归touch这个目录下的所有文件，这个作用是为了更新时间戳，这样make的时候，这部分文件就会重新被make\n➜ aosp_workdir cd frameworks/av/media ➜ media git:(011dbb4bf7) find ./ * -exec touch {} \\; 然后设置一个环境变量，并编译db即可，这部分参考自葫芦娃的文章。\nexport ALLOW_NINJA_ENV=true\rcodeql database create out/codeql-frameworks \\\r--language=cpp \\\r--command=\u0026#34;`pwd`/build/soong/soong_ui.bash --make-mode -j16\u0026#34; ","permalink":"https://10cks.top/posts/codeql-%E7%BC%96%E8%AF%91-aosp-database/","summary":"build aosp   安装aosp需要的编译依赖 https://source.android.com/setup/build/initializing\n  下载源码 https://source.android.com/setup/build/downloading\n  sudo apt-get update\rsudo apt-get install repo\rmkdir aosp_workdir\rcd aosp_workdir\rrepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b master\rrepo sync 要下很久，可以用sudo iftop来看一下下载速度。\n 编译aosp  source build/envsetup.sh\rlunch aosp_x86_64-eng\rmake -j32 build codeql database 到这里首先我们选择我们想看的目录，这里我选择frameworks/av/media，然后递归touch这个目录下的所有文件，这个作用是为了更新时间戳，这样make的时候，这部分文件就会重新被make\n➜ aosp_workdir cd frameworks/av/media ➜ media git:(011dbb4bf7) find ./ * -exec touch {} \\; 然后设置一个环境变量，并编译db即可，这部分参考自葫芦娃的文章。\nexport ALLOW_NINJA_ENV=true\rcodeql database create out/codeql-frameworks \\\r--language=cpp \\\r--command=\u0026#34;`pwd`/build/soong/soong_ui.","title":"CodeQL 编译 AOSP database"},{"content":"本文最后更新于 2022 年 2 月。PT 站的前世今生，新手入门指南和概念扫盲。\n专题文章目录  PT 下载从入门到养老篇一：站点介绍及生存指南 PT 下载从入门到养老篇二：隐匿的地下通讯 PT 下载从入门到养老篇三：NAS 存储服务器及硬盘选购  介绍 PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。\n许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。\n目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。\n日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。\n2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。\n国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。\n教育网 PT 站点 以北邮人（北京邮电大学）、蒲公英（西北工业大学）、极速之星（北京理工大学）和六维空间（东北大学）为主。\n高校校园网提供的 IPv4 网络一般是有计费及限速策略的，由校方向电信、联通、移动、鹏博士等运营商采购带宽并在出口实施自动分流。而为了推广 IPv6 业务，各高校所接入的中国教育网（CERNET）的 IPv6 网络一般是不计费且不限速的，因此组建一个依托于 IPv6 的免费资源分享网络有着很大意义。\n一般来说，教育网 PT 站的原创影视资源较少，大部分为转载资源。Coursera、Udacity 等公开课资源（WEB-DL）、考研视频、电子书等内容较多，此外，北邮人等站点还提供一些诸如 Steam 游戏数据备份文件，这样学生就不用担心被几十个 G 的 Steam 游戏更新榨干网费了。\n目前来看教育网 PT 站或多或少获得了学校网络中心的技术和政策支持，所以才能存留至今。部分教育网 PT 站仅允许 IPv6 或仅归属于教育网 ASN 的 IPv6 访问，因此对于公众来说访问有些难度，可以通过 HE.net 提供的 IPv6 TunnelBroker 隧道，或者 IPv6 VPS 来中转流量。\n从分享率和发种规范来看，教育网 PT 十分宽松，但保种率可能不如公网 PT 站高，资源也没那么丰富。但对于追热门电影和美剧的轻度用户来说还是足够了。\n公网 PT 站点 传说中国有五大公网 PT 站：HDS、TTG、HDC、CHD、HDR，也有三大 PT 站的说法（即 CHDbits、HDChina、TTG）。后来经过世界版权日风波（即被称作“中国版权第一案”的思路网侵权案），HDStar（思路网）管理组被捕入狱，剩下的站点也多多少少受到了一些影响，有些直接关闭了，有的则隐没了。\n希望考古中国 PT 站历史的朋友可以查看这个帖子：国内外PT站点评。希望考古国际 PT 站的朋友，可以查看这个帖子：PT站点大全。历史比较悠久了，仅供参考。\n距离版权日风波已经过去了七八年，现在国内 PT 站又呈现出繁荣景象。一方面国内电视剧集的分级制度迟迟未推出，而 Netflix、HBO、Disney+、Apple TV+ 等境外流媒体业务的订阅费用也居高不下。另一方面，国内百兆、千兆家庭宽带已经覆盖到了三四线城市甚至是县城，养一个 PT 账号的成本已经相当低了。\n在此列出几个常见的站点，仅供参考。\n 目前以影视资源为主的有  HDChina 瓷器：近 10 年的老站，用户数据继承自原先的 HDWinG 和 HDStar。资源方面，官方制作组（HDCTV 和 HDChina）的 Netflix、HBO 剧集，原盘，录制的电视剧比较多。 CHDbits 彩虹岛：近 10 年的老站点，影视资源很丰富。 SSD (Spring Sunday)：2010 年创建的老站点，前身为 CMCT 触摸春天。 M-Team 馒头：有比较多的成人内容，官方提供付费邀请码购买渠道。 BT School 比特校园：2019 年刚创建的新站点，门槛相对比较低。 HD Time 高清时间：老站点，但是没什么名气。 52PT 我爱PT：新站点。 HDSky 天空：综合站点。 TTG：国内大站之一，2014 年末作为 TTG 出现。 Ourbits 我堡：算是国内大站了，没啥特色。 HDHome 家园：2015 年左右成立的 PT 站，没啥特色。 PTHome 铂金家：2018 年左右成立的新站，没啥特色。 HDCity 城市：2016 年底成立的新站（相对来说）。 NicePT 老师站：又成为小馒头（相对于 M-Team 来说），主要为成人内容。 CCFBits 精品高清：挺老的大站了，资源很丰富也很低调。 HDR (HDRoute)：前身为 HDRoad 思路高清，历史悠久。 LeagueHD 柠檬：小站中发展的还算不错的，2019 年成立。 Haidan 海胆之家：2020 年刚成立的小站。   教育网 PT，部分 tracker 可能仅允许教育网或 IPv6 连接。入站门槛较低，可以凭借 edu 教育域名的邮箱进行注册，也可以通过校内用户发起邀请。对分享率和种子规范的限制比较宽松。  NanyangPT 南洋：西安交通大学 PT 站 BYR 北邮人：北京邮电大学 PT 站，仅对 IPv6 开放 TJUPT 北洋园：天津大学 PT 站 葡萄PT：上海交通大学 PT 站 NPUPT 蒲公英：西北工业大学 PT 站 BITPT 极速之星：北京理工大学 PT 站 六维空间：东北大学 PT 站 NexusHD：浙江大学 PT 站，仅供校内用户访问。   以动漫资源为主的有  U2 动漫花园 幼儿园：老牌动漫 PT 站。各种上古资源都能找到。 Skyey Snow 天雪动漫：基于 Discuz! 构建的 PT 站点，相对来说新一些。   以音乐资源为主的有  OpenCD 皇后 PT：小体积种子比较多，基本靠攒魔力值来保号。    用户规范 对于用户，无论是公网 PT 站还是教育网 PT 站，往往都有以下要求：\n  上传、下载量：新手考核计划一般为一个月内 \u0026gt;=50GB 的上传下载量。部分教育网 PT 站可能没有新手考核要求。\n  分享率（上传量/下载量）：PT 站的优质资源离不开各位用户的分享和做种。为了减少吸血鬼用户的影响，几乎所有 PT 站点都会要求用户的风险率超过一定值。除此之外，用户分享率与用户等级相关，如果风险率低于标准会自动回退到较低的用户等级。\n  魔力值（Bonus points，即积分，获得于用户赠送、活动奖励或做种）：魔力值可以用于兑换站内头衔、更改用户名、消除广告，甚至至博彩小游戏（例如赌球或 24 点，常见于世界杯期间）。\n  最小做种时间：为了保障种子活跃度，一些 PT 站严格禁止下完就跑（称为 H\u0026amp;R, Hit and Run）的行为，要求用户至少持续做种一定时间）。摘录一段 OpenCD 的规则作为参考。\n在种子下载完成后，该种子需在 30 天内做种 36 小时，未达到此要求则记一次 H\u0026amp;R。\rH\u0026amp;R 满 10 次，即 ban。皇后及以上级别，包括 VIP，计算 HR 次数，但不 ban 号。\r消除已获得的 H\u0026amp;R 的两种方式\r1. 获得 H\u0026amp;R 的种子在 90 天内达到 300 小时做种时间则会自动消除该 H\u0026amp;R\r2. 用魔力值兑换取消 H\u0026amp;R 次数   生存指南 考核期 大部分站点都有邀请考核制度，需要在一个月时间内达成一定的上传量、下载量以及魔力值。部分站点考核由于不计算魔力值的兑换上传量，建议老老实实下载热门种子并做种。\n邀请者可以消耗数倍的魔力值来兑换一个无需新手考核的邀请码。被邀请人也可以付费捐赠（几百元不等）来免除新手考核。\n考核后 对于一些以影视作品为主的网站，尽可能的下载热门种子，这样能更快的获得上传量。可以使用 BT 客户端的 RSS 订阅功能，实现无人值守下载。 对于以小种为主的 PT 站，如 OpenCD 以及大部分教育网站点，则需要通过下载大量小体积种子并长时间做种以换取魔力值，再使用魔力值兑换上传。\n养老期 此时混 PT 只为偶尔下几个资源，而不是那么注重参与了，因此保持一个良好的分享率以备不时之需是很有必要的。\n部分站点可以通过捐赠获得终身 VIP 头衔，从此不再需要担心分享率问题。\n刷流量 想快速将上传、下载流量刷上去，最快的办法就是租用 Seedbox。Seedbox 即专用于跑 BT/PT 的服务器，一般位于海外（德国、罗马尼亚、荷兰）等地。\n可以通过 SeedBox 例如 FeralHosting 或 Seedbox.io 配合 RSS 订阅来实现无人值守下载。由于 Seedbox 带宽相对较大（普遍在 1-10Gbps 左右），盒子间互刷效果过于明显，部分 PT 站会有 seedbox 限制政策，例如限制上传、下载速度或者最大上传量。\n也可以通过 Hetzner、Kimsufi、OVHCloud 等云服务及托管商购买独立服务器（dedicated server，也称作独服、杜甫）。“大盘鸡”是坊间黑话，用以指代硬盘很大的服务器。\n当然，也可以自己搭建黑群晖或直接使用群晖 Synology、威联通 QNAP 等成品 NAS 或使用 OpenMediaVault、VMWare ESXi、UNRaid 搭建私人的 HTPC 平台。\nPT 下载客户端的选择 不同网站对于 BT 客户端的兼容性不同。尤其是 BitTorrent v2 协议推出后，与旧版本的客户端均不兼容。因此部分 PT 站会拒绝较新版本的 BT 软件。此外，普通的 PT 下载器如 Free Download Manager (FDM)、迅雷、Aria2c 以及 qBittorrent-enhanced 是被严格禁止的。\n 99.9% 的 seedbox 用户选择 Rtorrent/Rutorrent，因为有些 seedbox provider 只提供这些。 大部分 Windows 用户选择了 µTorrent (uTorrent)。但是 uTorrent 3.x/4.x 并不稳定，性能也不好，内置了浏览器、工具栏等奇怪的插件。另外一部分用户选择了 qBittorrent。 大部分群晖用户会选择 Synology Download Station；而由于糟糕的兼容性，大部分威联通用户会选择封装好的 qBittorrent。 Linux 用户可能会选择 libtorrent 或 qBittorrent-nox。  注意事项   除非在特定板块，不要在某个 PT 站提到其他 PT 站点的名字。 有些网站管理员非常介意用户流失，或者与其他站点发生过不愉快的事情，因此会对触犯此条例的用户执行封禁。\n  尽可能地尊重发布者，不要在评论区发表不积极的意见。 尊重资源发布者是一种美德。触犯此条例可能会获得警告信或者永久封禁。\n  遇到技术问题应先使用搜索引擎检索，而不是当伸手党。 网站管理员一般非常反感小白用户的问题。\n  不要作弊 由于圈子很小，可能会遭受连锁封禁（被多个站点同时封禁）。\n  不要持有小号（马甲）\n管理员一般会基于以下规则来判断马甲账号\n 用户的登录、注册 IP 用户客户端上报 Tracker 所使用的 IP 用户名及邮箱的命名规律 匿名举报    谨慎选择邀请人，不要随意向陌生人发送邀请。 部分站点对于违反某些规则的用户会采取连坐措施，封禁整个邀请链（树）。\n  不要在公共场合发送、索求邀请码，或者提到网站网址和名称。 这个“传统”已经持续近十年了，只不过是自我安慰。\n  ","permalink":"https://10cks.top/posts/pt-%E4%B8%8B%E8%BD%BD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%BB%E8%80%81%E7%AF%87%E4%B8%80%E7%AB%99%E7%82%B9%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/","summary":"本文最后更新于 2022 年 2 月。PT 站的前世今生，新手入门指南和概念扫盲。\n专题文章目录  PT 下载从入门到养老篇一：站点介绍及生存指南 PT 下载从入门到养老篇二：隐匿的地下通讯 PT 下载从入门到养老篇三：NAS 存储服务器及硬盘选购  介绍 PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。\n许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。\n目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。\n日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。\n2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。\n国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。","title":"PT 下载从入门到养老篇一：站点介绍及生存指南"},{"content":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。\n信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况：\n 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 ……  我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。\n解决问题的办法其实写在了 TCP 报文头上，下面具体分析：\n数据损坏  检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法：  1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum    接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。\n乱序和冗余  字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。  数据丢失  确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\u0026quot;确认\u0026quot;进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u0026lt; RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。  基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多：\n 发送方对数据的处理效率高于接收方，接收方达到处理能力极限，而发送方无法感知，依然大量传递数据，就造成了数据丢失。(流量太快) 发送太多的数据造成数据在信道中过于拥堵，也会造成数据丢失。(流量太多)  这两种情况都会触发 TCP 的重传机制，而重传只会丢失更多数据，应对这两种情况，我们需要更多的机制：\n 流量控制机制：找到 TCP 两方中效率低的一方一次能处理的数据峰值，用 Window 表示，发送方根据 Window 的大小发送数据包，直到接收方收到所有数据包再进行下一次数据发送。 拥塞控制机制：找到信道一次能容纳的数据峰值，具体的实现涉及很多复杂的算法。  可靠性其实是一个很大的话题，有很多细节值得深究，本文只是让读者对可靠性有个基本的认识。\n参考资料\n 车小胖的知乎回答 seq 和 ack 号的正确理解 图解 TCP 重传、滑动窗口、流量控制、拥塞控制  ","permalink":"https://10cks.top/posts/%E5%85%B3%E4%BA%8E-tcp-%E6%88%91%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88/","summary":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。\n信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况：\n 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 ……  我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。\n解决问题的办法其实写在了 TCP 报文头上，下面具体分析：\n数据损坏  检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法：  1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum    接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。\n乱序和冗余  字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。  数据丢失  确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\u0026quot;确认\u0026quot;进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u0026lt; RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。  基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多：","title":"关于TCP我学到了什么"},{"content":"计算机网络在信息时代中的作用 21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。 网络现已成为信息社会的命脉和发展知识经济的重要基础。 网络是指“三网”，即电信网络、有线电视网络和计算机网络。 发展最快的并起到核心作用的是计算机网络。 因特网(Internet)的发展  进入 20 世纪 90 年代以后，以因特网为代表的计算机网络得到了飞速的发展。 已从最初的教育科研网络逐步发展成为商业网络。 已成为仅次于全球电话网的世界第二大网络。  因特网的意义  因特网是自印刷术以来人类通信方面最大的变革。 现在人们的生活、工作、学习和交往都已离不开因特网。  因特网概述 网络的网络  起源于美国的因特网现已发展成为世界上最大的国际性计算机互联网 网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 互联网是“网络的网络”(network of networks)。 连接在因特网上的计算机都称为主机(host)。 网络与因特网  网络把许多计算机连接在一起。 因特网则把许多网络连接在一起。    因特网发展的三个阶段  第一阶段是从单个网络 ARPANET 向互联网发展的过程。  1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。 人们把 1983 年作为因特网的诞生时间。   第二阶段的特点是建成了三级结构的因特网。  三级计算机网络，分为主干网、地区网和校园网（或企业网）。   第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。  出现了因特网服务提供者 ISP (Internet Service Provider)。 根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。    因特网的标准化工作  制订因特网的正式标准要经过以下的四个阶段  因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。 建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。 草案标准(Draft Standard) 因特网标准(Internet Standard)   各种RFC之间的关系  计算机网络在我国的发展 因特网的组成 因特网的边缘部分  由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。  处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统(end system)。 “主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。 即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”    因特网的核心部分  由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）  网络核心部分是因特网中最复杂的部分。 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器(router)。  路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。  在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是：  把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。       路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。    计算机网络在我国的发展 (1) 中国公用计算机互联网 CHINANET (2) 中国教育和科研计算机网 CERNET (3) 中国科学技术网 CSTNET (4) 中国联通互联网 UNINET (5) 中国网通公用互联网 CNCNET (6) 中国国际经济贸易互联网 CIETNET (7) 中国移动互联网 CMNET (8) 中国长城互联网 CGWNET（建设中） (9) 中国卫星集团互联网 CSNET（建设中） 计算机网络的类别 计算机网络的定义  最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。 因特网(Internet)是“网络的网络”。  几种不同类别的网络  不同作用范围的网络  广域网 WAN (Wide Area Network) 局域网 LAN (Local Area Network) 城域网 MAN (Metropolitan Area Network) 个人区域网 PAN (Personal Area Network)   从网络的使用者进行分类  公用网 (public network) 专用网 (private network)    计算机网络的性能 计算机网络的性能指标  速率  比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。 Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。 速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等 速率往往是指额定速率或标称速率。   带宽  “带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。 现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 常用的带宽单位  更常用的带宽单位是 千比每秒，即 kb/s （103 b/s） 兆比每秒，即 Mb/s（106 b/s） 吉比每秒，即 Gb/s（109 b/s） 太比每秒，即 Tb/s（1012 b/s） 请注意：在计算机界，K = 210 = 1024 M = 220, G = 230, T = 240。   数字信号流随时间的变化  在时间轴上信号的宽度随带宽的增大而变窄。     吞吐量  吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。   时延(delay 或 latency)  传输时延（发送时延 ） 发送数据时，数据块从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 传播时延 电磁波在信道中需要传播一定的距离而花费的时间。 信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。 处理时延 交换结点为存储转发而进行一些必要的处理所花费的时间。 排队时延 结点缓存队列中分组排队所经历的时延。 排队时延的长短往往取决于网络中当时的通信量。 数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和：   时延带宽积  链路的时延带宽积又称为以比特为单位的链路长度。   利用率  信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。 信道利用率并非越高越好。   时延与网络利用率的关系  根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系：  U 是网络的利用率，数值在 0 到 1 之间。      计算机网络的非性能特征  费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护  计算机网络的体系结构 计算机网络体系结构的形成  相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。 “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。  协议与划分层次  划分层次的必要性  计算机网络中的数据交换必须遵守事先约定好的规则。 这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。 网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。   网络协议的组成要素  语法 数据与控制信息的结构或格式 。 语义 需要发出何种控制信息，完成何种动作以及做出何种响应。 同步 事件实现顺序的详细说明。   分层的好处  各层之间是独立的。 灵活性好。 结构上可分割开。 易于实现和维护。 能促进标准化工作。    具有五层协议的体系结构  TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。 但最下面的网络接口层并没有具体内容。 因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。  实体、协议、服务和服务访问点  实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 要实现本层协议，还需要使用下层所提供的服务。 本层的服务用户只能看见服务而无法看见下面的协议。 下面的协议对上面的服务用户是透明的。 协议是“水平的”，即协议是控制对等实体之间通信的规则。 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。 同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。 协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。  Internet 和 Internet 的区别 以小写字母 i 开始的 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。 以大写字母I开始的的 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。 万维网 WWW 的问世 因特网已经成为世界上规模最大和增长速率最快的计算机网络，没有人能够准确说出因特网究竟有多大。 因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 WWW (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。 客户软件的特点 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。 不需要特殊的硬件和很复杂的操作系统。 服务器软件的特点 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。 一般需要强大的硬件和高级的操作系统支持。 因特网的边缘部分与核心部分 两种国际标准 法律上的(de jure)国际标准 OSI 并没有得到市场的认可。 是非国际标准 TCP/IP 现在获得了最广泛的应用。 TCP/IP 常被称为事实上的(de facto) 国际标准。 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 分组交换 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 添加首部构成分组  每一个数据段前面添加上首部构成分组  分组交换的传输单元  分组交换网以“分组”作为数据传输单元。 依次把各分组发送到接收端（假定接收端在左边）  分组首部的重要性  每一个分组的首部都含有地址等控制信息。 分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。 用这样的存储转发方式，最后分组就能到达最终目的地。  收到分组后剥去首部  接收端收到分组后剥去首部还原成报文  最后还原成原来的报文 分组交换的优点  高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。  分组交换带来的问题  分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。  电路交换 两部电话机只需要用一对电线就能够互相连接起来。 更多的电话机互相连通  5 部电话机两两相连，需 10 对电线。 N 部电话机两两相连，需 N(N – 1)/2 对电线。 当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。  使用交换机  当电话机的数量增多时，就要使用交换机来完成全网的交换任务。  电路交换的特点  电路交换必定是面向连接的。 电路交换的三个阶段：  建立连接 通信 释放连接   电路交换传送计算机数据效率低  计算机数据具有突发性。 这导致通信线路的利用率很低。    三种交换的比较 两种通信方式 客户服务器方式（C/S 方式） 即Client/Server方式  客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。 客户服务器方式所描述的是进程之间服务和被服务的关系。 客户是服务的请求方，服务器是服务的提供方。  对等方式（P2P 方式） 即 Peer-to-Peer方式  对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。 双方都可以下载对方已经存储在硬盘中的共享文档。 对等连接方式的特点  对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。 例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。    TCP/IP 的体系结构 关于开放系统互连参考模型OSI/RM 只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。 在市场化方面 OSI 却失败了。  OSI 的专家们在完成 OSI 标准时没有商业驱动力； OSI 的协议实现起来过分复杂，且运行效率很低； OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场； OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现。  ","permalink":"https://10cks.top/posts/%E7%AC%AC1%E7%AB%A0-%E6%A6%82%E8%BF%B0/","summary":"计算机网络在信息时代中的作用 21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。 网络现已成为信息社会的命脉和发展知识经济的重要基础。 网络是指“三网”，即电信网络、有线电视网络和计算机网络。 发展最快的并起到核心作用的是计算机网络。 因特网(Internet)的发展  进入 20 世纪 90 年代以后，以因特网为代表的计算机网络得到了飞速的发展。 已从最初的教育科研网络逐步发展成为商业网络。 已成为仅次于全球电话网的世界第二大网络。  因特网的意义  因特网是自印刷术以来人类通信方面最大的变革。 现在人们的生活、工作、学习和交往都已离不开因特网。  因特网概述 网络的网络  起源于美国的因特网现已发展成为世界上最大的国际性计算机互联网 网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 互联网是“网络的网络”(network of networks)。 连接在因特网上的计算机都称为主机(host)。 网络与因特网  网络把许多计算机连接在一起。 因特网则把许多网络连接在一起。    因特网发展的三个阶段  第一阶段是从单个网络 ARPANET 向互联网发展的过程。  1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。 人们把 1983 年作为因特网的诞生时间。   第二阶段的特点是建成了三级结构的因特网。  三级计算机网络，分为主干网、地区网和校园网（或企业网）。   第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。  出现了因特网服务提供者 ISP (Internet Service Provider)。 根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。    因特网的标准化工作  制订因特网的正式标准要经过以下的四个阶段  因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。 建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。 草案标准(Draft Standard) 因特网标准(Internet Standard)   各种RFC之间的关系  计算机网络在我国的发展 因特网的组成 因特网的边缘部分  由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。  处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统(end system)。 “主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。 即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”    因特网的核心部分  由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）  网络核心部分是因特网中最复杂的部分。 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器(router)。  路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。  在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是：  把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。       路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。    计算机网络在我国的发展 (1) 中国公用计算机互联网 CHINANET (2) 中国教育和科研计算机网 CERNET (3) 中国科学技术网 CSTNET (4) 中国联通互联网 UNINET (5) 中国网通公用互联网 CNCNET (6) 中国国际经济贸易互联网 CIETNET (7) 中国移动互联网 CMNET (8) 中国长城互联网 CGWNET（建设中） (9) 中国卫星集团互联网 CSNET（建设中） 计算机网络的类别 计算机网络的定义  最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。 因特网(Internet)是“网络的网络”。  几种不同类别的网络  不同作用范围的网络  广域网 WAN (Wide Area Network) 局域网 LAN (Local Area Network) 城域网 MAN (Metropolitan Area Network) 个人区域网 PAN (Personal Area Network)   从网络的使用者进行分类  公用网 (public network) 专用网 (private network)    计算机网络的性能 计算机网络的性能指标  速率  比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。 Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。 速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等 速率往往是指额定速率或标称速率。   带宽  “带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。 现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 常用的带宽单位  更常用的带宽单位是 千比每秒，即 kb/s （103 b/s） 兆比每秒，即 Mb/s（106 b/s） 吉比每秒，即 Gb/s（109 b/s） 太比每秒，即 Tb/s（1012 b/s） 请注意：在计算机界，K = 210 = 1024 M = 220, G = 230, T = 240。   数字信号流随时间的变化  在时间轴上信号的宽度随带宽的增大而变窄。     吞吐量  吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。   时延(delay 或 latency)  传输时延（发送时延 ） 发送数据时，数据块从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 传播时延 电磁波在信道中需要传播一定的距离而花费的时间。 信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。 处理时延 交换结点为存储转发而进行一些必要的处理所花费的时间。 排队时延 结点缓存队列中分组排队所经历的时延。 排队时延的长短往往取决于网络中当时的通信量。 数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和：   时延带宽积  链路的时延带宽积又称为以比特为单位的链路长度。   利用率  信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。 信道利用率并非越高越好。   时延与网络利用率的关系  根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系：  U 是网络的利用率，数值在 0 到 1 之间。      计算机网络的非性能特征  费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护  计算机网络的体系结构 计算机网络体系结构的形成  相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。 “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。  协议与划分层次  划分层次的必要性  计算机网络中的数据交换必须遵守事先约定好的规则。 这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。 网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。   网络协议的组成要素  语法 数据与控制信息的结构或格式 。 语义 需要发出何种控制信息，完成何种动作以及做出何种响应。 同步 事件实现顺序的详细说明。   分层的好处  各层之间是独立的。 灵活性好。 结构上可分割开。 易于实现和维护。 能促进标准化工作。    具有五层协议的体系结构  TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。 但最下面的网络接口层并没有具体内容。 因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。  实体、协议、服务和服务访问点  实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 要实现本层协议，还需要使用下层所提供的服务。 本层的服务用户只能看见服务而无法看见下面的协议。 下面的协议对上面的服务用户是透明的。 协议是“水平的”，即协议是控制对等实体之间通信的规则。 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。 同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。 协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。  Internet 和 Internet 的区别 以小写字母 i 开始的 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。 以大写字母I开始的的 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。 万维网 WWW 的问世 因特网已经成为世界上规模最大和增长速率最快的计算机网络，没有人能够准确说出因特网究竟有多大。 因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 WWW (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。 客户软件的特点 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。 不需要特殊的硬件和很复杂的操作系统。 服务器软件的特点 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。 一般需要强大的硬件和高级的操作系统支持。 因特网的边缘部分与核心部分 两种国际标准 法律上的(de jure)国际标准 OSI 并没有得到市场的认可。 是非国际标准 TCP/IP 现在获得了最广泛的应用。 TCP/IP 常被称为事实上的(de facto) 国际标准。 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 主机 1 向主机 2 发送数据 分组交换 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 添加首部构成分组  每一个数据段前面添加上首部构成分组  分组交换的传输单元  分组交换网以“分组”作为数据传输单元。 依次把各分组发送到接收端（假定接收端在左边）  分组首部的重要性  每一个分组的首部都含有地址等控制信息。 分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。 用这样的存储转发方式，最后分组就能到达最终目的地。  收到分组后剥去首部  接收端收到分组后剥去首部还原成报文  最后还原成原来的报文 分组交换的优点  高效 动态分配传输带宽，对通信链路是逐段占用。 灵活 以分组为传送单位和查找路由。 迅速 不必先建立连接就能向其他主机发送分组。 可靠 保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。  分组交换带来的问题  分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。  电路交换 两部电话机只需要用一对电线就能够互相连接起来。 更多的电话机互相连通  5 部电话机两两相连，需 10 对电线。 N 部电话机两两相连，需 N(N – 1)/2 对电线。 当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。  使用交换机  当电话机的数量增多时，就要使用交换机来完成全网的交换任务。  电路交换的特点  电路交换必定是面向连接的。 电路交换的三个阶段：  建立连接 通信 释放连接   电路交换传送计算机数据效率低  计算机数据具有突发性。 这导致通信线路的利用率很低。    三种交换的比较 两种通信方式 客户服务器方式（C/S 方式） 即Client/Server方式  客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。 客户服务器方式所描述的是进程之间服务和被服务的关系。 客户是服务的请求方，服务器是服务的提供方。  对等方式（P2P 方式） 即 Peer-to-Peer方式  对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。 双方都可以下载对方已经存储在硬盘中的共享文档。 对等连接方式的特点  对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。 例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。    TCP/IP 的体系结构 关于开放系统互连参考模型OSI/RM 只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。 在市场化方面 OSI 却失败了。  OSI 的专家们在完成 OSI 标准时没有商业驱动力； OSI 的协议实现起来过分复杂，且运行效率很低； OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场； OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现。  ","title":"第 1 章 概述"},{"content":"物理层的基本概念 物理层的主要任务描述为确定与传输媒体的接口的一些特性   机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。\n  电气特性 指明在接口电缆的各条线上出现的电压的范围。\n  功能特性 指明某条线上出现的某一电平的电压表示何种意义。\n  过程特性 指明对于不同功能的各种可能事件的出现顺序。\n数据通信的基础知识 数据通信系统的模型   有关信道的几个基本概念   单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。\n  双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n  双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。\n  几种最基本的调制方法\n  调幅(AM)：载波的振幅随基带数字信号而变化。\n  调频(FM)：载波的频率随基带数字信号而变化。\n  调相(PM) ：载波的初始相位随基带数字信号而变化。\n  概要: 图片\n信道的极限容量     信道能够通过的频率范围\n 1924 年，奈奎斯特(Nyquist)就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值    信噪比\n  香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。 信道的极限信息传输速率 C 可表达为 C = W log2(1+S/N) b/s W 为信道的带宽（以 Hz 为单位）； S 为信道内所传信号的平均功率； N 为信道内部的高斯噪声功率。\n  香农公式表明\n  信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。\n  只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。\n  若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。\n  实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。\n信道的极限信息传输速率 物理层下面的传输媒体 导向传输媒体         双绞线\n 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair)    同轴电缆\n 50 Ω同轴电缆 75 Ω 同轴电缆    光缆\n  光纤的工作原理\n  光线在纤芯中传输的方式是不断地全反射\n非导向传输媒体       无线传输所使用的频段很广。\n  短波通信主要是靠电离层的反射，但短波信道的通信质量较差。\n  微波在空间主要是直线传播。\n  卫星通信\n  地面微波接力通信\n信道复用技术 频分复用、时分复用和统计时分复用     频分复用 FDM(Frequency Division Multiplexing)\n 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。  示意图      时分复用TDM(Time Division Multiplexing)\n 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。  示意图      统计时分复用 STDM\u000b(Statistic TDM)\n  是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。\n  示意图\n波分复用       波分复用 WDM(Wavelength Division Multiplexing)\n  光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。\n码分复用     码分复用 CDM(Code Division Multiplexing)\n 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。 具体内容  1.为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 S 和 T 有 2.为了讨论方便，取 m=8，设码片 s 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。      在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到(其中 S\u0026rsquo; 为 S 的反码。) * 3.利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 * 码分复用需要发送的数据量为原先的 m 倍。\n数字传输系统 脉码调制 PCM 体制 同步光纤网 SONET 和同步数字系列 SDH 宽带接入技术 xDSL技术   xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。\n光纤同轴混合网（HFC 网）   HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。\nFTTx 技术   FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。\n 光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。 光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。 光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。    ","permalink":"https://10cks.top/posts/%E7%AC%AC2%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/","summary":"物理层的基本概念 物理层的主要任务描述为确定与传输媒体的接口的一些特性   机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。\n  电气特性 指明在接口电缆的各条线上出现的电压的范围。\n  功能特性 指明某条线上出现的某一电平的电压表示何种意义。\n  过程特性 指明对于不同功能的各种可能事件的出现顺序。\n数据通信的基础知识 数据通信系统的模型   有关信道的几个基本概念   单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。\n  双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n  双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。\n  几种最基本的调制方法\n  调幅(AM)：载波的振幅随基带数字信号而变化。\n  调频(FM)：载波的频率随基带数字信号而变化。\n  调相(PM) ：载波的初始相位随基带数字信号而变化。\n  概要: 图片\n信道的极限容量     信道能够通过的频率范围\n 1924 年，奈奎斯特(Nyquist)就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值    信噪比\n  香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。 信道的极限信息传输速率 C 可表达为 C = W log2(1+S/N) b/s W 为信道的带宽（以 Hz 为单位）； S 为信道内所传信号的平均功率； N 为信道内部的高斯噪声功率。","title":"第 2 章  物理层"},{"content":"使用点对点信道的数据链路层 数据链路和帧  数据链路层使用的信道主要有以下两种类型：  点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发   数据链路层模型 链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层传送的是帧  三个基本问题  (1) 封装成帧  将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 *   (2) 透明传输  透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 *   (3) 差错控制   循环冗余检验 CRC 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。\n  帧检验序列 FCS 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。\n  冗余码的计算\n 例子： 现在 k = 6, M = 101001。 设 n = 3, 除数 P = 1101， 被除数是 2^nM = 101001000。 模 2 运算的结果是：商 Q = 110101， 余数 R = 001。 把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2^nM + R 即：101001001，共 (k + n) 位。    概要: CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。\n    点对点协议 PPP PPP 协议的特点  互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。  PPP 协议的帧格式  示意图： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500  PPP 协议的工作状态  过程： 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。  使用广播信道的数据链路层 局域网的数据链路层  局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类：  星形网 环形网 总线网 树形网   数据链路层的两个子层  逻辑链路控制 LLC (Logical Link Control)子层 媒体接入控制 MAC (Medium Access Control)子层。 概要: 与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的 所以以后一般不考虑 LLC 子层   适配器  网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (Network Interface Card)，或“网卡”。  适配器的重要功能：  进行串行/并行转换。 对数据进行缓存。 在计算机的操作系统安装设备驱动程序。 实现以太网协议。        CSMA/CD 协议  CSMA/CD 表示载波监听多点接入 / 碰撞检测。  多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。   具体内容  记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 概要: 示意图    使用广播信道的以太网 使用集线器的星形拓扑  传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。 这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub)  以太网的信道利用率  一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间 τ 使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。 发送一帧占用线路的时间是 T0 + τ ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为：  以太网的 MAC 层  MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。  以太网帧格式：  类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法；  扩展的以太网 在物理层扩展以太网  用多个集线器可连成更大的局域网  用集线器组成更大的局域网都在一个碰撞域中  优点  使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。 扩大了局域网覆盖的地理范围。   缺点  碰撞域增大了，但总的吞吐量并未提高。 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。        在数据链路层扩展以太网  在数据链路层扩展局域网是使用网桥。  网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。 网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口 。  优点  过滤通信量。 扩大了物理范围。 提高了可靠性。 可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。   缺点  存储转发增加了时延。 在MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。 网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。     交换机  交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。  下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。        虚拟局域网  虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。  高速以太网 100BASE-T 以太网  速率达到或超过 100 Mb/s 的以太网称为高速以太网 可在全双工方式下工作而无冲突发生。因此，不使用 CSMA/CD 协议。  吉比特以太网  允许在 1 Gb/s 下全双工和半双工两种方式工作。 在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。  10 吉比特以太网  10 吉比特以太网只工作在全双工方式 也不使用 CSMA/CD 协议。  使用高速以太网进行宽带接入  以太网接入的重要特点是它可提供双向的宽带通信，并且可根据用户对带宽的需求灵活地进行带宽升级。 采用以太网接入可实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率和降低了传输的成本。  其他类型的高速局域网接口 集线器在转发帧时，不对传输媒体进行检测。 网桥在转发帧之前必须执行 CSMA/CD 算法。\n","permalink":"https://10cks.top/posts/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","summary":"使用点对点信道的数据链路层 数据链路和帧  数据链路层使用的信道主要有以下两种类型：  点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发   数据链路层模型 链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层传送的是帧  三个基本问题  (1) 封装成帧  将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 *   (2) 透明传输  透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 *   (3) 差错控制   循环冗余检验 CRC 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。\n  帧检验序列 FCS 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。\n  冗余码的计算\n 例子： 现在 k = 6, M = 101001。 设 n = 3, 除数 P = 1101， 被除数是 2^nM = 101001000。 模 2 运算的结果是：商 Q = 110101， 余数 R = 001。 把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2^nM + R 即：101001001，共 (k + n) 位。    概要: CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。","title":"第 3 章  数据链路层"},{"content":"网络层提供的两种服务 虚电路服务 数据报服务 概要: 虚电路服务与数据报服务的对比 网际协议 IP 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有四个协议：  地址解析协议 ARP (Address Resolution Protocol) 逆地址解析协议 RARP (Reverse Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 概要: 示意图  虚拟互连网络  网络互相连接起来要使用一些中间设备  物理层中继系统：转发器(repeater)。 数据链路层中继系统：网桥或桥接器(bridge)。 网络层中继系统：路由器(router)。 网桥和路由器的混合物：桥路器(brouter)。 网络层以上的中继系统：网关(gateway)。    IP 数据报的格式  版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。  IP数据报分片   概要: 示意图  分类的 IP 地址  IP 地址的编址方式经历了三个历史阶段：  分类  由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {\u0026lt; 网络号 \u0026gt;, \u0026lt; 主机号 \u0026gt;}  示意图     子网划分  通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。      IP 地址 ::= {\u0026lt; 网络号 \u0026gt;, \u0026lt; 子网号 \u0026gt;, \u0026lt; 主机号 \u0026gt;}\n要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。\n注意，外部网络看不到子网的存在。 * 无分类 * 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。\nIP 地址 ::= {\u0026lt; 网络前缀号 \u0026gt;, \u0026lt; 主机号 \u0026gt;}\nCIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\nCIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。\n一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。\n在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。\nIP 地址与硬件地址  IP层抽象的互联网屏蔽了下层很复杂的细节 在抽象的网络层上讨论问题，就能够使用 统一的、抽象的 IP 地址 研究主机和主机或主机和路由器之间的通信  示意图    地址解析协议 ARP 与逆地址解析协议RARP  缘由  网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。   地址解析协议 ARP  ARP 实现由 IP 地址得到 MAC 地址  每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。      如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 * 示意图\n 逆地址解析协议 RARP  逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。  这种主机往往是无盘工作站。 因此 RARP协议目前已很少使用。      IP 层转发分组的流程  分组转发算法  (1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。 (2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。 (3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。 (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。 (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。 (6) 报告转发分组出错。 概要: 示意图    划分子网和构造超网 划分子网 使用子网时分组转发 无分类编址 CIDR（构造超网） 网际控制报文协议 ICMP 简介  ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。  ICMP 报文的种类  ICMP 差错报告报文  终点不可达 源点抑制(Source quench) 时间超过 参数问题 改变路由（重定向）(Redirect)   ICMP 询问报文  回送请求和回答报文 时间戳请求和回答报文   ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。  ICMP 的应用举例    Ping   Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。    Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。\n  Traceroute   Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。    Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 * 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； * 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 * 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 * 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。\n因特网的路由选择协议 有关路由选择协议的几个基本概念  静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。  自治系统 AS(Autonomous System)  自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。  内部网关协议 IGP (Interior Gateway Protocol)  即在一个自治系统内部使用的路由选择协议。  内部网关协议 RIP  RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。      RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 * 距离向量算法： * 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； * 对修改后的 RIP 报文中的每一个项目，进行以下步骤： * 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； * 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 * 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 * RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 * 内部网关协议 OSPF * 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。\n开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 * OSPF 具有以下特点： * 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 * 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 * 只有当链路状态发生变化时，路由器才会发送信息。 * 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。\n外部网关协议 BGP (External Gateway Protocol)  若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 AS 之间的路由选择很困难，主要是由于：  互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。   BGP 只能寻找一条比较好的路由，而不是最佳路由。  每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 * 示意图\n路由器的构成  路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。 路由器从功能上可以划分为  路由选择 分组转发   分组转发结构由三个部分组成  交换结构 一组输入端口 一组输出端口 概要: 示意图    IP 多播 IP 多播的基本概念  多播可明显地减少网络中资源的消耗  在局域网上进行硬件多播 因特网组管理协议 IGMP 和多播路由选择协议  IGMP 使多播路由器\u000b知道多播组成员信息 多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。  虚拟专用网 VPN 和网络地址转换 NAT 虚拟专用网 VPN  由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。  有三个专用地址块：  10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255     VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。  网络地址转换 NAT  专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。  因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 ","permalink":"https://10cks.top/posts/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/","summary":"网络层提供的两种服务 虚电路服务 数据报服务 概要: 虚电路服务与数据报服务的对比 网际协议 IP 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有四个协议：  地址解析协议 ARP (Address Resolution Protocol) 逆地址解析协议 RARP (Reverse Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 概要: 示意图  虚拟互连网络  网络互相连接起来要使用一些中间设备  物理层中继系统：转发器(repeater)。 数据链路层中继系统：网桥或桥接器(bridge)。 网络层中继系统：路由器(router)。 网桥和路由器的混合物：桥路器(brouter)。 网络层以上的中继系统：网关(gateway)。    IP 数据报的格式  版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。  IP数据报分片   概要: 示意图  分类的 IP 地址  IP 地址的编址方式经历了三个历史阶段：  分类  由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {\u0026lt; 网络号 \u0026gt;, \u0026lt; 主机号 \u0026gt;}  示意图     子网划分  通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。      IP 地址 ::= {\u0026lt; 网络号 \u0026gt;, \u0026lt; 子网号 \u0026gt;, \u0026lt; 主机号 \u0026gt;}","title":"第 4 章 网络层"},{"content":"第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 * 1 * 2 * 3 * 4\n超时重传时间的选择  超时重传  TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。    一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： * 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：（其中 RTTd 为偏差的加权平均值）\n选择确认 SACK TCP的流量控制 利用滑动窗口实现流量控制  TCP 流量控制  流量控制是为了控制发送方发送速率，保证接收方来得及接收。    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n 流量控制举例  必须考虑传输效率 TCP 的拥塞控制 拥塞控制的一般原理  如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 拥塞控制所起的作用  几种拥塞控制方法  TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。  发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。    为了便于讨论，做如下假设：\n接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 * 1. 慢开始与拥塞避免 * 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 \u0026hellip;\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd \u0026gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 * 2. 快重传与快恢复 * 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n随机早期检测 RED TCP 的运输连接管理 TCP 的连接建立  假设 A 为客户端，B 为服务器端。  首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\nA 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。\nB 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。\nA 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\nB 收到 A 的确认后，连接建立。\n 三次握手的原因  第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。    客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\nTCP 的连接释放  以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。  A 发送连接释放报文，FIN=1。\nB 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n当 B 不再需要连接时，发送连接释放报文，FIN=1。\nA 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\nB 收到 A 的确认后释放连接。\n 四次挥手的原因  客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。   TIME_WAIT  客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：  确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。      TCP 的有限状态机  粗实线箭头表示对客户进程的正常变迁。 粗虚线箭头表示对服务器进程的正常变迁。 另一种细线箭头表示异常变迁。  ","permalink":"https://10cks.top/posts/%E7%AC%AC5%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/","summary":"第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。","title":"第 5 章 运输层"},{"content":"第 6 章 应用层 域名系统 DNS 域名系统概述  DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。  因特网的域名结构  域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。  域名服务器  一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。  DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：  如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。    文件传送协议 FTP 概述  文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。 FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。  FTP 的基本工作原理  FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：  控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。   根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：  主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。    简单文件传送协议 TFTP  TFTP 是一个很小且易于实现的文件传送协议。 TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。 TFTP 只支持文件传输而不支持交互。 TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 TFTP 的主要特点是 (1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。 (2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。 (3) 支持 ASCII 码或二进制传送。 (4) 可对文件进行读或写。 (5) 使用很简单的首部。  远程终端协议 TELNET 简述  TELNET 是一个简单的远程终端协议，也是因特网的正式标准。 用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。 TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。  万维网 WWW 概述  万维网 WWW (World Wide Web)并非某种特殊的计算机网络。 万维网是一个大规模的、联机式的信息储藏所。 万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。 这种访问方式称为“链接”。 万维网是分布式超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充。  万维网的工作方式  万维网以客户服务器方式工作。 浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。  万维网必须解决的问题  (1) 怎样标志分布在整个因特网上的万维网文档？ 使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。 使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 (2) 用何协议实现万维网上各种超链的链接？ 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 (3) 怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ 超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 (4) 怎样使用户能够很方便地找到所需的信息？ 为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。  统一资源定位符 URL  统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。 URL 的一般形式是：\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;  超文本传送协议 HTTP  HTTP 是面向事务的客户服务器协议。 HTTP 1.0 协议是无状态的(stateless)。 HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。  万维网的文档  超文本标记语言 HTML  超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。 HTML 定义了许多用于排版的命令（即标签）。 HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。   动态万维网文档  静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。    万维网的信息检索系统  全文检索搜索  全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到因特网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。   分类目录搜索  分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。    电子邮件 电子邮件概述  电子邮件(e-mail)是因特网上使用得最多的和最受用户欢迎的一种应用。 电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取。 电子邮件不仅使用方便，而且还具有传递迅速和费用低廉的优点。 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。  电子邮件的最主要的组成构件 简单邮件传送协议 SMTP  SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。  电子邮件的信息格式  一个电子邮件分为信封和内容两大部分。 RFC 822 只规定了邮件内容中的首部(header)格式，而对邮件的主体(body)部分则让用户自由撰写。  邮件内容的首部  “To:”后面填入一个或多个收件人的电子邮件地址。用户只需打开地址簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。 “Subject:”是邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。 抄送 “Cc:” 表示应给某某人发送一个邮件副本。 “From” 和 “Date” 表示发信人的电子邮件地址和发信日期。“Reply-To” 是对方回信所用的地址。      邮件读取协议 POP3 和 IMAP  POP3  POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。   IMAP  IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。    基于万维网的电子邮件  例子  电子邮件从 A 发送到网易邮件服务器是使用 HTTP 协议。 两个邮件服务器之间的传送使用 SMTP。 邮件从新浪邮件服务器传送到 B 是使用 HTTP 协议。 概要: 示意图    通用因特网邮件扩充 MIME  MIME 概述  MIME 并没有改动 SMTP 或取代它。 MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。    动态主机配置协议 DHCP DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下：  1.客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 2.DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 3.如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 4.DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。  简单网络管理协议 SNMP 网络管理的基本概念  网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。 SNMP 的网络管理由三个部分组成  SNMP 本身  SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象（变量）名及其状态（值）。   管理信息结构 SMI (Structure of Management Information)  SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。   管理信息库 MIB(Management Information Base)。  MIB 在被管理的实体中创建了命名对象，并规定了其类型。      管理信息结构 SMI  SMI 的功能：  (1) 被管对象应怎样命名； (2) 用来存储被管对象的数据类型有哪些种； (3) 在网络上传送的管理数据应如何编码。    管理信息库 MIB  被管对象必须维持可供管理程序读写的若干控制和状态信息。这些信息总称为管理信息库 MIB 。  SNMP 的协议数据单元和报文  SNMP的操作只有两种基本的管理功能，即：  “读”操作，用 get 报文来检测各被管对象的状况； “写”操作，用 set 报文来改变各被管对象的状况。   SNMP 的报文格式  ","permalink":"https://10cks.top/posts/%E7%AC%AC6%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/","summary":"第 6 章 应用层 域名系统 DNS 域名系统概述  DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。  因特网的域名结构  域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。  域名服务器  一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。  DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：  如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。    文件传送协议 FTP 概述  文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。 FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。 FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。  FTP 的基本工作原理  FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：  控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。   根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：  主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。    简单文件传送协议 TFTP  TFTP 是一个很小且易于实现的文件传送协议。 TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。 TFTP 只支持文件传输而不支持交互。 TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 TFTP 的主要特点是 (1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。 (2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。 (3) 支持 ASCII 码或二进制传送。 (4) 可对文件进行读或写。 (5) 使用很简单的首部。  远程终端协议 TELNET 简述  TELNET 是一个简单的远程终端协议，也是因特网的正式标准。 用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。 TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。  万维网 WWW 概述  万维网 WWW (World Wide Web)并非某种特殊的计算机网络。 万维网是一个大规模的、联机式的信息储藏所。 万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。 这种访问方式称为“链接”。 万维网是分布式超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充。  万维网的工作方式  万维网以客户服务器方式工作。 浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。  万维网必须解决的问题  (1) 怎样标志分布在整个因特网上的万维网文档？ 使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。 使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 (2) 用何协议实现万维网上各种超链的链接？ 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。 HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 (3) 怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ 超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 (4) 怎样使用户能够很方便地找到所需的信息？ 为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。  统一资源定位符 URL  统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。 URL 的一般形式是：\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt;  超文本传送协议 HTTP  HTTP 是面向事务的客户服务器协议。 HTTP 1.","title":"第 6 章 应用层"},{"content":"markdown 里写代码块 这部分用直观的对照一个一个例子来呈现，先展示代码块渲染在页面上的样子，紧接着展示 markdown 源码怎么写。\n1. 最普通的用法 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  markdown 写法：\n1 2 3 4 5  ```rust fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   对于不带行号的代码块，默认的样式布局可能会显得有些局促，调整一下文章的 CSS：\n1 2 3 4 5  /* 不带行号的代码块 */ .highlight\u0026gt;pre { padding: 10px; /* 适当留出边距 */ overflow: auto; /* 代码行太长向右滚动 */ }   2. 带行号的 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table} fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   上面代码中用到了扩展语法，也就是紧跟在 rust 后、花括号内的部分。\n这里用到的参数是 lineos，有以下两种取值：\n inline：代码行号内联在代码块里，鼠标框选代码时会选中行号 table：鼠标框选代码时不会选中行号，方便复制粘贴 table 目前有个小瑕疵就是行号和代码对不齐，需要在文章的 CSS 中设置一下 line-height：  1 2 3 4  .highlight{ /* 统一行高，让行号和代码能对齐 */ line-height: 18px; }   3. 自定义起始行号 渲染效果：\n21 22 23  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table, linenostart=21} fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   linenostart=21 表示代码块从第 21 行开始计数。典型的使用场景是，在一大段代码中单摘出一小段，为保留原有的代码行号，就可以这么来用。\n4. 行高亮 我们有时候会有把某些行高亮，用来强调突出，像下面这样：\n渲染效果：\n1 2 3 4 5 6 7  fn main(){another_function(5);}fn another_function(x: i32){println!(\u0026#34;The value of x is: {}\u0026#34;,x);}  对应的 markdown 写法：\n1 2 3 4 5 6 7 8 9  ```rust {linenos=table, hl_lines=[2 \u0026#34;5-6\u0026#34;]} fn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026#34;The value of x is: {}\u0026#34;, x); } ```   这里 hl_lines 就表示有哪些行高亮，它的值是一个集合，上面的例子中有两部分做了高亮。首先是第 2 行，接下来是第 5-6 行，当连续多行高亮时，可以用 ”起始行号-截止行号“ 的写法。其中「起始行号」和「截止行号」并非指左侧的代码行号，而是从这个代码块中的第一行开始数起。例如下面这段：\n渲染效果：\n21 22 23  fn main(){another_function(5);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table, linenostart=21, hl_lines=[2]} fn main() { another_function(5); } ```   代码行号从第 21 行开始，高亮的是本代码块的第 2 行，于是实际是第 22 行高亮。\n","permalink":"https://10cks.top/posts/markdown%E9%87%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%9D%97/","summary":"markdown 里写代码块 这部分用直观的对照一个一个例子来呈现，先展示代码块渲染在页面上的样子，紧接着展示 markdown 源码怎么写。\n1. 最普通的用法 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  markdown 写法：\n1 2 3 4 5  ```rust fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   对于不带行号的代码块，默认的样式布局可能会显得有些局促，调整一下文章的 CSS：\n1 2 3 4 5  /* 不带行号的代码块 */ .highlight\u0026gt;pre { padding: 10px; /* 适当留出边距 */ overflow: auto; /* 代码行太长向右滚动 */ }   2. 带行号的 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：","title":"markdown里写代码块"},{"content":"hugo博客通过简码的方式插入ppt、bilibili、youtube等功能\n创建: 2022-04-16 | 更新: 2022-04-16 | 字数: 676字 | 时长: 2分钟 | 作者: Sulv | 标签:\nHugo 、博客搭建\n1. 引入 ppt 功能 定位到 layouts/shortcodes目录，新建一个文件叫 ppt.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #googleslides_shortcodes { padding-bottom: 66%; position: relative; display: block; width: 100%; border-bottom: 5px solid; } #googleslides_shortcodes iframe { position: absolute; top: 0; left: 0 } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;googleslides_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;googleSlideIframe\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; src=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34; frameborder=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;\u0026#34; \u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   2. 引入 bilibili 视频 定位到 layouts/shortcodes目录，新建一个文件叫 bilibili.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .bilibili_shortcodes { position: relative; width: 100%; height: 0; padding-bottom: 66%; margin: auto; overflow: hidden; text-align: center; } .bilibili_shortcodes iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;bilibili_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe src=\u0026#34;https://player.bilibili.com/player.html?bvid={{.Get 0 }}\u0026amp;page={{ if .Get 1 }}{{.Get 1}}{{ else }}1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026amp;as_wide=0{{end}}\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   3. 引入 youtube 视频 定位到 layouts/shortcodes目录，新建一个文件叫 youtube.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .youtube_shortcodes { position: relative; width: 100%; height: 0; padding-bottom: 66%; margin: auto; overflow: hidden; text-align: center; } .youtube_shortcodes iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;youtube_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe class=\u0026#34;youtube-player\u0026#34; type=\u0026#34;text/html\u0026#34; width=\u0026#34;640\u0026#34; height=\u0026#34;385\u0026#34; src=\u0026#34;https://www.youtube.com/embed/{{ index .Params 0 }}?autoplay=0\u0026#34; style=\u0026#34; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\u0026#34; allowfullscreen frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   4. 使用方法 在写文章的时候，直接按如下方式书写就可以\n4.1 ppt 展示 1 2  {a{\u0026lt; ppt src=\u0026#34;ppt网址\u0026#34; \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效   ppt展示效果：\n4.2 bilibili 视频 1 2 3 4  {a{\u0026lt; bilibili BV1Ab4y117G2 \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效 # BV1Ab4y117G2 指的是 bilibili 链接中的 bvid # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{a{\u0026lt; bilibili BV1Ab4y117G2 5 \u0026gt;}}   4.3 youtube 视频 1 2  {a{\u0026lt; youtube Fm4oT4QJbWs \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效   5. 参考链接 https://caymanhk.gitee.io/posts/006_hugo%E9%80%9A%E8%BF%87shortcodes%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91/\nhttps://zhuanlan.zhihu.com/p/396330042\nhttps://tin6.com/post/several-hugo-shortcoeds-samples/\n","permalink":"https://10cks.top/posts/hugo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89shortcodes/","summary":"hugo博客通过简码的方式插入ppt、bilibili、youtube等功能\n创建: 2022-04-16 | 更新: 2022-04-16 | 字数: 676字 | 时长: 2分钟 | 作者: Sulv | 标签:\nHugo 、博客搭建\n1. 引入 ppt 功能 定位到 layouts/shortcodes目录，新建一个文件叫 ppt.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #googleslides_shortcodes { padding-bottom: 66%; position: relative; display: block; width: 100%; border-bottom: 5px solid; } #googleslides_shortcodes iframe { position: absolute; top: 0; left: 0 } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;googleslides_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;googleSlideIframe\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; src=\u0026#34;{{ .","title":"Hugo博客自定义shortcodes"},{"content":"1 2 3 4 5  git init git add . git commit -m \u0026#34;date\u0026#34; git remote add origin https://github.com/10cks/10cks.github.io.git git push -u -f origin master   ","permalink":"https://10cks.top/posts/github_page%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/","summary":"1 2 3 4 5  git init git add . git commit -m \u0026#34;date\u0026#34; git remote add origin https://github.com/10cks/10cks.github.io.git git push -u -f origin master   ","title":"Github_page搭建指南"},{"content":"反函数 函数有反函数的充要条件：不同等x等于不同的y。\n求一个函数的反函数，例如$y=f(x)$，实质上就是把x与y的值对调，然后再求$y=f(x)$。\n初等函数与基本初等函数 由常数和基本初等函数经过有限次的加减乘除和复合所得到且能用一个解析式表示的函数，称为初等函数。\n","permalink":"https://10cks.top/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E8%BF%9E%E7%BB%AD/","summary":"反函数 函数有反函数的充要条件：不同等x等于不同的y。\n求一个函数的反函数，例如$y=f(x)$，实质上就是把x与y的值对调，然后再求$y=f(x)$。\n初等函数与基本初等函数 由常数和基本初等函数经过有限次的加减乘除和复合所得到且能用一个解析式表示的函数，称为初等函数。","title":""},{"content":"求一元二次方程组的解 $$ {\\begin{array}{*{20}{l}} {\\text{对}\\text{于}\\text{如}\\text{下}\\text{形}\\text{式}\\text{的}\\text{一}\\text{元}\\text{二}\\text{次}\\text{方}\\text{程}\\text{：}}\\ {a\\mathop{{x}}\\nolimits^{{2}}+bx+c=0}\\ {\\text{则}\\text{方}\\text{程}\\text{的}\\text{两}\\text{根}\\text{为}\\text{：}}\\ {\\mathop{{x}}\\nolimits_{{1}}=\\frac{{-b+\\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}}\\ {\\mathop{{x}}\\nolimits_{{2}}=\\frac{{-b-\\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}} \\end{array}} $$\n求根公式 $$ \\begin{array}{{20}{l}} {a\\mathop{{x}}\\nolimits^{{2}}+bx+c=0}\\ { \\Delta =\\mathop{{b}}\\nolimits^{{2}}-4ac}\\ { \\left{ \\begin{array}{{20}{c}} { \\Delta \u0026gt; 0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}}\\ { \\Delta =0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}}\\ { \\Delta \u0026lt; 0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}} \\end{array}\\right. }\\ {\\mathop{{x}}\\nolimits_{{1,2}}=\\frac{{-b \\pm \\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}}\\ {\\mathop{{x}}\\nolimits_{{1}}+\\mathop{{x}}\\nolimits_{{2}}=-\\frac{{b}}{{a}}}\\ {\\mathop{{x}}\\nolimits_{{1}}\\mathop{{x}}\\nolimits_{{2}}=\\frac{{c}}{{a}}} \\end{array} $$\nLatex公式网\n","permalink":"https://10cks.top/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0/%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F/","summary":"求一元二次方程组的解 $$ {\\begin{array}{*{20}{l}} {\\text{对}\\text{于}\\text{如}\\text{下}\\text{形}\\text{式}\\text{的}\\text{一}\\text{元}\\text{二}\\text{次}\\text{方}\\text{程}\\text{：}}\\ {a\\mathop{{x}}\\nolimits^{{2}}+bx+c=0}\\ {\\text{则}\\text{方}\\text{程}\\text{的}\\text{两}\\text{根}\\text{为}\\text{：}}\\ {\\mathop{{x}}\\nolimits_{{1}}=\\frac{{-b+\\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}}\\ {\\mathop{{x}}\\nolimits_{{2}}=\\frac{{-b-\\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}} \\end{array}} $$\n求根公式 $$ \\begin{array}{{20}{l}} {a\\mathop{{x}}\\nolimits^{{2}}+bx+c=0}\\ { \\Delta =\\mathop{{b}}\\nolimits^{{2}}-4ac}\\ { \\left{ \\begin{array}{{20}{c}} { \\Delta \u0026gt; 0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}}\\ { \\Delta =0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}}\\ { \\Delta \u0026lt; 0\\text{方}\\text{程}\\text{有}\\text{两}\\text{个}\\text{相}\\text{等}\\text{的}\\text{实}\\text{根}} \\end{array}\\right. }\\ {\\mathop{{x}}\\nolimits_{{1,2}}=\\frac{{-b \\pm \\sqrt{{\\mathop{{b}}\\nolimits^{{2}}-4ac}}}}{{2a}}}\\ {\\mathop{{x}}\\nolimits_{{1}}+\\mathop{{x}}\\nolimits_{{2}}=-\\frac{{b}}{{a}}}\\ {\\mathop{{x}}\\nolimits_{{1}}\\mathop{{x}}\\nolimits_{{2}}=\\frac{{c}}{{a}}} \\end{array} $$\nLatex公式网","title":""},{"content":"$$ \\lim_{x\\to 0}\\frac{sinx}{x} $$\n","permalink":"https://10cks.top/about/","summary":"about","title":"About"},{"content":"计算机技术  IDA Pro权威指南第二版 汇编语言第三版 深入理解计算机系统第三版（CSAPP） 自顶向下计算机网络第七版 编译原理第二版（龙书） 编译器设计第二版 第一行代码第二版 第一行代码第三版 Android编程权威指南 操作系统精髓与设计原理第八版 加密与解密第四版 数据隐藏技术揭秘 游戏安全——手游安全技术入门 揭秘家用路由器0day漏洞挖掘技术  文学  生死疲劳 鱼王 玫瑰的名字 奥地利史 艾希曼在耶路撒冷 德国通史 看不见的城市 世界简史 剧本 对白 故事 遗落的南境：湮灭 江南三部曲 河边的错误 静静的顿河 活着为了讲述 动物庄园 月亮和六便士 三体全集 飘 霍乱时期的爱情 拉丁美洲被切开的血管 球桌闪电 西西弗神话 理想国 查拉图斯特拉如是说 自然哲学的数学原理 雪国 1984 神经漫游者 鼠疫 原则  医学 ","permalink":"https://10cks.top/list/","summary":"list","title":"List"},{"content":"是针对footer.css 这个文件的修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  .footer, .top-link { font-size: 12px; color: var(--secondary); } .footer { max-width: calc(var(--main-width) + var(--gap) * 2); margin: auto; padding: calc((var(--footer-height) - var(--gap)) / 2) var(--gap); text-align: center; line-height: 24px; } .footer span { margin-inline-start: 1px; margin-inline-end: 1px; } .footer span:last-child { white-space: nowrap; } .footer a { color: inherit; border-bottom: 1px solid var(--secondary); } .footer a:hover { border-bottom: 1px solid var(--primary); } .top-link { visibility: hidden; position: fixed; bottom: 60px; right: 30px; z-index: 99; background: var(--tertiary); width: 42px; height: 42px; padding: 12px; border-radius: 64px; transition: visibility 0.5s, opacity 0.8s linear; } .top-link, .top-link svg { filter: drop-shadow(0px 0px 0px var(--theme)); } .footer a:hover, .top-link:hover { color: var(--primary); } .top-link:focus, #theme-toggle:focus { outline: 0; } /* 划分线 */ /* 鼠标浮动 */ .post-entry:hover { transition: transform 0.3s; -webkit-transform: scale(1.2); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1) translateZ(0) translate3d(0, 0, 0) rotate(0); /* padding: 30px; 放大 /* 解析： transform:scale(值)；它的值是指定的缩放的倍率，比如： 0.5就是缩放到50%； 1就是100%； 1.5就是放大150%； 可能值：scale（x,y)是元素X轴Y轴同时缩放； scaleX（x)是元素X轴缩放； scaleY（y)是元素Y轴缩放； */ } .entry-link:hover { border-radius: 5px; box-shadow: 0px 0px 5px 0px rgb(236, 100, 9); width: 100%; height: 100%; line-height: 40px; padding-left: 20px; border-left: 3px solid rgb(236, 100, 9); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  :root { --nav-width: 1100px; --article-width: 650px; --toc-width: 200px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; /* border-right: 1px solid var(--border); */ right: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } /*blank.css文件，这里用来设置边目录*/   设置元数据要用.Params.password\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  :root { --gap: 24px; --content-gap: 20px; --nav-width: 1024px; --main-width: 720px; --header-height: 60px; --footer-height: 60px; --radius: 8px; --theme: rgb(255, 255, 255); --entry: rgb(255, 255, 255); --primary: rgb(30, 30, 30); --secondary: rgb(108, 108, 108); --tertiary: rgb(214, 214, 214); --content: rgb(31, 31, 31); --hljs-bg: rgb(28, 29, 33); --code-bg: rgb(212, 212, 212); --border: rgb(238, 238, 238); } /*修改主题背景色*/   hover的标题颜色修改是修改的footer.css中的代码\n1 2 3  .post-entry:hover h2{ color: rgb(231, 26, 26); }   修改代码背景色\n1 2 3 4 5 6 7 8 9 10 11  /*blank.css文件*/ :root { --nav-width: 1100px; --article-width: 650px; --toc-width: 200px; --hljs-bg: rgb(48, 10, 36); /*修改代码背景色*/ } .dark { --hljs-bg: rgb(48, 10, 36); }   1 2 3 4 5 6 7 8  .archive-entry:hover{ border-radius: 2px; /*这里设置边框圆角*/ border-bottom:; /*这里设置下划线*/ border-top:0px; border-left:2px solid #ee1313; border-right:0px; /* box-shadow: 0px 0px 5px 0px rgb(119, 113, 109); */ }   ","permalink":"https://10cks.top/posts/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84css/","summary":"是针对footer.css 这个文件的修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  .","title":"本博客使用的css"}]