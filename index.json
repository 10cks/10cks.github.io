[{"content":"书籍学习 外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。\nAndroid系统安全   Android安全架构深究\n  Android安全攻防权威指南\n  Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)\n  Android安全技术揭秘与防范\n  Android软件安全与逆向分析\n  Android系统基础   Android的设计与实现*卷1\n  深入理解Android卷1*邓凡平\n  深入理解Android卷2_邓凡平\n  深入理解Android卷3_邓凡平\n  Android技术内幕.系统卷\n  Android系统级深入开发.移植与调试\n  Android深度探索（卷2）系统应用源代码分析与ROM定制\n  拨云见日-基于android的内核与系统架构源码分析\n  Android底层开发技术实战详解 内核、移植和驱动 Android源码设计模式解析与实战\n  Android：Wi-Fi NFC和GPS\n  Android系统原理及开发要点详解(韩超,梁泉)\n  Android框架揭秘(带完整书签高清扫描版)\n  Linux内核  ORANGE’S：一个操作系统的实现 Linux内核设计与实现_第三版 Linux内核设计的艺术 Linux内核完全注释V3.0书签版 30天自制操作系统.川合秀实  ","permalink":"https://10cks.top/posts/android%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/","summary":"书籍学习 外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。\nAndroid系统安全   Android安全架构深究\n  Android安全攻防权威指南\n  Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)\n  Android安全技术揭秘与防范\n  Android软件安全与逆向分析\n  Android系统基础   Android的设计与实现*卷1\n  深入理解Android卷1*邓凡平\n  深入理解Android卷2_邓凡平\n  深入理解Android卷3_邓凡平\n  Android技术内幕.系统卷\n  Android系统级深入开发.移植与调试\n  Android深度探索（卷2）系统应用源代码分析与ROM定制\n  拨云见日-基于android的内核与系统架构源码分析\n  Android底层开发技术实战详解 内核、移植和驱动 Android源码设计模式解析与实战\n  Android：Wi-Fi NFC和GPS\n  Android系统原理及开发要点详解(韩超,梁泉)\n  Android框架揭秘(带完整书签高清扫描版)\n  Linux内核  ORANGE’S：一个操作系统的实现 Linux内核设计与实现_第三版 Linux内核设计的艺术 Linux内核完全注释V3.","title":"Android系统安全书籍"},{"content":" Rime 输入法  1.1. 基础配置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南\n Rime 的各种配置，均是由 .yaml 文件所定义。yaml 是一种标记语言。.yaml 文件实际上是文本文档。可使用记事本、或 Emeditor 等进行编辑。 对 Rime 进行自定义，是通过对 .custom.yaml 文件修改达成。不同的 .custom.yaml 文件，控制不同的功能实现。.custom.yaml 实际上是相当于对 .yaml 文件打补丁，在重新部署后，会将 .custom.yaml 中的内容写入 .yaml 文件中，完成自定。  例一：weasel.yaml 是常规设置，主要控制托盘图标、候选词横竖排列、界面配色等等功能。那么，我们需要定制界面配色，只需在 weasel.custom.yaml 中修改，重新部署后就可实现。 例二：default.yaml 是默认设置，主要控制快捷键、按键上屏等等。同样，作修改就编辑 default.custom.yaml 文件即可。 例三：以上是全局设置，亦即不论使用何种输入方案，均起作用。double_pinyin_flypy.custom.yaml 这种则是输入法方案设置。主要实现特殊标点符号、词库等功能。是针对特定输入方案的配置。    可见，我们绝大部分的自定，都只需修改对应的 .custom.yaml 文件即可。\n 所有自定修改，都必须重新部署。在开始菜单可以找到【小狼毫】重新部署。  1.2. 皮肤设置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南\n打开 weasel.custom.yaml 文件，若没有，则新建。所有自定义项均在 patch: 下，注意缩进\n1 2 3 4 5 6 7 8 9 10 11 12 13  customization:distribution_code_name:Weaseldistribution_version:0.14.3generator:\u0026#34;Weasel::UIStyleSettings\u0026#34;modified_time:\u0026#34;Mon Jul 13 11:31:05 2020\u0026#34;rime_version:1.5.3patch:\u0026#34;style/color_scheme\u0026#34;: google# 皮肤风格\u0026#34;style/layout/border_width\u0026#34;: 0\u0026#34;style/layout/border\u0026#34;: 0\u0026#34;style/horizontal\u0026#34;: true#横排显示候选词\u0026#34;style/font_face\u0026#34;: Microsoft YaHei# 候选词字体\u0026#34;style/font_point\u0026#34;: 12# 候选词字号  一个模仿 Windows 10 自带的微软拼音皮肤的设置如下，以供修改尝试参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  customization:distribution_code_name:Weaseldistribution_version:0.14.3generator:\u0026#34;Weasel::UIStyleSettings\u0026#34;modified_time:\u0026#34;Thu Jun 27 17:32:21 2019\u0026#34;rime_version:1.5.3patch:\u0026#34;style/display_tray_icon\u0026#34;: true\u0026#34;style/horizontal\u0026#34;: true#横排显示\u0026#34;style/font_face\u0026#34;: \u0026#34;Microsoft YaHei\u0026#34;#字体\u0026#34;style/font_point\u0026#34;: 13#字体大小\u0026#34;style/inline_preedit\u0026#34;: true# 嵌入式候选窗单行显示\u0026#34;style/layout/border_width\u0026#34;: 0\u0026#34;style/layout/border\u0026#34;: 0\u0026#34;style/layout/margin_x\u0026#34;: 12#候选字左右边距\u0026#34;style/layout/margin_y\u0026#34;: 12#候选字上下边距\u0026#34;style/layout/hilite_padding\u0026#34;: 12#候选字背景色色块高度 若想候选字背景色块无边界填充候选框，仅需其高度和候选字上下边距一致即可\u0026#34;style/layout/hilite_spacing\u0026#34;: 3# 序号和候选字之间的间隔\u0026#34;style/layout/spacing\u0026#34;: 10#作用不明\u0026#34;style/layout/candidate_spacing\u0026#34;: 24# 候选字间隔\u0026#34;style/layout/round_corner\u0026#34;: 0#候选字背景色块圆角幅度\u0026#34;style/color_scheme\u0026#34;: Micosoft\u0026#34;preset_color_schemes/Micosoft\u0026#34;:name:\u0026#34;Micosoft\u0026#34;author:\u0026#34;XNOM\u0026#34;back_color:0xffffff#候选框 背景色border_color:0xD77800#候选框 边框颜色text_color:0x000000#已选择字 文字颜色hilited_text_color:0x000000#已选择字右侧拼音 文字颜色hilited_back_color:0xffffff#已选择字右侧拼音 背景色hilited_candidate_text_color:0xffffff#候选字颜色hilited_candidate_back_color:0xD77800#候选字背景色candidate_text_color:0x000000#未候选字颜色  1.3. 特殊符号快速输入 百度贴吧. 小狼毫输入法怎么输入希腊字母和数学符号\n首先确定使用的拼音方案，比如如果使用 luna_pinyin_simp （明月拼音简化字）方案，那么新建 lunar_pinyin_simp.custom.yaml 配置文件，写入：\n1 2 3  patch:\u0026#34;punctuator/import_preset\u0026#34;:symbols\u0026#34;recognizer/patterns/punct\u0026#34;: \u0026#34;^/([A-Z|a-z]*|[0-9]|10)$\u0026#34;  然后小狼毫文件夹里点击 小狼毫重新部署，即可。\n通过 / 键配合缩写实现快速输入。注意使用键盘的 ? 键唤起，而不是小键盘的 / 键。\n 输入 /xl 直接给出希腊字母，如 \\alphaα 等。 输入 /sx 直接给出常用数学符号，如 ±, ÷ 等。 输入 /jh 直接给出一些特殊符号，如 ■，□，▣，▥ 等。  1.4. shift 直接上屏且切换中英文 Xeon-Shao. 小狼毫（Rime）输入法设置Shift直接上屏英文字符并切换为英文状态方法\n小狼毫默认输入方式下，左Shift键只切换为英文，右Shift键直接上屏中文。这对于用惯了搜狗的人来说在进行中英文混输的时候经常出错，特别影响效率，接下来提供方法解决这个问题。\n 开始菜单中，找到小狼毫的文件夹，打开 “用户资料文件夹”，如果有 weasel.custom.yaml，则复制一份，复制后的文件重命名为 default.custom.yaml；如果没有，则自己新建文件命名为 default.custom.yaml，并将内容修改为如下：  1 2 3 4 5 6 7 8  customization:distribution_code_name:Weaseldistribution_version:0.12.0generator:\u0026#34;Weasel::UIStyleSettings\u0026#34;modified_time:\u0026#34;Thu Nov 15 09:43:07 2018\u0026#34;rime_version:1.3.2patch:\u0026#34;ascii_composer/switch_key/Shift_L\u0026#34;: commit_code   小狼毫文件夹里点击 “小狼毫重新部署”；  Shift_L: commit_code 的意思是：其中 L 指 Left，左的意思。commit- 提交。code－ 代码。 当我们输入一段文字未上屏之前，按此键后字符将被将直接上屏。\n","permalink":"https://10cks.top/posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","summary":"Rime 输入法  1.1. 基础配置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南\n Rime 的各种配置，均是由 .yaml 文件所定义。yaml 是一种标记语言。.yaml 文件实际上是文本文档。可使用记事本、或 Emeditor 等进行编辑。 对 Rime 进行自定义，是通过对 .custom.yaml 文件修改达成。不同的 .custom.yaml 文件，控制不同的功能实现。.custom.yaml 实际上是相当于对 .yaml 文件打补丁，在重新部署后，会将 .custom.yaml 中的内容写入 .yaml 文件中，完成自定。  例一：weasel.yaml 是常规设置，主要控制托盘图标、候选词横竖排列、界面配色等等功能。那么，我们需要定制界面配色，只需在 weasel.custom.yaml 中修改，重新部署后就可实现。 例二：default.yaml 是默认设置，主要控制快捷键、按键上屏等等。同样，作修改就编辑 default.custom.yaml 文件即可。 例三：以上是全局设置，亦即不论使用何种输入方案，均起作用。double_pinyin_flypy.custom.yaml 这种则是输入法方案设置。主要实现特殊标点符号、词库等功能。是针对特定输入方案的配置。    可见，我们绝大部分的自定，都只需修改对应的 .custom.yaml 文件即可。\n 所有自定修改，都必须重新部署。在开始菜单可以找到【小狼毫】重新部署。  1.2. 皮肤设置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南\n打开 weasel.custom.yaml 文件，若没有，则新建。所有自定义项均在 patch: 下，注意缩进\n1 2 3 4 5 6 7 8 9 10 11 12 13  customization:distribution_code_name:Weaseldistribution_version:0.","title":"Rime输入法使用指南"},{"content":"RSA 相信很多同学还在使用 RSA 算法用于生成 SSH 公钥，可能还会纠结选择多少位才足够安全，一般建议是 4096 bits:\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 这样我们的公钥(public key) 就会非常长：\ncat test_rsa_4096.pub\rssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCXlH8OxqMFhv2+En10yV2ZorDzRFXQm9pPuWQ8G5iu+cUpyhwDoKnd+l6PCZTrCgcVJgLSsVAVbZ3CK6Qnoj3TDQl4yaj90UasmivWM2INc2hObr5P2y2AqWnnZBXmxpoUGZPz/9323JalC+m/EwXNcdrC5JzgD083BC0ykfB801vcAzrZwsnbKfCUsGfUNP9mco3+hFwTqgfJxEvmI3X6hbGIGY1d2QbGMLrs3JYVsfRzJDjFaYOSwXZR6pM5uUCKENt9hOmVUZfuZqvlzLZX95yc53a6qNgOJhzaFZYz3wD2gY0dNp1boGnAtXsLqEnqtm9skp05iMuT01B9WrKEOZG5rsRZDh3bYXJ8ZP0lO/RbStuBczd8ZgObb32NfUyHG2JObDpm9mjsvWZqJxJbT5l/6vMXu8hQ6ikDrf6R33PRcRdbUIrAOpDUrfBxjkUonxjqqEbHhpcAlMWNJ4qcjtjvSnLOhH9GBn5KCnFJ7VIbyXc+Gj9AAp9xuV/9jv1R7CathkS2QrC5s9pFY3I24mFevpkioEeJYPAYUTuFBenWg5MdFK99FYO44wjmFa/RxwEQtYFXV+RybTJTC0eDpjK1u3w7LVm2JjEVoSfOJIKt9yZQn5Fm0kmueBz5aQ4CzZNoZBMKr7TT0dX9cJoANzd19uM4uCV6HRVJmQyz4Q== your_email@example.com Ed25519 其实，有一些更先进的算法，比 RSA 更安全，公钥更简短，随着区块链的普及，它们正慢慢被更多的人接受，比如 Ed25519，虽然它只有 256 bit，但安全性比 RSA 3072 还要高。\nEd25519 SSH Key 生成：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 公钥：\ncat test_ed25519.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGcMXqCXtcjny9gXV1NDmwArHy0AgJs+R7N6XpOutviw your_email@example.com Github 已经默认推荐大家使用 Ed25519: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nEd25519 是一个椭圆曲线，非常优美，安全性经过数学严格证明：\nBy Deirdre Connolly in [State of the Curve] (2016)\n这里有一份目前使用 Ed25519 的列表： https://ianix.com/pub/ed25519-deployment.html\n","permalink":"https://10cks.top/posts/%E4%BD%BF%E7%94%A8-ecdsa-%E6%9B%BF%E6%8D%A2-rsa-%E7%94%9F%E6%88%90-ssh-key/","summary":"RSA 相信很多同学还在使用 RSA 算法用于生成 SSH 公钥，可能还会纠结选择多少位才足够安全，一般建议是 4096 bits:\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 这样我们的公钥(public key) 就会非常长：\ncat test_rsa_4096.pub\rssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCXlH8OxqMFhv2+En10yV2ZorDzRFXQm9pPuWQ8G5iu+cUpyhwDoKnd+l6PCZTrCgcVJgLSsVAVbZ3CK6Qnoj3TDQl4yaj90UasmivWM2INc2hObr5P2y2AqWnnZBXmxpoUGZPz/9323JalC+m/EwXNcdrC5JzgD083BC0ykfB801vcAzrZwsnbKfCUsGfUNP9mco3+hFwTqgfJxEvmI3X6hbGIGY1d2QbGMLrs3JYVsfRzJDjFaYOSwXZR6pM5uUCKENt9hOmVUZfuZqvlzLZX95yc53a6qNgOJhzaFZYz3wD2gY0dNp1boGnAtXsLqEnqtm9skp05iMuT01B9WrKEOZG5rsRZDh3bYXJ8ZP0lO/RbStuBczd8ZgObb32NfUyHG2JObDpm9mjsvWZqJxJbT5l/6vMXu8hQ6ikDrf6R33PRcRdbUIrAOpDUrfBxjkUonxjqqEbHhpcAlMWNJ4qcjtjvSnLOhH9GBn5KCnFJ7VIbyXc+Gj9AAp9xuV/9jv1R7CathkS2QrC5s9pFY3I24mFevpkioEeJYPAYUTuFBenWg5MdFK99FYO44wjmFa/RxwEQtYFXV+RybTJTC0eDpjK1u3w7LVm2JjEVoSfOJIKt9yZQn5Fm0kmueBz5aQ4CzZNoZBMKr7TT0dX9cJoANzd19uM4uCV6HRVJmQyz4Q== your_email@example.com Ed25519 其实，有一些更先进的算法，比 RSA 更安全，公钥更简短，随着区块链的普及，它们正慢慢被更多的人接受，比如 Ed25519，虽然它只有 256 bit，但安全性比 RSA 3072 还要高。\nEd25519 SSH Key 生成：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 公钥：\ncat test_ed25519.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGcMXqCXtcjny9gXV1NDmwArHy0AgJs+R7N6XpOutviw your_email@example.com Github 已经默认推荐大家使用 Ed25519: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nEd25519 是一个椭圆曲线，非常优美，安全性经过数学严格证明：\nBy Deirdre Connolly in [State of the Curve] (2016)\n这里有一份目前使用 Ed25519 的列表： https://ianix.com/pub/ed25519-deployment.html","title":"使用 ECDSA 替换 RSA 生成 SSH Key"},{"content":"在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\u0026#34;/usr/bin/echo\u0026#34;, [\u0026#34;echo\u0026#34;, \u0026#34;evilpan\u0026#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \u0026#34;/etc/ld.so.preload\u0026#34;, R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=19285, ...}) = 0 mmap(NULL, 19285, PROT_READ, MAP_PRIVATE, 3, 0) = 0x79aecf8000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib/aarch64-linux-gnu/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\267\\0\\1\\0\\0\\0p\\16\\2\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 fstat(3, {st_mode=S_IFREG|0777, st_size=1439544, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79aecf6000 mmap(NULL, 1511520, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79aeb5e000 mprotect(0x79aecb7000, 61440, PROT_NONE) = 0 mmap(0x79aecc6000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x158000) = 0x79aecc6000 mmap(0x79aeccc000, 12384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79aeccc000 close(3) = 0 mprotect(0x79aecc6000, 16384, PROT_READ) = 0 mprotect(0x5787f5f000, 4096, PROT_READ) = 0 mprotect(0x79aecff000, 4096, PROT_READ) = 0 munmap(0x79aecf8000, 19285) = 0 brk(NULL) = 0x57b1bd2000 brk(0x57b1bf3000) = 0x57b1bf3000 fstat(1, {st_mode=S_IFCHR|0600, st_rdev=makedev(0x88, 0x2), ...}) = 0 write(1, \u0026#34;evilpan\\n\u0026#34;, 8evilpan ) = 8 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++   对于需要监控系统调用的场景，strace 是个非常合适的工具，因为它基于 PTRACE_SYSCALL 去跟踪并基于中断的方式去接管所有系统调用，因此即便目标使用了不依赖 libc 的内联 svc 也可以被识别到。不过这个缺点也很明显，从名称也看出来，本质上该程序是基于 ptrace 对目标进行跟踪，因此如果对方代码中有反调试措施，那么就很有可能被检测到。\n另外在 Android 系统中，APP 进程都是由 zygote fork 而出，因此使用 strace 比较不容易确定跟踪时机，而且由于许多应用有多个进程，就需要对输出结果进行额外的过滤和清洗。\n 更多关于 strace 的实现原理可以参考: How does strace work?\n jtrace 在早期 strace 程序还不支持 arm64，因此 Jonathan Levin 在编写 Android Internal 一书时就写了 jtrace 这个工具，旨在用于对 Android 应用的跟踪。虽然现在 Google 也在 AOSP 中支持了 strace，但 jtrace 仍然有其独特的优点:\n 支持系统属性的访问监控 (setprop/getprop) 支持输入事件的监控 (InputReader) 支持 Binder 信息的解析 支持 AIDL 的解析 ……  虽然 jtrace 是闭源的，但提供了独特的插件功能，用户可以根据其提供的接口去编写一个插件(动态库)，并使用 --plugin 参数或者 JTRACE_EXT_PATH 环境变量指定的路径加载插件，从而实现自定义的系统调用参数解析处理。\n虽然优点比 strace 多了不少，但其缺点并没有解决，jtrace 本身依然是基于 PTRACE_SYSCALL 进行系统调用跟踪的，因此还是很容易被应用的反调试检测到。\n 详见: http://newandroidbook.com/tools/jtrace.html\n Frida frida 是目前全球最为知名的动态跟踪工具集 (Instrumentation)，支持使用 js 脚本来对目标应用程序进行动态跟踪。相信读者对于 frida 已经不陌生，这里也就不再过多介绍。其功能之丰富毋庸置疑，但也有一些硬伤，比如:\n frida-gum 基于 inline-hook 对目标跟踪代码进行实时重编译 (JIT)，对于应用本身有较大的侵入性； frida-inject 需要依赖 ptrace 对目标应用进行第一次注入并加载 agent，有一个较短的注入窗口可能会被反调试应用检测到； frida 目前尚不支持系统调用事件级别的追踪，虽然 frida-stalker 可以做到汇编级别，但是开销过大； frida 太过知名，以至于有很多针对 frida 的特征检测； ……  类似的 Instrumentation 工具还有 QDBI，hookzz 等等。\n其他 除了上面提到的这些工具，还有很多其他工具可以进行动态监控，比如 ltrace、gdb 等但这些工具都不能完美实现我的需求。既要马儿跑得快(开销小)，又要马儿不吃草(无侵入)，那我们就只有把眼光放向内核了。\nKernel Tracing 101 如果目标是为了实现系统调用监控，以及部分系统调用参数的修改(例如 IO 重定向)，那么一个直观的想法是修改内核源码，在我们感兴趣的系统调用入口插入自己的代码实现具体功能。但是这样非常低效，一来我们要在不同的系统调用相关函数中增加代码，引入过多修改后会导致更新内核合并上游提交变得困难；二来我们每次修改后都需要重新编译内核以及对应的 AOSP 代码(因为内核在 boot.img 中，详见后文)，再烧写到手机或模拟器中，流程过于复杂。\n另外一个想法是通过在内核代码中引入一次性的 trampoline，然后在后续增加或者减少系统调用监控入口时通过内核模块的方式去进行修改。这样似乎稍微合理一些，但其实内核中已经有了许多类似的监控方案，这样做纯属重复造轮子，效率低不说还可能随时引入 kernel panic。\n大局观 那么，内核中都有哪些监控方案？这其实不是一个容易回答的问题，我们在日常运维时听说过 kprobe、jprobe、uprobe、eBPF、tracefs、systemtab、perf，……到底他们之间的的关系是什么，分别都有什么用呢？\n这里推荐一篇文章: Linux tracing systems \u0026amp; how they fit together，根据其中的介绍，这些内核监控方案/工具可以分为三类:\n 数据: 根据监控数据的来源划分 采集: 根据内核提供给用户态的原始事件回调接口进行划分 前端: 获取和解析监控事件数据的用户工具  后面对这些监控方案分别进行简要的介绍。\nkprobe 简单来说，kprobe 可以实现动态内核的注入，基于中断的方法在任意指令中插入追踪代码，并且通过 pre_handler/post_handler/fault_handler 去接收回调。\n使用 参考 Linux 源码中的 samples/kprobes/kprobe_example.c，一个简单的 kprobe 内核模块实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026lt;linux/kernel.h\u0026gt;#include \u0026lt;linux/module.h\u0026gt;#include \u0026lt;linux/kprobes.h\u0026gt; #define MAX_SYMBOL_LEN 64 static char symbol[MAX_SYMBOL_LEN] = \u0026#34;_do_fork\u0026#34;; module_param_string(symbol, symbol, sizeof(symbol), 0644); /* For each probe you need to allocate a kprobe structure */ static struct kprobe kp = { .symbol_name = symbol, }; /* kprobe pre_handler: called just before the probed instruction is executed */ static int handler_pre(struct kprobe *p, struct pt_regs *regs) { pr_info(\u0026#34;\u0026lt;%s\u0026gt; pre_handler: p-\u0026gt;addr = 0x%p, pc = 0x%lx\\n\u0026#34;, p-\u0026gt;symbol_name, p-\u0026gt;addr, (long)regs-\u0026gt;pc); /* A dump_stack() here will give a stack backtrace */ return 0; } /* kprobe post_handler: called after the probed instruction is executed */ static void handler_post(struct kprobe *p, struct pt_regs *regs, unsigned long flags) { pr_info(\u0026#34;\u0026lt;%s\u0026gt; post_handler: p-\u0026gt;addr = 0x%p\\n\u0026#34;, p-\u0026gt;symbol_name, p-\u0026gt;addr); } /* * fault_handler: this is called if an exception is generated for any * instruction within the pre- or post-handler, or when Kprobes * single-steps the probed instruction. */ static int handler_fault(struct kprobe *p, struct pt_regs *regs, int trapnr) { pr_info(\u0026#34;fault_handler: p-\u0026gt;addr = 0x%p, trap #%dn\u0026#34;, p-\u0026gt;addr, trapnr); /* Return 0 because we don\u0026#39;t handle the fault. */ return 0; } static int __init kprobe_init(void) { int ret; kp.pre_handler = handler_pre; kp.post_handler = handler_post; kp.fault_handler = handler_fault; ret = register_kprobe(\u0026amp;kp); if (ret \u0026lt; 0) { pr_err(\u0026#34;register_kprobe failed, returned %d\\n\u0026#34;, ret); return ret; } pr_info(\u0026#34;Planted kprobe at %p\\n\u0026#34;, kp.addr); return 0; } static void __exit kprobe_exit(void) { unregister_kprobe(\u0026amp;kp); pr_info(\u0026#34;kprobe at %p unregistered\\n\u0026#34;, kp.addr); } module_init(kprobe_init) module_exit(kprobe_exit) MODULE_LICENSE(\u0026#34;GPL\u0026#34;);   安装该内核模块后，每当系统中的进程调用 fork，就会触发我们的 handler，从而在 dmesg 中输出对应的日志信息。值得注意的是，kprobe 模块依赖于具体的系统架构，上述 pre_handler 中我们打印指令地址使用的是 regs-\u0026gt;pc，这是 ARM64 的情况，如果是 X86 环境，则对应 regs-\u0026gt;ip，可查看对应 arch 的 struct pt_regs 实现。\n原理 kprobe 框架基于中断实现。当 kprobe 被注册后，内核会将对应地址的指令进行拷贝并替换为断点指令(比如 X86 中的 int 3)，随后当内核执行到对应地址时，中断会被触发从而执行流程会被重定向到我们注册的 pre_handler 函数；当对应地址的原始指令执行完后，内核会再次执行 post_handler (可选)，从而实现指令级别的内核动态监控。也就是说，kprobe 不仅可以跟踪任意带有符号的内核函数，也可以跟踪函数中间的任意指令。\n另一个 kprobe 的同族是 kretprobe，只不过是针对函数级别的内核监控，根据用户注册时提供的 entry_handler 和 ret_handler 来分别在函数进入时和返回前进行回调。当然实现上和 kprobe 也有所不同，不是通过断点而是通过 trampoline 进行实现，可以略为减少运行开销。\n 有人可能听说过 Jprobe，那是早期 Linux 内核的的一个监控实现，现已被 Kprobe 替代。\n 拓展阅读:\n An introduction to KProbes Documentation/trace/kprobetrace.rst samples/kprobes/kprobe_example.c samples/kprobes/kretprobe_example.c  uprobe uprobe 顾名思义，相对于内核函数/地址的监控，主要用于用户态函数/地址的监控。听起来是不是有点神奇，内核怎么监控用户态函数的调用呢？\n使用 站在用户视角，我们先看个简单的例子，假设有这么个一个用户程序:\n1 2 3 4 5 6 7 8 9  // test.c #include \u0026lt;stdio.h\u0026gt;void foo() { printf(\u0026#34;hello, uprobe!\\n\u0026#34;); } int main() { foo(); return 0; }   编译好之后，查看某个符号的地址，然后告诉内核我要监控这个地址的调用:\n1 2 3 4 5 6  $ gcc test.c -o test $ readelf -s test | grep foo 87: 0000000000000764 32 FUNC GLOBAL DEFAULT 13 foo $ echo \u0026#39;p /root/test:0x764\u0026#39; \u0026gt; /sys/kernel/debug/tracing/uprobe_events $ echo 1 \u0026gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo 1 \u0026gt; /sys/kernel/debug/tracing/tracing_on   然后运行用户程序并检查内核的监控返回:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ ./test \u0026amp;\u0026amp; ./test hello, uprobe! hello, uprobe! $ cat /sys/kernel/debug/tracing/trace # tracer: nop # # WARNING: FUNCTION TRACING IS CORRUPTED # MAY BE MISSING FUNCTION EVENTS # entries-in-buffer/entries-written: 3/3 #P:8 # # _-----=\u0026gt; irqs-off # / _----=\u0026gt; need-resched # | / _---=\u0026gt; hardirq/softirq # || / _--=\u0026gt; preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | test-7958 [006] .... 34213.780750: p_test_0x764: (0x6236218764) test-7966 [006] .... 34229.054039: p_test_0x764: (0x5f586cb764)   当然，最后别忘了关闭监控:\n1 2 3  $ echo 0 \u0026gt; /sys/kernel/debug/tracing/tracing_on $ echo 0 \u0026gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo \u0026gt; /sys/kernel/debug/tracing/uprobe_events   原理 上面的接口是基于 debugfs (在较新的内核中使用 tracefs)，即读写文件的方式去与内核交互实现 uprobe 监控。其中写入 uprobe_events 时会经过一系列内核调用:\n probes_write create_trace_uprobe kern_path: 打开目标 ELF 文件； alloc_trace_uprobe: 分配 uprobe 结构体； register_trace_uprobe: 注册 uprobe； regiseter_uprobe_event: 将 probe 添加到全局列表中，并创建对应的 uprobe debugfs 目录，即上文示例中的 p_test_0x764；  当已经注册了 uprobe 的 ELF 程序被执行时，可执行文件会被 mmap 映射到进程的地址空间，同时内核会将该进程虚拟地址空间中对应的 uprobe 地址替换成断点指令。当目标程序指向到对应的 uprobe 地址时，会触发断点，从而触发到 uprobe 的中断处理流程 (arch_uprobe_exception_notify)，进而在内核中打印对应的信息。\n与 kprobe 类似，我们可以在触发 uprobe 时候根据对应寄存器去提取当前执行的上下文信息，比如函数的调用参数等。同时 uprobe 也有类似的同族: uretprobe。使用 uprobe 的好处是我们可以获取许多对于内核态比较抽象的信息，比如 bash 中 readline 函数的返回、SSL_read/write 的明文信息等。\n拓展阅读:\n Linux uprobe: User-Level Dynamic Tracing Documentation/trace/uprobetracer.rst Linux tracing - kprobe, uprobe and tracepoint  tracepoints tracepont 是内核中提供的一种轻量级代码监控方案，可以实现动态调用用户提供的监控函数，但需要子系统的维护者根据需要自行添加到自己的代码中。\n使用 tracepoint 的使用和 uprobe 类似，主要基于 debugfs/tracefs 的文件读写去进行实现。一个区别在于 uprobe 使用的的用户自己定义的观察点(event)，而 tracepoint 使用的是内核代码中预置的观察点。\n查看内核(或者驱动)中定义的所有观察点:\n1 2 3 4 5 6 7 8  $ cat /sys/kernel/debug/tracing/available_events sctp:sctp_probe sctp:sctp_probe_path sde:sde_perf_uidle_status .... random:random_read random:urandom_read ...   在 events 对应目录下包含了以子系统结构组织的观察点目录:\n1 2 3 4 5 6 7  $ ls /sys/kernel/debug/tracing/events/random/ add_device_randomness credit_entropy_bits extract_entropy get_random_bytes mix_pool_bytes_nolock urandom_read add_disk_randomness debit_entropy extract_entropy_user get_random_bytes_arch push_to_pool xfer_secondary_pool add_input_randomness enable filter mix_pool_bytes random_read $ ls /sys/kernel/debug/tracing/events/random/random_read/ enable filter format id trigger   以 urandom 为例，这是内核的伪随机数生成函数，对其开启追踪:\n1 2 3 4 5  $ echo 1 \u0026gt; /sys/kernel/debug/tracing/events/random/urandom_read/enable $ echo 1 \u0026gt; /sys/kernel/debug/tracing/tracing_on $ head -c1 /dev/urandom $ cat /sys/kernel/debug/tracing/trace_pipe head-9949 [006] .... 101453.641087: urandom_read: got_bits 40 nonblocking_pool_entropy_left 0 input_entropy_left 2053   其中 trace_pipe 是输出的管道，以阻塞的方式进行读取，因此需要先开始读取再获取 /dev/urandom，然后就可以看到类似上面的输出。这里输出的格式是在内核中定义的，我们下面会看到。\n 当然，最后记得把 trace 关闭。\n 原理 根据内核文档介绍，子系统的维护者如果想在他们的内核函数中增加跟踪点，需要执行两步操作:\n 定义跟踪点 使用跟踪点  内核为跟踪点的定义提供了 TRACE_EVENT 宏。还是以 urandom_read 这个跟踪点为例，其在内核中的定义在 include/trace/events/random.h:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #undef TRACE_SYSTEM #define TRACE_SYSTEM random  TRACE_EVENT(random_read, TP_PROTO(int got_bits, int need_bits, int pool_left, int input_left), TP_ARGS(got_bits, need_bits, pool_left, input_left), TP_STRUCT__entry( __field( int, got_bits ) __field( int, need_bits ) __field( int, pool_left ) __field( int, input_left ) ), TP_fast_assign( __entry-\u0026gt;got_bits = got_bits; __entry-\u0026gt;need_bits = need_bits; __entry-\u0026gt;pool_left = pool_left; __entry-\u0026gt;input_left = input_left; ), TP_printk(\u0026#34;got_bits %d still_needed_bits %d \u0026#34; \u0026#34;blocking_pool_entropy_left %d input_entropy_left %d\u0026#34;, __entry-\u0026gt;got_bits, __entry-\u0026gt;got_bits, __entry-\u0026gt;pool_left, __entry-\u0026gt;input_left) );   其中:\n random_read: trace 事件的名称，不一定要内核函数名称一致，但通常为了易于识别会和某个关键的内核函数相关联。隶属于 random 子系统(由 TRACE_SYSTEM 宏定义)； TP_PROTO: 定义了跟踪点的原型，可以理解为入参类型; TP_ARGS: 定义了”函数“的调用参数； TP_STRUCT__entry: 用于 fast binary tracing，可以理解为一个本地 C 结构体的定义； TP_fast_assign: 上述本地 C 结构体的初始化; TP_printk: 类似于 printk 的结构化输出定义，上节中 trace_pipe 的输出结果就是这里定义的；  TRACE_EVENT 宏并不会自动插入对应函数，而是通过展开定义了一个名为 trace_urandom_read 的函数，需要内核开发者自行在代码中进行调用。 上述跟踪点实际上是在 drivers/char/random.c 文件中进行了调用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  static ssize_t urandom_read_nowarn(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { int ret; nbytes = min_t(size_t, nbytes, INT_MAX \u0026gt;\u0026gt; (ENTROPY_SHIFT + 3)); ret = extract_crng_user(buf, nbytes); trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(\u0026amp;input_pool)); // \u0026lt;-- 这里  return ret; } static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { unsigned long flags; static int maxwarn = 10; if (!crng_ready() \u0026amp;\u0026amp; maxwarn \u0026gt; 0) { maxwarn--; if (__ratelimit(\u0026amp;urandom_warning)) pr_notice(\u0026#34;%s: uninitialized urandom read (%zd bytes read)\\n\u0026#34;, current-\u0026gt;comm, nbytes); spin_lock_irqsave(\u0026amp;primary_crng.lock, flags); crng_init_cnt = 0; spin_unlock_irqrestore(\u0026amp;primary_crng.lock, flags); } return urandom_read_nowarn(file, buf, nbytes, ppos); }   值得注意的是实际上是在 urandom_read_nowarn 函数中而不是 urandom_read 函数中调用的，因此也可见注入点名称和实际被调用的内核函数名称没有直接关系，只需要便于识别和定位即可。\n根据上面的介绍我们可以了解到，tracepoint 相对于 probe 来说各有利弊:\n 缺点是需要开发者自己定义并且加入到内核代码中，对代码略有侵入性； 优点是对于参数格式有明确定义，并且在不同内核版本中相对稳定，kprobe 跟踪的内核函数可能在下个版本就被改名或者优化掉了；  另外，tracepoint 除了在内核代码中直接定义，还可以在驱动中进行动态添加，用于方便驱动开发者进行动态调试，复用已有的 debugfs 最终架构。这里有一个简单的自定义 tracepoint 示例，可用于加深对 tracepoint 使用的理解。\n拓展阅读:\n LWN: Using the TRACE_EVENT() macro (Part 1) Documentation/trace/tracepoints.rst Taming Tracepoints in the Linux Kernel  USDT USDT 表示 Userland Statically Defined Tracing，即用户静态定义追踪 (币圈同志先退下)。最早源于 Sun 的 Dtrace 工具，因此 USDT probe 也常被称为 Dtrace probe。可以理解为 kernel tracepoint 的用户层版本，由应用开发者在自己的程序中关键函数加入自定义的跟踪点，有点类似于 printf 调试法(误)。\n下面是一个简单的示例:\n1 2 3 4 5 6  #include \u0026#34;sys/sdt.h\u0026#34;int main() { DTRACE_PROBE(\u0026#34;hello_usdt\u0026#34;, \u0026#34;enter\u0026#34;); int reval = 0; DTRACE_PROBE1(\u0026#34;hello_usdt\u0026#34;, \u0026#34;exit\u0026#34;, reval); }   DTRACE_PROBEn 是 UDST (systemtap) 提供的追踪点定义+插入辅助宏，n 表示参数个数。编译上述代码后就可以看到被注入的 USDT probe 信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ apt-get install systemtap-sdt-dev $ gcc hello-usdt.c -o hello-usdt $ readelf -n ./hello-usdt ... Displaying notes found in: .note.stapsdt Owner Data size Description stapsdt 0x0000002e NT_STAPSDT (SystemTap probe descriptors) Provider: \u0026#34;hello_usdt\u0026#34; Name: \u0026#34;enter\u0026#34; Location: 0x0000000000001131, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: stapsdt 0x00000038 NT_STAPSDT (SystemTap probe descriptors) Provider: \u0026#34;hello_usdt\u0026#34; Name: \u0026#34;exit\u0026#34; Location: 0x0000000000001139, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: -4@-4(%rbp)   readelf -n 表示输出 ELF 中 NOTE 段的信息。\n在使用 trace 工具(如 BCC、SystemTap、dtrace) 对该应用进行追踪时，会在启动过程中修改目标进程的对应地址，将其替换为 probe ，在触发调用时候产生对应事件，供数据收集端使用。通常添加 probe 的方式是 基于 uprobe 实现的。\n使用 USDT 的一个好处是应用开发者可以在自己的程序中定义更加上层的追踪点，方便对于功能级别监控和分析，比如 node.js server 就自带了 USDT probe 点可用于追踪 HTTP 请求，并输出请求的路径等信息。由于 USDT 需要开发者配合使用，不符合我们最初的逆向分析需要，因此就不过多介绍了。(其实是懒得搭环境)\n拓展阅读:\n Exploring USDT Probes on Linux LWN: Using user-space tracepoints with BPF  小结 上述介绍的四种常见内核监控方案，根据静态/动态类型以及面向内核还是用户应用来划分的话，可以用下表进行概况:\n   监控方案 静态 动态 内核 用户     Kprobes  ✔ ✔    Uprobes  ✔  ✔   Tracepoints ✔  ✔    USDT ✔   ✔    准确来说 USDT 不算是一种独立的内核监控数据源，因为其实现还是依赖于 uprobe，不过为了对称还是放在这里，而且这样目录比较好看。\n采集 \u0026amp; 前端 上面我们介绍了几种当今内核中主要的监控数据来源，基本上可以涵盖所有的监控需求。不过从易用性上来看，只是实现了基本的架构，使用上有的是基于内核提供的系统调用/驱动接口，有的是基于 debugfs/tracefs，对用户而言不太友好，因此就有了许多封装再封装的监控前端，本节对这些主要的工具进行简要介绍。\nftrace ftrace 是内核中用于实现内部追踪的一套框架，这么说有点抽象，但实际上我们前面已经用过了，就是 tracefs 中的使用的方法。\n 在旧版本中内核中(4.1 之前)使用 debugfs，一般挂载到 /sys/kernel/debug/tracing；在新版本中使用独立的 tracefs，挂载到 /sys/kernel/tracing。但出于兼容性原因，原来的路径仍然保留，所以我们将其统一称为 tracefs。\n ftrace 通常被叫做 function tracer，但除了函数跟踪，还支持许多其他事件信息的追踪:\n hwlat: 硬件延时追踪 irqsoff: 中断延时追踪 preemptoff: 追踪指定时间片内的 CPU 抢占事件 wakeup: 追踪最高优先级的任务唤醒的延时 branch: 追踪内核中的 likely/unlikely 调用 mmiotrace: 追踪某个二进制模块所有对硬件的读写事件 ……  Android 中提供了一个简略的文档指导如何为内核增加 ftrace 支持，详见: Using ftrace。\nperf perf 是 Linux 发行版中提供的一个性能监控程序，基于内核提供的 perf_event_open 系统调用来对进程进行采样并获取信息。Linux 中的 perf 子系统可以实现对 CPU 指令进行追踪和计数，以及收集 kprobe、uprobe 和 tracepoints 的信息，实现对系统性能的分析。\n在 Android 中提供了一个简单版的 perf 程序 simpleperf，接口和 perf 类似。\n虽然可以监测到系统调用，但缺点是无法获取系统调用的参数，更不可以动态地修改内核。因此对于安全测试而言作用不大，更多是给 APP 开发者和手机厂商用于性能热点分析。值得一提的是，perf 子系统曾经出过不少漏洞，在 Android 内核提权史中也曾经留下过一点足迹 :D\neBPF eBPF 为 extended Berkeley Packet Filter 的缩写，BPF 最早是用于包过滤的精简虚拟机，拥有自己的一套指令集，我们常用的 tcpdump 工具内部就会将输入的过滤规则转换为 BPF 指令，比如:\n1 2 3 4 5 6 7  $ tcpdump -i lo0 \u0026#39;src 1.2.3.4\u0026#39; -d (000) ld [0] (001) jeq #0x2000000 jt 2\tjf 5 (002) ld [16] (003) jeq #0x1020304 jt 4\tjf 5 (004) ret #262144 (005) ret #0   该汇编指令表示令过滤器只接受 IP 包，并且来源 IP 地址为 1.2.3.4。其中的指令集可以参考 Linux Socket Filtering aka Berkeley Packet Filter (BPF)。eBPF 在 BPF 指令集上做了许多增强(extend):\n 寄存器个数从 2 个增加为 10 个 (R0 - R9)； 寄存器大小从 32 位增加为 64 位； 条件指令 jt/jf 的目标替换为 jt/fall-through，简单来说就是 else 分支可以默认忽略； 增加了 bpf_call 指令以及对应的调用约定，减少内核调用的开销； ……  内核存在一个 eBPF 解释器，同时也支持实时编译(JIT)增加其执行速度，但很重要的一个限制是 eBPF 程序不能影响内核正常运行，在 内核加载 eBPF 程序前会对其进行一次语义检查，确保代码的安全性，主要限制为:\n 不能包含循环，这是为了防止 eBPF 程序过度消耗系统资源(5.3 中增加了部分循环支持)； 不能反向跳转，其实也就是不能包含循环； BPF 程序的栈大小限制为 512 字节； ……  具体的限制策略都在内核的 eBPF verifier 中，不同版本略有差异。值得一提的是，最近几年 Linux 内核出过很多 eBPF 的漏洞，大多是 verifier 的验证逻辑错误，其中不少还上了 Pwn2Own，但是由于权限的限制在 Android 中普通应用无法执行 bpf(2) 系统调用，因此并不受影响。\neBPF 和 perf_event 类似，通过内核虚拟机的方式实现监控代码过滤的动态插拔，这在许多场景下十分奏效。对于普通用户而言，基本上不会直接编写 eBPF 的指令去进行监控，虽然内核提供了一些宏来辅助 eBPF 程序的编写，但实际上更多的是使用上层的封装框架去调用，其中最著名的一个就是 BCC。\nBCC BCC (BPF Compiler Collection) 包含了一系列工具来协助运维人员编写监控代码，其中使用较多的是其 Python 绑定。一个简单的示例程序如下:\n1 2 3 4 5 6 7 8  from bcc import BPF prog=\u0026#34;\u0026#34;\u0026#34; int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\u0026#34;Hello, World!\\\\n\u0026#34;); return 0; } \u0026#34;\u0026#34;\u0026#34; BPF(text=prog).trace_print()   执行该 python 代码后，每当系统中的进程调用 clone 系统调用，该程序就会打印 “Hello World” 输出信息。 可以看到这对于动态监控代码非常有用，比如我们可以通过 python 传入参数指定打印感兴趣的系统调用及其参数，而无需频繁修改代码。\neBPF 可以获取到内核中几乎所有的监控数据源，包括 kprobes、uprobes、tracepoints 等等，官方 repo 中给出了许多示例程序，比如 opensnoop 监控文件打开行为、execsnoop 监控程序的执行。后文我们会在 Android 系统进行实际演示来感受其威力。\nbpftrace bpftrace 是 eBPF 框架的另一个上层封装，与 BCC 不同的是 bpftrace 定义了一套自己的 DSL 脚本语言，语法(也)类似于 awk，从而可以方便用户直接通过命令行实现丰富的功能，截取几条官方给出的示例:\n1 2 3 4 5  # 监控系统所有的打开文件调用(open/openat)，并打印打开文件的进程以及被打开的文件路径 bpftrace -e \u0026#39;tracepoint:syscalls:sys_enter_open { printf(\u0026#34;%s %s\\n\u0026#34;, comm, str(args-\u0026gt;filename)); }\u0026#39; # 统计系统中每个进程执行的系统调用总数 bpftrace -e \u0026#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }\u0026#39;   官方同样也给出了许多 .bt 脚本示例，可以通过其代码进行学习和编写。\n拓展阅读:\n LWN: A thorough introduction to eBPF Extending the Kernel with eBPF https://www.opersys.com/downloads/cc-slides/android-debug/slides-main-211122.html#/ http://www.caveman.work/2019/01/29/eBPF-on-Android/  SystemTap SystemTap(stab) 是 Linux 中的一个命令行工具，可以对各种内核监控源信息进行结构化输出。同时也实现了自己的一套 DSL 脚本，语法类似于 awk，可实现系统监控命令的快速编程。\n使用 systemtap 需要包含内核源代码，因为需要动态编译和加载内核模块。在 Android 中还没有官方的支持，不过有一些开源的 systemtap 移植。\n拓展阅读: Comparing SystemTap and bpftrace\n其他 除了上面介绍的这些，还有许多开源的内核监控前端，比如 LTTng、trace-cmd、kernelshark等，内核监控输出以结构化的方式进行保存、处理和可视化，对于大量数据而言是非常实用的。限于篇幅不再对这些工具进行一一介绍，而且笔者使用的也不多，后续有机会再进行研究。\nAndroid 移植 上面说了那么多，终究只是 Linux 发行版上的热闹，那么这些 trace 方法在 Android 上行得通吗？理论上 AOSP 的代码是开源的，内核也是开源的，编译一下不就好了。但实践起来我们会遇到几个方面的困难:\n 许多工具需要编译代码，BCC 工具还需要 Python 运行，这在默认的 Android 环境中不存在； 原厂提供的预编译内核镜像不带有 kprobe 等监控功能支持，需要自行修改配置，烧写和编译内核； Linux 旧版本对于 eBPF 的支持不完善，许多新功能都是在 5.x 后才引进，而 Android 的 Linux 内核都比较旧，需要进行 cherry-pick 甚至手动 backport； AOSP 较新版本引入了 GKI(Generic Kernel Image)，需要保持内核驱动接口的兼容性，因此内核代码不能引入过多修改； ……  由于我们主要目的是进行安卓应用逆向分析，因此最好在真机环境运行，因为许多应用并不支持 x86 环境。当然 ARM 模拟器也可以，但在攻防对抗的时可能需要进行额外的模拟器检测绕过。\n笔者使用的是 Google Pixel 5，使用其他手机的话需要适当进行调整。\n1. Debian over Android Android 系统本身并不是为了开发而设计的，因此只内置了简单的 busybox(toybox) 工具，以及一些包管理相关的程序如 pm/am/dumpsys/input 等。为了在上面构建完整的开发环境，我们需要能在安卓中运行 gcc/clang、python、Makefile 等，一个直观的想法是通过沙盒等方式在上面运行一个常见的 Linux 发行版，比如 Ubuntu 或者 Debian。\nandrodeb 正是这个想法的一个实现，其核心是基于 chroot 在 Android 中运行了一个 Debian aarch64 镜像，并可以通过 apt 等包管理工具安装所需要的编译工具链，从而在上面编译和运行 bcc 等 Linux 项目。\n在 Android 上运行 Debian 系统的示例如下:\nRunning Debian on Android\n其中的关键之处在于正确挂载原生 Android 中的映射，比如 procfs、devfs、debugfs 等。\n2. 自定义内核 解决了在 Android 上运行开发工具的问题之后，我们还需要一个支持动态调试的内核环境。在绝大多数官方固件中自带的内核都没有开启 KPROBES 的支持，这意味着我们自行编译和加载内核。为了能够支持 KPROBES、UPROBES、TRACEPOINTS 等功能，需要在内核的配置中添加以下选项:\n禁用内核的安全特性，开启调试支持:\n-d CONFIG_LTO \\\r-d CONFIG_LTO_CLANG \\\r-d CONFIG_CFI_CLANG \\\r-d CFI_PERMISSIVE \\\r-d CFI_CLANG \\\r-e CONFIG_IRQSOFF_TRACER \\\r-e CONFIG_PREEMPT_TRACER \\\r-e CONFIG_DEBUG_FS \\\r-e CONFIG_CHECKPOINT_RESTORE \\\r-d CONFIG_RANDOMIZE_BASE \\ 开启 eBPF 支持:\n-e CONFIG_BPF \\\r-e CONFIG_BPF_SYSCALL \\\r-e CONFIG_BPF_JIT \\\r-e CONFIG_HAVE_EBPF_JIT \\\r-e CONFIG_IKHEADERS \\ 开启 kprobes 支持:\n-e CONFIG_HAVE_KPROBES \\\r-e CONFIG_KPROBES \\\r-e CONFIG_KPROBE_EVENT \\ 开启 kretprobe 支持:\n-e CONFIG_KRETPROBES \\\r-e CONFIG_HAVE_KRETPROBES \\\r-d CONFIG_SHADOW_CALL_STACK \\\r-e CONFIG_ROP_PROTECTION_NONE \\ 开启 ftrace 支持:\n-e CONFIG_FTRACE_SYSCALLS \\\r-e CONFIG_FUNCTION_TRACER \\\r-e CONFIG_HAVE_DYNAMIC_FTRACE \\\r-e CONFIG_DYNAMIC_FTRACE \\ 开启 uprobes 支持:\n-e CONFIG_UPROBES \\\r-e CONFIG_UPROBE_EVENT \\\r-e CONFIG_BPF_EVENTS BCC 建议设置的选项:\n-e CONFIG_DEBUG_PREEMPT \\\r-e CONFIG_PREEMPTIRQ_EVENTS \\\r-d CONFIG_PROVE_LOCKING \\\r-d CONFIG_LOCKDEP 为了避免各类环境问题，我建议编译环境最好选择干净的虚拟机英文环境，或者直接使用 Docker 镜像，根据官方的指导去编译，见: Building Kernels。\n编译内核常见的依赖:\n1 2 3 4 5 6 7 8 9  $ pkg --add-architecture i386 $ apt install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip   拓展阅读:\n Building a Pixel kernel with KASAN+KCOV eBPF/BCC - A better low-level Instrumentation tool on Android  3. 内核移植 当你成功编译好内核并启动后，很可能会发现有一些内核分析工具比如 BCC 在使用上会出现各种问题，这通常是内核版本的原因。由于 eBPF 目前在内核中也在频繁更新，因此许多新的特性并没有增加到当前内核上。\n例如，在 Pixel 5 最新的支持的内核是 4.19 版本，在这个版本中，bpf_probe_read_user (issue#3175) 函数还没添加进内核，因此使用 BCC 会回退到 bpf_probe_read_kernel，这在内核直接读取用户空间的数据(比如系统调用的参数)时会出现错误，因此我们需要手动去 cherry-pick 对应的 commit，即在 Linux 5.5 中添加的 6ae08ae3dea2。\nBCC 所需的所有内核特性及其引进的版本列表可以参考: BCC/kernel-versions.md，部分列表如下所示:\n因此为了减少可能遇到的兼容性问题，尽量使用最新版本的内核，当然通常厂商都只维护一个较旧的 LTS 版本，只进行必要的安全性更新，如果买机不淑的话就需要自食其力了。\n实战测试 通过在上述 Android Debian 环境编译好 BCC 之后，我们就可以使用 Python 编写对应的应用跟踪分析脚本了。一般是通过应用名去过滤系统调用，但是在 Android 中还有个特别的过滤方式就是通过用户 ID，因为应用是根据动态安装获取的 UID 去进行沙盒隔离的。\n以某个层层加固的恶意 APK 为例，安装后获取其 UID 为 u0_a142，转换成数字是 10142，对其进行 exec 系统调用的监控:\n可以看到目标应用调用了 ps、getprop、pm 等程序，用来检测当前系统的 adb 状态以及所安装的应用，比如其中通过 pm path com.topjohnwu.magisk 来判断 Magisk 工具是否存在，因此存在 root 检测行为。上图中 pm 实际调用了 cmd 程序进行查找，因为 pm 本质上只是一个 shell 脚本:\n1 2 3  $ cat `which pm` #!/system/bin/sh cmd package \u0026#34;$@\u0026#34;   使用 UID 进行过滤的好处是可以跟踪所有 fork 的子进程和孙子进程，这是基于 PID 或者进程名跟踪所无法比拟的。除了 exec，我们还可以跟踪其他内核函数，比如 root 检测经常用到的 openat 或 access，如下所示:\n基于内核级别的监控，让应用中所有的加固/隐藏/内联汇编等防御措施形同虚设，而且可以在应用启动的初期进行观察，让应用的一切行为在我们眼中无所遁形。\nPS: 如果在使用 BCC 的过程中发现没有过滤 UID 的选项，那可能需要切换到最新的 release 版本或者 master 分支，因为这个选项是笔者最近才加上去的。\n:D\n拓展阅读:\n eBPF super powers on ARM64 and Android (slides) eBPF - Android Reverse Engineering Superpowers  总结 本文总结并分析了几种内核主要的监控方案，它们通常用于性能监控和内核调试，但我们也可以将其用做安全分析，并在 Android 中进行了实际的移植和攻防测试，并且获得了超出预期的实战效果。除了内核级别监控，我们还可以基于 uprobes 实现应用内任意地址的监控，如在 SSL_read/write 地址处获取所有 SSL 加密的数据。得益于内核提供的丰富监控原语，我们可以实现内核级别移动端沙盒，全面监控移动应用行为，也可以通过内核读写原语去实现系统调用参数修改，从而实现应用运行环境的模拟和伪造。\n","permalink":"https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","summary":"在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\u0026#34;/usr/bin/echo\u0026#34;, [\u0026#34;echo\u0026#34;, \u0026#34;evilpan\u0026#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \u0026#34;/etc/ld.","title":"Linux 内核监控在 Android 攻防中的应用"},{"content":"前言 很久之前就用过安卓的termux，最近在使用Telegam的API，想做一个追踪丢失手机的功能。不过在我的小米8（root）上从Google Play下载的termux无法进行pkg update，会出现502报错，百思不得其解。\n后来在官方论坛找到原因，Google Play上的termux已经好久没有更新了，现在要从F-Droid上下载最新版本。我也懒得更换源了，换源的话就直接按照清华源的教程操作即可。如下：\n1 2  sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@\u0026#39; $PREFIX/etc/apt/sources.list apt update \u0026amp;\u0026amp; apt upgrade   目标 开发一款APP，能够实现强制打开GPS并根据telegram指令定时发送GPS数据到指定用户。\n实施 ","permalink":"https://10cks.top/posts/termux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","summary":"前言 很久之前就用过安卓的termux，最近在使用Telegam的API，想做一个追踪丢失手机的功能。不过在我的小米8（root）上从Google Play下载的termux无法进行pkg update，会出现502报错，百思不得其解。\n后来在官方论坛找到原因，Google Play上的termux已经好久没有更新了，现在要从F-Droid上下载最新版本。我也懒得更换源了，换源的话就直接按照清华源的教程操作即可。如下：\n1 2  sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@\u0026#39; $PREFIX/etc/apt/sources.list apt update \u0026amp;\u0026amp; apt upgrade   目标 开发一款APP，能够实现强制打开GPS并根据telegram指令定时发送GPS数据到指定用户。\n实施 ","title":"Termux使用指南"},{"content":"Botconf 2021/22 重新回到线下举办，并且回到了第一届的举办地——法国西海岸的南特。尽管是线下举办，但由于各国的政策要求不一，仍有部分议题的主讲人未能到场进行分享。作为一个在专业领域内比较受认可的会议，本届 Botconf 有来自世界各地的三百多名安全研究人员注册参加。此前，360 Netlab 与绿盟等国内安全公司也有议题在该会议上进行分享，本届也有一个来自阿里云的工作。\n下面只挑选部分议题进行介绍，感兴趣的同学可以去官网查看全部议题进一步了解。\nPS：Botconf 要求参与会议的人员不要录制视频，只有官方能够录制视频。并且每个主讲人都会对内容做出说明，如果表明是机密信息的情况下，请不要拍照或者对外进行相关内容的讨论。所以在遵守该要求的情况下，在公开议题中选取了部分议题进行简要介绍，完整、详细的内容请查看官网或者联系作者。\n监控多个 P2P 僵尸网络的经验见解 来自德国达姆施塔特工业大学、美国马里兰大学和马来西亚理科大学关于监控僵尸网络的研究。研究人员认为监控僵尸网络就像盲人摸象：\nP2P 僵尸网络的三个典型模式：非结构化、结构化、寄生。\n利用爬虫和传感器构建僵尸网络监控系统，以下是一些系统截图（公众号会对图片进行压缩，原图是非常清晰的）：\n该研究监控了 Mozi、Hajime、DDG 等比较大规模的 P2P 僵尸网络，跟踪失陷主机的相关统计信息（如国家、自治系统、地理分布等）。\n研究人员通过双队列并行两万个爬虫获取信息。\n后续研究人员还会增加对 Bot 生命周期的自动测量、对反监控的措施加以完善等其他功能，该项目也欢迎其他研究人员的合作。\n根据通信模式检测利用合法服务进行 C\u0026amp;C 的失陷主机 来自 Akamai 的工作一向扎实。这次内容提到 Akamai 正在努力跟踪发现失陷痕迹，提醒相关用户存在可疑行为。因为很多犯罪分子都会使用合法的 Web 服务来进行攻击。例如 HAMMERTOSS 使用 Twitter、GitHub 和云存储服务进行 C\u0026amp;C 通信。\n典型的三类恶意流量模式：Beacon、DGA 与多信道。\n研究人员发现，使用功率谱密度（PSD）将时域数据转向频域处理，可能会很有效果。清华在 CCS 2021 上也发表了一篇利用频域分析检测恶意流量的工作《Realtime Robust Malicious Traffic Detection via Frequency Domain Analysis》，利用频域分析可能是有潜力的工作方向，感兴趣的同学可以尝试研究。\n正常的设备流量模式与失陷主机的流量模式存在显著差异：\nAkamai 使用 DNS 数据来进行检测：\n在 Akamai 在应用中发现了许多正常情况下难以发现的恶意攻击，例如 uBlock 恶意插件（仿冒合法广告拦截插件的恶意插件）：\nKashmirBlack 僵尸网络的来龙去脉 Imperva 跟踪 PHPUnit 远程代码执行（CVE-2017-9841）漏洞的在野传播，该漏洞影响波及 Drupal、WordPress、PrestaShop 与 Magento 等知名框架。\n整体流程如上所示，当然攻击者也利用了很多其他漏洞。\n该僵尸网络是根据 GitHub 的仓库名称命名的：\n最早从 2016 年该僵尸网络就开始活跃：\n早于 VirusTotal 在云上检测恶意软件 来自阿里云与达摩院的工作。依托阿里自己的云安全产品，利用 ssdeep 构建超过一亿文件的关系图。新发现的样本和已知的样本进行比对，升级得到样本标签：\n由于样本量很大，工程应用上的优化其实是核心。其中的 tips 如下所示：\n方法上也很明晰，和前人做的很多工作一脉相承。例如 Brian Wallace 在 Virus Bulletin 分享过应对大规模样本场景下高性能使用 ssdeep 的方法、Intezer 也分享过类似的工作。这部分在此前的文章中也提到过，可以进一步阅读。本项工作在各处都加以优化，希望在海量样本场景下提供更好的应用性能。\n 狩猎样本可用的哈希函数介绍\nAvenger，公众号：威胁棱镜狩猎样本的哈希游戏\n 有线索的情况下可以直接在图里查询，没有线索的情况下可以看聚类的情况。\n例如 21.1 万个 XorDDoS 样本，Avira 引擎能够检出 15.3 万，总有一些样本在 ViursTotal 上是不能被检出的，就可以通过这种方法发现。\n从大视角来看，勒索软件聚类：\n挖矿软件聚类：\nMirai 聚类：\nAgent Tesla 聚类：\n最后，研究人员指出，该方法并不局限于使用 ssdeep，其他算法也可以使用，原理是共通的。\nPS：这个报告因为超时一直被催促，比较遗憾最后由于时间原因取消了提问环节。\n恶意软件市场中私密论坛的形态研究 研究人员从 2020 年 6 月 1 日到 2021 年 2 月 10 日，跟踪了一个超过六万成员、100 万帖子的私密论坛和一个超过 18.5 万成员、34.5 万帖子的公开论坛。公开论坛中有 86 个恶意软件提供方、私密论坛中有 136 个恶意软件提供方。\n恶意软件中，控制类恶意软件占据了半壁江山。\n控制类恶意软件中，私密论坛上近四分之三都是远控：\n窃密类恶意软件中，私密论坛百花齐放，各种类型的窃密恶意软件都有一席之地。\n从目标上看，移动端仍然只是一小部分，计算机终端还是主流。\n恶意软件价格跨度极大，从免费到一万美元以上都有。\nQbot 进化之路 从 2007 年开始，Qbot 就持续活跃，是目前最活跃的恶意软件之一。\n研究人员分析了 Qbot 近十年的进化之路。\n内容十分硬核，本届 Botconf 其实还有一个议题是讲 Qbot 的《Behind The Scenes Of Qbot》，但该议题是 Amber 的，也没有对外放 PPT，就不做表述了。\n十五年来高级攻击者对气隙网络的觊觎 ESET 梳理了过往 15 年中 17 个针对气隙网络进行攻击的案例，发现攻击的一些特点，例如所有的恶意软件框架都使用 USB 设备作为物理介质将数据摆渡出目标网络中。\n去年 ESET 披露的白皮书已经讲了很多，感兴趣可以参考查看。\n ESET 分析白皮书\nhttps://www.welivesecurity.com/wp-content/uploads/2021/12/eset_jumping_the_air_gap_wp.pdf\n  ESET 博客内容\nhttps://www.welivesecurity.com/2021/12/01/jumping-air-gap-15-years-nation-state-effort/\n 安天此前也对外分享过关于《高级威胁组织渗透隔离网络能力与年度案例》，感兴趣可以自行查阅。\n针对赌博行业攻击的犯罪团伙 趋势科技的研究人员发现了一个专门攻击赌博网站的 APT 组织 GamblingPuppet。该组织全平台通吃，Windows、Linux 和 macOS 都不放过。\n该攻击组织被认为是一个说中文的团伙，使用了 PlugX、Gh0st RAT 等被认为是与中文攻击者有关的恶意软件，从很多攻击基础设施的命名中也可以发现（实在是太脏，打了码 \u0026hellip; \u0026hellip;）。\n趋势科技也在陆续披露相关研究内容，六月末在 FIRST 2022 上也要讲这一议题。\n 趋势科技博客内容\nhttps://www.trendmicro.com/en_hk/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html\n 期望 Yara 性能再提升 Yara 目前在分析应用中已经越来越普及，当样本量一大，性能又会变成问题。Avast 的研究人员举了一个例子，一个耗时 45 分钟的 Yara 规则优化后甚至可以提升至 3 秒钟，不好的 Yara 规则对系统资源的占用是巨大的。\nAvast 在 Yara 上下了许多功夫，例如开发了将 Yara 规则解析为 AST 的工具 yaramod。还改进了字符串的模式匹配方案，比特币地址匹配可以提速十倍，普通场景下也能提升超过四分之一，这个 PR 日后应该也会被合并进来。\n为了提高效率，尽可能快地得到匹配结果，在性能上有一些需要注意的问题。例如：\n 尽量不要使用正则表达式，消耗大量内存而且拖慢性能 必须要使用正则表达式，避免使用贪婪匹配，且尽量确定匹配上限 元数据也占内存，如果内存并不宽裕，尽量缩减元数据  比较完整的表述可以查看 Neo23x0 大神的文章作为参考。笔者以前翻过旧版本的没有发，日后应该也会把更新过的版本翻出来发在公众号上，着急的同学则可以自行查看原文。\n Yara 性能指南\nhttps://github.com/Neo23x0/YARA-Performance-Guidelines/\n PS：Twitter 上今年年初开启了一个名为 #100DaysofYARA 的话题，本来进行的如火如荼，可惜俄乌冲突后大家都无心看这个了，后续应该也会整理一下这个话题有什么值得分享的内容。 水坑 RTM 僵尸网络 Group-IB 针对 RTM 僵尸网络的分析与水坑方式的介绍。RTM 僵尸网络的攻击概览如下：\n攻击者甚至把 C\u0026amp;C 服务器的地址藏在了比特币交易里：\n研究人员仍然通过极其精巧的方式进行了水坑：\n持续跟踪了受害者的情况，为执法机关的处置提供了依据：\n","permalink":"https://10cks.top/posts/botconf-2022-%E8%AE%AE%E9%A2%98%E9%80%9F%E9%80%92/","summary":"Botconf 2021/22 重新回到线下举办，并且回到了第一届的举办地——法国西海岸的南特。尽管是线下举办，但由于各国的政策要求不一，仍有部分议题的主讲人未能到场进行分享。作为一个在专业领域内比较受认可的会议，本届 Botconf 有来自世界各地的三百多名安全研究人员注册参加。此前，360 Netlab 与绿盟等国内安全公司也有议题在该会议上进行分享，本届也有一个来自阿里云的工作。\n下面只挑选部分议题进行介绍，感兴趣的同学可以去官网查看全部议题进一步了解。\nPS：Botconf 要求参与会议的人员不要录制视频，只有官方能够录制视频。并且每个主讲人都会对内容做出说明，如果表明是机密信息的情况下，请不要拍照或者对外进行相关内容的讨论。所以在遵守该要求的情况下，在公开议题中选取了部分议题进行简要介绍，完整、详细的内容请查看官网或者联系作者。\n监控多个 P2P 僵尸网络的经验见解 来自德国达姆施塔特工业大学、美国马里兰大学和马来西亚理科大学关于监控僵尸网络的研究。研究人员认为监控僵尸网络就像盲人摸象：\nP2P 僵尸网络的三个典型模式：非结构化、结构化、寄生。\n利用爬虫和传感器构建僵尸网络监控系统，以下是一些系统截图（公众号会对图片进行压缩，原图是非常清晰的）：\n该研究监控了 Mozi、Hajime、DDG 等比较大规模的 P2P 僵尸网络，跟踪失陷主机的相关统计信息（如国家、自治系统、地理分布等）。\n研究人员通过双队列并行两万个爬虫获取信息。\n后续研究人员还会增加对 Bot 生命周期的自动测量、对反监控的措施加以完善等其他功能，该项目也欢迎其他研究人员的合作。\n根据通信模式检测利用合法服务进行 C\u0026amp;C 的失陷主机 来自 Akamai 的工作一向扎实。这次内容提到 Akamai 正在努力跟踪发现失陷痕迹，提醒相关用户存在可疑行为。因为很多犯罪分子都会使用合法的 Web 服务来进行攻击。例如 HAMMERTOSS 使用 Twitter、GitHub 和云存储服务进行 C\u0026amp;C 通信。\n典型的三类恶意流量模式：Beacon、DGA 与多信道。\n研究人员发现，使用功率谱密度（PSD）将时域数据转向频域处理，可能会很有效果。清华在 CCS 2021 上也发表了一篇利用频域分析检测恶意流量的工作《Realtime Robust Malicious Traffic Detection via Frequency Domain Analysis》，利用频域分析可能是有潜力的工作方向，感兴趣的同学可以尝试研究。\n正常的设备流量模式与失陷主机的流量模式存在显著差异：\nAkamai 使用 DNS 数据来进行检测：\n在 Akamai 在应用中发现了许多正常情况下难以发现的恶意攻击，例如 uBlock 恶意插件（仿冒合法广告拦截插件的恶意插件）：\nKashmirBlack 僵尸网络的来龙去脉 Imperva 跟踪 PHPUnit 远程代码执行（CVE-2017-9841）漏洞的在野传播，该漏洞影响波及 Drupal、WordPress、PrestaShop 与 Magento 等知名框架。","title":"Botconf 2022 议题速递"},{"content":"build aosp   安装aosp需要的编译依赖 https://source.android.com/setup/build/initializing\n  下载源码 https://source.android.com/setup/build/downloading\n  sudo apt-get update\rsudo apt-get install repo\rmkdir aosp_workdir\rcd aosp_workdir\rrepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b master\rrepo sync 要下很久，可以用sudo iftop来看一下下载速度。\n 编译aosp  source build/envsetup.sh\rlunch aosp_x86_64-eng\rmake -j32 build codeql database 到这里首先我们选择我们想看的目录，这里我选择frameworks/av/media，然后递归touch这个目录下的所有文件，这个作用是为了更新时间戳，这样make的时候，这部分文件就会重新被make\n➜ aosp_workdir cd frameworks/av/media ➜ media git:(011dbb4bf7) find ./ * -exec touch {} \\; 然后设置一个环境变量，并编译db即可，这部分参考自葫芦娃的文章。\nexport ALLOW_NINJA_ENV=true\rcodeql database create out/codeql-frameworks \\\r--language=cpp \\\r--command=\u0026#34;`pwd`/build/soong/soong_ui.bash --make-mode -j16\u0026#34; ","permalink":"https://10cks.top/posts/codeql-%E7%BC%96%E8%AF%91-aosp-database/","summary":"build aosp   安装aosp需要的编译依赖 https://source.android.com/setup/build/initializing\n  下载源码 https://source.android.com/setup/build/downloading\n  sudo apt-get update\rsudo apt-get install repo\rmkdir aosp_workdir\rcd aosp_workdir\rrepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b master\rrepo sync 要下很久，可以用sudo iftop来看一下下载速度。\n 编译aosp  source build/envsetup.sh\rlunch aosp_x86_64-eng\rmake -j32 build codeql database 到这里首先我们选择我们想看的目录，这里我选择frameworks/av/media，然后递归touch这个目录下的所有文件，这个作用是为了更新时间戳，这样make的时候，这部分文件就会重新被make\n➜ aosp_workdir cd frameworks/av/media ➜ media git:(011dbb4bf7) find ./ * -exec touch {} \\; 然后设置一个环境变量，并编译db即可，这部分参考自葫芦娃的文章。\nexport ALLOW_NINJA_ENV=true\rcodeql database create out/codeql-frameworks \\\r--language=cpp \\\r--command=\u0026#34;`pwd`/build/soong/soong_ui.","title":"CodeQL 编译 AOSP database"},{"content":"本文最后更新于 2022 年 2 月。PT 站的前世今生，新手入门指南和概念扫盲。\n专题文章目录  PT 下载从入门到养老篇一：站点介绍及生存指南 PT 下载从入门到养老篇二：隐匿的地下通讯 PT 下载从入门到养老篇三：NAS 存储服务器及硬盘选购  介绍 PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。\n许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。\n目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。\n日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。\n2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。\n国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。\n教育网 PT 站点 以北邮人（北京邮电大学）、蒲公英（西北工业大学）、极速之星（北京理工大学）和六维空间（东北大学）为主。\n高校校园网提供的 IPv4 网络一般是有计费及限速策略的，由校方向电信、联通、移动、鹏博士等运营商采购带宽并在出口实施自动分流。而为了推广 IPv6 业务，各高校所接入的中国教育网（CERNET）的 IPv6 网络一般是不计费且不限速的，因此组建一个依托于 IPv6 的免费资源分享网络有着很大意义。\n一般来说，教育网 PT 站的原创影视资源较少，大部分为转载资源。Coursera、Udacity 等公开课资源（WEB-DL）、考研视频、电子书等内容较多，此外，北邮人等站点还提供一些诸如 Steam 游戏数据备份文件，这样学生就不用担心被几十个 G 的 Steam 游戏更新榨干网费了。\n目前来看教育网 PT 站或多或少获得了学校网络中心的技术和政策支持，所以才能存留至今。部分教育网 PT 站仅允许 IPv6 或仅归属于教育网 ASN 的 IPv6 访问，因此对于公众来说访问有些难度，可以通过 HE.net 提供的 IPv6 TunnelBroker 隧道，或者 IPv6 VPS 来中转流量。\n从分享率和发种规范来看，教育网 PT 十分宽松，但保种率可能不如公网 PT 站高，资源也没那么丰富。但对于追热门电影和美剧的轻度用户来说还是足够了。\n公网 PT 站点 传说中国有五大公网 PT 站：HDS、TTG、HDC、CHD、HDR，也有三大 PT 站的说法（即 CHDbits、HDChina、TTG）。后来经过世界版权日风波（即被称作“中国版权第一案”的思路网侵权案），HDStar（思路网）管理组被捕入狱，剩下的站点也多多少少受到了一些影响，有些直接关闭了，有的则隐没了。\n希望考古中国 PT 站历史的朋友可以查看这个帖子：国内外PT站点评。希望考古国际 PT 站的朋友，可以查看这个帖子：PT站点大全。历史比较悠久了，仅供参考。\n距离版权日风波已经过去了七八年，现在国内 PT 站又呈现出繁荣景象。一方面国内电视剧集的分级制度迟迟未推出，而 Netflix、HBO、Disney+、Apple TV+ 等境外流媒体业务的订阅费用也居高不下。另一方面，国内百兆、千兆家庭宽带已经覆盖到了三四线城市甚至是县城，养一个 PT 账号的成本已经相当低了。\n在此列出几个常见的站点，仅供参考。\n 目前以影视资源为主的有  HDChina 瓷器：近 10 年的老站，用户数据继承自原先的 HDWinG 和 HDStar。资源方面，官方制作组（HDCTV 和 HDChina）的 Netflix、HBO 剧集，原盘，录制的电视剧比较多。 CHDbits 彩虹岛：近 10 年的老站点，影视资源很丰富。 SSD (Spring Sunday)：2010 年创建的老站点，前身为 CMCT 触摸春天。 M-Team 馒头：有比较多的成人内容，官方提供付费邀请码购买渠道。 BT School 比特校园：2019 年刚创建的新站点，门槛相对比较低。 HD Time 高清时间：老站点，但是没什么名气。 52PT 我爱PT：新站点。 HDSky 天空：综合站点。 TTG：国内大站之一，2014 年末作为 TTG 出现。 Ourbits 我堡：算是国内大站了，没啥特色。 HDHome 家园：2015 年左右成立的 PT 站，没啥特色。 PTHome 铂金家：2018 年左右成立的新站，没啥特色。 HDCity 城市：2016 年底成立的新站（相对来说）。 NicePT 老师站：又成为小馒头（相对于 M-Team 来说），主要为成人内容。 CCFBits 精品高清：挺老的大站了，资源很丰富也很低调。 HDR (HDRoute)：前身为 HDRoad 思路高清，历史悠久。 LeagueHD 柠檬：小站中发展的还算不错的，2019 年成立。 Haidan 海胆之家：2020 年刚成立的小站。   教育网 PT，部分 tracker 可能仅允许教育网或 IPv6 连接。入站门槛较低，可以凭借 edu 教育域名的邮箱进行注册，也可以通过校内用户发起邀请。对分享率和种子规范的限制比较宽松。  NanyangPT 南洋：西安交通大学 PT 站 BYR 北邮人：北京邮电大学 PT 站，仅对 IPv6 开放 TJUPT 北洋园：天津大学 PT 站 葡萄PT：上海交通大学 PT 站 NPUPT 蒲公英：西北工业大学 PT 站 BITPT 极速之星：北京理工大学 PT 站 六维空间：东北大学 PT 站 NexusHD：浙江大学 PT 站，仅供校内用户访问。   以动漫资源为主的有  U2 动漫花园 幼儿园：老牌动漫 PT 站。各种上古资源都能找到。 Skyey Snow 天雪动漫：基于 Discuz! 构建的 PT 站点，相对来说新一些。   以音乐资源为主的有  OpenCD 皇后 PT：小体积种子比较多，基本靠攒魔力值来保号。    用户规范 对于用户，无论是公网 PT 站还是教育网 PT 站，往往都有以下要求：\n  上传、下载量：新手考核计划一般为一个月内 \u0026gt;=50GB 的上传下载量。部分教育网 PT 站可能没有新手考核要求。\n  分享率（上传量/下载量）：PT 站的优质资源离不开各位用户的分享和做种。为了减少吸血鬼用户的影响，几乎所有 PT 站点都会要求用户的风险率超过一定值。除此之外，用户分享率与用户等级相关，如果风险率低于标准会自动回退到较低的用户等级。\n  魔力值（Bonus points，即积分，获得于用户赠送、活动奖励或做种）：魔力值可以用于兑换站内头衔、更改用户名、消除广告，甚至至博彩小游戏（例如赌球或 24 点，常见于世界杯期间）。\n  最小做种时间：为了保障种子活跃度，一些 PT 站严格禁止下完就跑（称为 H\u0026amp;R, Hit and Run）的行为，要求用户至少持续做种一定时间）。摘录一段 OpenCD 的规则作为参考。\n在种子下载完成后，该种子需在 30 天内做种 36 小时，未达到此要求则记一次 H\u0026amp;R。\rH\u0026amp;R 满 10 次，即 ban。皇后及以上级别，包括 VIP，计算 HR 次数，但不 ban 号。\r消除已获得的 H\u0026amp;R 的两种方式\r1. 获得 H\u0026amp;R 的种子在 90 天内达到 300 小时做种时间则会自动消除该 H\u0026amp;R\r2. 用魔力值兑换取消 H\u0026amp;R 次数   生存指南 考核期 大部分站点都有邀请考核制度，需要在一个月时间内达成一定的上传量、下载量以及魔力值。部分站点考核由于不计算魔力值的兑换上传量，建议老老实实下载热门种子并做种。\n邀请者可以消耗数倍的魔力值来兑换一个无需新手考核的邀请码。被邀请人也可以付费捐赠（几百元不等）来免除新手考核。\n考核后 对于一些以影视作品为主的网站，尽可能的下载热门种子，这样能更快的获得上传量。可以使用 BT 客户端的 RSS 订阅功能，实现无人值守下载。 对于以小种为主的 PT 站，如 OpenCD 以及大部分教育网站点，则需要通过下载大量小体积种子并长时间做种以换取魔力值，再使用魔力值兑换上传。\n养老期 此时混 PT 只为偶尔下几个资源，而不是那么注重参与了，因此保持一个良好的分享率以备不时之需是很有必要的。\n部分站点可以通过捐赠获得终身 VIP 头衔，从此不再需要担心分享率问题。\n刷流量 想快速将上传、下载流量刷上去，最快的办法就是租用 Seedbox。Seedbox 即专用于跑 BT/PT 的服务器，一般位于海外（德国、罗马尼亚、荷兰）等地。\n可以通过 SeedBox 例如 FeralHosting 或 Seedbox.io 配合 RSS 订阅来实现无人值守下载。由于 Seedbox 带宽相对较大（普遍在 1-10Gbps 左右），盒子间互刷效果过于明显，部分 PT 站会有 seedbox 限制政策，例如限制上传、下载速度或者最大上传量。\n也可以通过 Hetzner、Kimsufi、OVHCloud 等云服务及托管商购买独立服务器（dedicated server，也称作独服、杜甫）。“大盘鸡”是坊间黑话，用以指代硬盘很大的服务器。\n当然，也可以自己搭建黑群晖或直接使用群晖 Synology、威联通 QNAP 等成品 NAS 或使用 OpenMediaVault、VMWare ESXi、UNRaid 搭建私人的 HTPC 平台。\nPT 下载客户端的选择 不同网站对于 BT 客户端的兼容性不同。尤其是 BitTorrent v2 协议推出后，与旧版本的客户端均不兼容。因此部分 PT 站会拒绝较新版本的 BT 软件。此外，普通的 PT 下载器如 Free Download Manager (FDM)、迅雷、Aria2c 以及 qBittorrent-enhanced 是被严格禁止的。\n 99.9% 的 seedbox 用户选择 Rtorrent/Rutorrent，因为有些 seedbox provider 只提供这些。 大部分 Windows 用户选择了 µTorrent (uTorrent)。但是 uTorrent 3.x/4.x 并不稳定，性能也不好，内置了浏览器、工具栏等奇怪的插件。另外一部分用户选择了 qBittorrent。 大部分群晖用户会选择 Synology Download Station；而由于糟糕的兼容性，大部分威联通用户会选择封装好的 qBittorrent。 Linux 用户可能会选择 libtorrent 或 qBittorrent-nox。  注意事项   除非在特定板块，不要在某个 PT 站提到其他 PT 站点的名字。 有些网站管理员非常介意用户流失，或者与其他站点发生过不愉快的事情，因此会对触犯此条例的用户执行封禁。\n  尽可能地尊重发布者，不要在评论区发表不积极的意见。 尊重资源发布者是一种美德。触犯此条例可能会获得警告信或者永久封禁。\n  遇到技术问题应先使用搜索引擎检索，而不是当伸手党。 网站管理员一般非常反感小白用户的问题。\n  不要作弊 由于圈子很小，可能会遭受连锁封禁（被多个站点同时封禁）。\n  不要持有小号（马甲）\n管理员一般会基于以下规则来判断马甲账号\n 用户的登录、注册 IP 用户客户端上报 Tracker 所使用的 IP 用户名及邮箱的命名规律 匿名举报    谨慎选择邀请人，不要随意向陌生人发送邀请。 部分站点对于违反某些规则的用户会采取连坐措施，封禁整个邀请链（树）。\n  不要在公共场合发送、索求邀请码，或者提到网站网址和名称。 这个“传统”已经持续近十年了，只不过是自我安慰。\n  ","permalink":"https://10cks.top/posts/pt-%E4%B8%8B%E8%BD%BD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%BB%E8%80%81%E7%AF%87%E4%B8%80%E7%AB%99%E7%82%B9%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/","summary":"本文最后更新于 2022 年 2 月。PT 站的前世今生，新手入门指南和概念扫盲。\n专题文章目录  PT 下载从入门到养老篇一：站点介绍及生存指南 PT 下载从入门到养老篇二：隐匿的地下通讯 PT 下载从入门到养老篇三：NAS 存储服务器及硬盘选购  介绍 PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。\n许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。\n目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。\n日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。\n2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。\n国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。","title":"PT 下载从入门到养老篇一：站点介绍及生存指南"},{"content":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。\n信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况：\n 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 ……  我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。\n解决问题的办法其实写在了 TCP 报文头上，下面具体分析：\n数据损坏  检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法：  1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum    接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。\n乱序和冗余  字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。  数据丢失  确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\u0026quot;确认\u0026quot;进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u0026lt; RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。  基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多：\n 发送方对数据的处理效率高于接收方，接收方达到处理能力极限，而发送方无法感知，依然大量传递数据，就造成了数据丢失。(流量太快) 发送太多的数据造成数据在信道中过于拥堵，也会造成数据丢失。(流量太多)  这两种情况都会触发 TCP 的重传机制，而重传只会丢失更多数据，应对这两种情况，我们需要更多的机制：\n 流量控制机制：找到 TCP 两方中效率低的一方一次能处理的数据峰值，用 Window 表示，发送方根据 Window 的大小发送数据包，直到接收方收到所有数据包再进行下一次数据发送。 拥塞控制机制：找到信道一次能容纳的数据峰值，具体的实现涉及很多复杂的算法。  可靠性其实是一个很大的话题，有很多细节值得深究，本文只是让读者对可靠性有个基本的认识。\n参考资料\n 车小胖的知乎回答 seq 和 ack 号的正确理解 图解 TCP 重传、滑动窗口、流量控制、拥塞控制  ","permalink":"https://10cks.top/posts/%E5%85%B3%E4%BA%8E-tcp-%E6%88%91%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88/","summary":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。\n信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况：\n 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 ……  我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。\n解决问题的办法其实写在了 TCP 报文头上，下面具体分析：\n数据损坏  检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法：  1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum    接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。\n乱序和冗余  字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。  数据丢失  确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\u0026quot;确认\u0026quot;进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u0026lt; RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。  基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多：","title":"关于TCP我学到了什么"},{"content":"markdown 里写代码块 这部分用直观的对照一个一个例子来呈现，先展示代码块渲染在页面上的样子，紧接着展示 markdown 源码怎么写。\n1. 最普通的用法 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  markdown 写法：\n1 2 3 4 5  ```rust fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   对于不带行号的代码块，默认的样式布局可能会显得有些局促，调整一下文章的 CSS：\n1 2 3 4 5  /* 不带行号的代码块 */ .highlight\u0026gt;pre { padding: 10px; /* 适当留出边距 */ overflow: auto; /* 代码行太长向右滚动 */ }   2. 带行号的 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table} fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   上面代码中用到了扩展语法，也就是紧跟在 rust 后、花括号内的部分。\n这里用到的参数是 lineos，有以下两种取值：\n inline：代码行号内联在代码块里，鼠标框选代码时会选中行号 table：鼠标框选代码时不会选中行号，方便复制粘贴 table 目前有个小瑕疵就是行号和代码对不齐，需要在文章的 CSS 中设置一下 line-height：  1 2 3 4  .highlight{ /* 统一行高，让行号和代码能对齐 */ line-height: 18px; }   3. 自定义起始行号 渲染效果：\n21 22 23  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table, linenostart=21} fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   linenostart=21 表示代码块从第 21 行开始计数。典型的使用场景是，在一大段代码中单摘出一小段，为保留原有的代码行号，就可以这么来用。\n4. 行高亮 我们有时候会有把某些行高亮，用来强调突出，像下面这样：\n渲染效果：\n1 2 3 4 5 6 7  fn main(){another_function(5);}fn another_function(x: i32){println!(\u0026#34;The value of x is: {}\u0026#34;,x);}  对应的 markdown 写法：\n1 2 3 4 5 6 7 8 9  ```rust {linenos=table, hl_lines=[2 \u0026#34;5-6\u0026#34;]} fn main() { another_function(5); } fn another_function(x: i32) { println!(\u0026#34;The value of x is: {}\u0026#34;, x); } ```   这里 hl_lines 就表示有哪些行高亮，它的值是一个集合，上面的例子中有两部分做了高亮。首先是第 2 行，接下来是第 5-6 行，当连续多行高亮时，可以用 ”起始行号-截止行号“ 的写法。其中「起始行号」和「截止行号」并非指左侧的代码行号，而是从这个代码块中的第一行开始数起。例如下面这段：\n渲染效果：\n21 22 23  fn main(){another_function(5);}  对应的 markdown 写法：\n1 2 3 4 5  ```rust {linenos=table, linenostart=21, hl_lines=[2]} fn main() { another_function(5); } ```   代码行号从第 21 行开始，高亮的是本代码块的第 2 行，于是实际是第 22 行高亮。\n","permalink":"https://10cks.top/posts/markdown%E9%87%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%9D%97/","summary":"markdown 里写代码块 这部分用直观的对照一个一个例子来呈现，先展示代码块渲染在页面上的样子，紧接着展示 markdown 源码怎么写。\n1. 最普通的用法 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  markdown 写法：\n1 2 3 4 5  ```rust fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } ```   对于不带行号的代码块，默认的样式布局可能会显得有些局促，调整一下文章的 CSS：\n1 2 3 4 5  /* 不带行号的代码块 */ .highlight\u0026gt;pre { padding: 10px; /* 适当留出边距 */ overflow: auto; /* 代码行太长向右滚动 */ }   2. 带行号的 渲染效果：\n1 2 3  fn main(){println!(\u0026#34;Hello, world!\u0026#34;);}  对应的 markdown 写法：","title":"markdown里写代码块"},{"content":"hugo博客通过简码的方式插入ppt、bilibili、youtube等功能\n创建: 2022-04-16 | 更新: 2022-04-16 | 字数: 676字 | 时长: 2分钟 | 作者: Sulv | 标签:\nHugo 、博客搭建\n1. 引入 ppt 功能 定位到 layouts/shortcodes目录，新建一个文件叫 ppt.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #googleslides_shortcodes { padding-bottom: 66%; position: relative; display: block; width: 100%; border-bottom: 5px solid; } #googleslides_shortcodes iframe { position: absolute; top: 0; left: 0 } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;googleslides_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;googleSlideIframe\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; src=\u0026#34;{{ .Get \u0026#34;src\u0026#34; }}\u0026#34; frameborder=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;\u0026#34; \u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   2. 引入 bilibili 视频 定位到 layouts/shortcodes目录，新建一个文件叫 bilibili.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .bilibili_shortcodes { position: relative; width: 100%; height: 0; padding-bottom: 66%; margin: auto; overflow: hidden; text-align: center; } .bilibili_shortcodes iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;bilibili_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe src=\u0026#34;https://player.bilibili.com/player.html?bvid={{.Get 0 }}\u0026amp;page={{ if .Get 1 }}{{.Get 1}}{{ else }}1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026amp;as_wide=0{{end}}\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34; \u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   3. 引入 youtube 视频 定位到 layouts/shortcodes目录，新建一个文件叫 youtube.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .youtube_shortcodes { position: relative; width: 100%; height: 0; padding-bottom: 66%; margin: auto; overflow: hidden; text-align: center; } .youtube_shortcodes iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;youtube_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe class=\u0026#34;youtube-player\u0026#34; type=\u0026#34;text/html\u0026#34; width=\u0026#34;640\u0026#34; height=\u0026#34;385\u0026#34; src=\u0026#34;https://www.youtube.com/embed/{{ index .Params 0 }}?autoplay=0\u0026#34; style=\u0026#34; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\u0026#34; allowfullscreen frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   4. 使用方法 在写文章的时候，直接按如下方式书写就可以\n4.1 ppt 展示 1 2  {a{\u0026lt; ppt src=\u0026#34;ppt网址\u0026#34; \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效   ppt展示效果：\n4.2 bilibili 视频 1 2 3 4  {a{\u0026lt; bilibili BV1Ab4y117G2 \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效 # BV1Ab4y117G2 指的是 bilibili 链接中的 bvid # 如果有集数（默认第一集），例如要播放第5集，则这样使用：{a{\u0026lt; bilibili BV1Ab4y117G2 5 \u0026gt;}}   4.3 youtube 视频 1 2  {a{\u0026lt; youtube Fm4oT4QJbWs \u0026gt;}} # 使用的时候把字母a去掉，我加上是为了防止被识别生效   5. 参考链接 https://caymanhk.gitee.io/posts/006_hugo%E9%80%9A%E8%BF%87shortcodes%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91/\nhttps://zhuanlan.zhihu.com/p/396330042\nhttps://tin6.com/post/several-hugo-shortcoeds-samples/\n","permalink":"https://10cks.top/posts/hugo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89shortcodes/","summary":"hugo博客通过简码的方式插入ppt、bilibili、youtube等功能\n创建: 2022-04-16 | 更新: 2022-04-16 | 字数: 676字 | 时长: 2分钟 | 作者: Sulv | 标签:\nHugo 、博客搭建\n1. 引入 ppt 功能 定位到 layouts/shortcodes目录，新建一个文件叫 ppt.html，放入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #googleslides_shortcodes { padding-bottom: 66%; position: relative; display: block; width: 100%; border-bottom: 5px solid; } #googleslides_shortcodes iframe { position: absolute; top: 0; left: 0 } \u0026lt;/style\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;googleslides_shortcodes\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;googleSlideIframe\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; src=\u0026#34;{{ .","title":"Hugo博客自定义shortcodes"},{"content":"1 2 3 4 5  git init git add . git commit -m \u0026#34;date\u0026#34; git remote add origin https://github.com/10cks/10cks.github.io.git git push -u -f origin master   ","permalink":"https://10cks.top/posts/github_page%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/","summary":"1 2 3 4 5  git init git add . git commit -m \u0026#34;date\u0026#34; git remote add origin https://github.com/10cks/10cks.github.io.git git push -u -f origin master   ","title":"Github_page搭建指南"},{"content":"Django架站有两种架构，一是MVC架构，二是MTV架构。 Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同. 包含系统中的数据内容，通常以数据库的形式来存储，如果数据有变动，则通知View实时改变现实的内容，还有一些处理数据的程序逻辑也在这里。\nMVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制） 从结构上看，可以分成三层, 1）最上面的一层，是直接面向最终用户的\u0026quot;视图层\u0026quot;（View）。它是提供给用户的操作界面，是程序的外壳。 2）最底下的一层，是核心的\u0026quot;数据层\u0026quot;（Model），也就是程序需要操作的数据或信息。 3）中间的一层，就是\u0026quot;控制层\u0026quot;（Controller），它负责根据用户从\u0026quot;视图层\u0026quot;输入的指令，选取\u0026quot;数据层\u0026quot;中的数据，然后对其进行相应的操作，产生最终结果。\n教程：django-tutorial\n创建APP 1 2  python manage.py startapp musics # 创建后要将APP加入setting.py的INSTALLED_APPS里面   1 2 3 4 5 6 7 8 9  INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;musics\u0026#39;, ]   生成目录结构为：\n1 2 3 4 5 6 7 8 9  C:. ├─.idea │ └─inspectionProfiles ├─djangoProject │ └─__pycache__ ├─musics │ └─migrations ├─templates └─__pycache__   创建超级用户 1 2 3  # 创建超级用户前要进行migrate：将新生成的迁移脚本，映射到数据库中，创建新的表或者修改表的结构 python manage.py migrate python manage.py createsuperuser   ","permalink":"https://10cks.top/posts/django%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","summary":"Django架站有两种架构，一是MVC架构，二是MTV架构。 Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同. 包含系统中的数据内容，通常以数据库的形式来存储，如果数据有变动，则通知View实时改变现实的内容，还有一些处理数据的程序逻辑也在这里。\nMVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制） 从结构上看，可以分成三层, 1）最上面的一层，是直接面向最终用户的\u0026quot;视图层\u0026quot;（View）。它是提供给用户的操作界面，是程序的外壳。 2）最底下的一层，是核心的\u0026quot;数据层\u0026quot;（Model），也就是程序需要操作的数据或信息。 3）中间的一层，就是\u0026quot;控制层\u0026quot;（Controller），它负责根据用户从\u0026quot;视图层\u0026quot;输入的指令，选取\u0026quot;数据层\u0026quot;中的数据，然后对其进行相应的操作，产生最终结果。\n教程：django-tutorial\n创建APP 1 2  python manage.py startapp musics # 创建后要将APP加入setting.py的INSTALLED_APPS里面   1 2 3 4 5 6 7 8 9  INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;musics\u0026#39;, ]   生成目录结构为：\n1 2 3 4 5 6 7 8 9  C:. ├─.idea │ └─inspectionProfiles ├─djangoProject │ └─__pycache__ ├─musics │ └─migrations ├─templates └─__pycache__   创建超级用户 1 2 3  # 创建超级用户前要进行migrate：将新生成的迁移脚本，映射到数据库中，创建新的表或者修改表的结构 python manage.","title":" Django使用指南"},{"content":"No time to die.\n","permalink":"https://10cks.top/about/","summary":"about","title":"About"},{"content":"计算机技术  IDA Pro权威指南第二版 汇编语言第三版 深入理解计算机系统第三版（CSAPP） 自顶向下计算机网络第七版 编译原理第二版（龙书） 编译器设计第二版 第一行代码第二版 第一行代码第三版 Android编程权威指南 操作系统精髓与设计原理第八版 加密与解密第四版 数据隐藏技术揭秘 游戏安全——手游安全技术入门 揭秘家用路由器0day漏洞挖掘技术  文学  生死疲劳 鱼王 玫瑰的名字 奥地利史 艾希曼在耶路撒冷 德国通史 看不见的城市 世界简史 剧本 对白 故事 遗落的南境：湮灭 江南三部曲 河边的错误 静静的顿河 活着为了讲述 动物庄园 月亮和六便士 三体全集 飘 霍乱时期的爱情 拉丁美洲被切开的血管 球桌闪电 西西弗神话 理想国 查拉图斯特拉如是说 自然哲学的数学原理 雪国 1984 神经漫游者 鼠疫 原则  医学 ","permalink":"https://10cks.top/list/","summary":"list","title":"List"},{"content":"是针对footer.css 这个文件的修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  .footer, .top-link { font-size: 12px; color: var(--secondary); } .footer { max-width: calc(var(--main-width) + var(--gap) * 2); margin: auto; padding: calc((var(--footer-height) - var(--gap)) / 2) var(--gap); text-align: center; line-height: 24px; } .footer span { margin-inline-start: 1px; margin-inline-end: 1px; } .footer span:last-child { white-space: nowrap; } .footer a { color: inherit; border-bottom: 1px solid var(--secondary); } .footer a:hover { border-bottom: 1px solid var(--primary); } .top-link { visibility: hidden; position: fixed; bottom: 60px; right: 30px; z-index: 99; background: var(--tertiary); width: 42px; height: 42px; padding: 12px; border-radius: 64px; transition: visibility 0.5s, opacity 0.8s linear; } .top-link, .top-link svg { filter: drop-shadow(0px 0px 0px var(--theme)); } .footer a:hover, .top-link:hover { color: var(--primary); } .top-link:focus, #theme-toggle:focus { outline: 0; } /* 划分线 */ /* 鼠标浮动 */ .post-entry:hover { transition: transform 0.3s; -webkit-transform: scale(1.2); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1) translateZ(0) translate3d(0, 0, 0) rotate(0); /* padding: 30px; 放大 /* 解析： transform:scale(值)；它的值是指定的缩放的倍率，比如： 0.5就是缩放到50%； 1就是100%； 1.5就是放大150%； 可能值：scale（x,y)是元素X轴Y轴同时缩放； scaleX（x)是元素X轴缩放； scaleY（y)是元素Y轴缩放； */ } .entry-link:hover { border-radius: 5px; box-shadow: 0px 0px 5px 0px rgb(236, 100, 9); width: 100%; height: 100%; line-height: 40px; padding-left: 20px; border-left: 3px solid rgb(236, 100, 9); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  :root { --nav-width: 1100px; --article-width: 650px; --toc-width: 200px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; /* border-right: 1px solid var(--border); */ right: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } /*blank.css文件，这里用来设置边目录*/   设置元数据要用.Params.password\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  :root { --gap: 24px; --content-gap: 20px; --nav-width: 1024px; --main-width: 720px; --header-height: 60px; --footer-height: 60px; --radius: 8px; --theme: rgb(255, 255, 255); --entry: rgb(255, 255, 255); --primary: rgb(30, 30, 30); --secondary: rgb(108, 108, 108); --tertiary: rgb(214, 214, 214); --content: rgb(31, 31, 31); --hljs-bg: rgb(28, 29, 33); --code-bg: rgb(212, 212, 212); --border: rgb(238, 238, 238); } /*修改主题背景色*/   hover的标题颜色修改是修改的footer.css中的代码\n1 2 3  .post-entry:hover h2{ color: rgb(231, 26, 26); }   修改代码背景色\n1 2 3 4 5 6 7 8 9 10 11  /*blank.css文件*/ :root { --nav-width: 1100px; --article-width: 650px; --toc-width: 200px; --hljs-bg: rgb(48, 10, 36); /*修改代码背景色*/ } .dark { --hljs-bg: rgb(48, 10, 36); }   1 2 3 4 5 6 7 8  .archive-entry:hover{ border-radius: 2px; /*这里设置边框圆角*/ border-bottom:; /*这里设置下划线*/ border-top:0px; border-left:2px solid #ee1313; border-right:0px; /* box-shadow: 0px 0px 5px 0px rgb(119, 113, 109); */ }   ","permalink":"https://10cks.top/posts/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84css/","summary":"是针对footer.css 这个文件的修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  .","title":"本博客使用的css"}]