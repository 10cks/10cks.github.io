<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 10cks</title>
    <link>https://10cks.top/posts/</link>
    <description>Recent content in Posts on 10cks</description>
    <image>
      <url>https://10cks.top/papermod-cover.png</url>
      <link>https://10cks.top/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 21 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://10cks.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android系统安全书籍</title>
      <link>https://10cks.top/posts/android%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/android%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%B9%A6%E7%B1%8D/</guid>
      <description>书籍学习 外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。
Android系统安全   Android安全架构深究
  Android安全攻防权威指南
  Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)
  Android安全技术揭秘与防范
  Android软件安全与逆向分析
  Android系统基础   Android的设计与实现*卷1
  深入理解Android卷1*邓凡平
  深入理解Android卷2_邓凡平
  深入理解Android卷3_邓凡平
  Android技术内幕.系统卷
  Android系统级深入开发.移植与调试
  Android深度探索（卷2）系统应用源代码分析与ROM定制
  拨云见日-基于android的内核与系统架构源码分析
  Android底层开发技术实战详解 内核、移植和驱动 Android源码设计模式解析与实战
  Android：Wi-Fi NFC和GPS
  Android系统原理及开发要点详解(韩超,梁泉)
  Android框架揭秘(带完整书签高清扫描版)
  Linux内核  ORANGE’S：一个操作系统的实现 Linux内核设计与实现_第三版 Linux内核设计的艺术 Linux内核完全注释V3.</description>
    </item>
    
    <item>
      <title>Rime输入法使用指南</title>
      <link>https://10cks.top/posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/</guid>
      <description>Rime 输入法  1.1. 基础配置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南
 Rime 的各种配置，均是由 .yaml 文件所定义。yaml 是一种标记语言。.yaml 文件实际上是文本文档。可使用记事本、或 Emeditor 等进行编辑。 对 Rime 进行自定义，是通过对 .custom.yaml 文件修改达成。不同的 .custom.yaml 文件，控制不同的功能实现。.custom.yaml 实际上是相当于对 .yaml 文件打补丁，在重新部署后，会将 .custom.yaml 中的内容写入 .yaml 文件中，完成自定。  例一：weasel.yaml 是常规设置，主要控制托盘图标、候选词横竖排列、界面配色等等功能。那么，我们需要定制界面配色，只需在 weasel.custom.yaml 中修改，重新部署后就可实现。 例二：default.yaml 是默认设置，主要控制快捷键、按键上屏等等。同样，作修改就编辑 default.custom.yaml 文件即可。 例三：以上是全局设置，亦即不论使用何种输入方案，均起作用。double_pinyin_flypy.custom.yaml 这种则是输入法方案设置。主要实现特殊标点符号、词库等功能。是针对特定输入方案的配置。    可见，我们绝大部分的自定，都只需修改对应的 .custom.yaml 文件即可。
 所有自定修改，都必须重新部署。在开始菜单可以找到【小狼毫】重新部署。  1.2. 皮肤设置 XNOM. 30分钟搞定 自由输入法RIME简明配置指南
打开 weasel.custom.yaml 文件，若没有，则新建。所有自定义项均在 patch: 下，注意缩进
1 2 3 4 5 6 7 8 9 10 11 12 13  customization:distribution_code_name:Weaseldistribution_version:0.</description>
    </item>
    
    <item>
      <title>使用 ECDSA 替换 RSA 生成 SSH Key</title>
      <link>https://10cks.top/posts/%E4%BD%BF%E7%94%A8-ecdsa-%E6%9B%BF%E6%8D%A2-rsa-%E7%94%9F%E6%88%90-ssh-key/</link>
      <pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/%E4%BD%BF%E7%94%A8-ecdsa-%E6%9B%BF%E6%8D%A2-rsa-%E7%94%9F%E6%88%90-ssh-key/</guid>
      <description>RSA 相信很多同学还在使用 RSA 算法用于生成 SSH 公钥，可能还会纠结选择多少位才足够安全，一般建议是 4096 bits:
ssh-keygen -t rsa -b 4096 -C &amp;#34;your_email@example.com&amp;#34; 这样我们的公钥(public key) 就会非常长：
cat test_rsa_4096.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCXlH8OxqMFhv2+En10yV2ZorDzRFXQm9pPuWQ8G5iu+cUpyhwDoKnd+l6PCZTrCgcVJgLSsVAVbZ3CK6Qnoj3TDQl4yaj90UasmivWM2INc2hObr5P2y2AqWnnZBXmxpoUGZPz/9323JalC+m/EwXNcdrC5JzgD083BC0ykfB801vcAzrZwsnbKfCUsGfUNP9mco3+hFwTqgfJxEvmI3X6hbGIGY1d2QbGMLrs3JYVsfRzJDjFaYOSwXZR6pM5uUCKENt9hOmVUZfuZqvlzLZX95yc53a6qNgOJhzaFZYz3wD2gY0dNp1boGnAtXsLqEnqtm9skp05iMuT01B9WrKEOZG5rsRZDh3bYXJ8ZP0lO/RbStuBczd8ZgObb32NfUyHG2JObDpm9mjsvWZqJxJbT5l/6vMXu8hQ6ikDrf6R33PRcRdbUIrAOpDUrfBxjkUonxjqqEbHhpcAlMWNJ4qcjtjvSnLOhH9GBn5KCnFJ7VIbyXc+Gj9AAp9xuV/9jv1R7CathkS2QrC5s9pFY3I24mFevpkioEeJYPAYUTuFBenWg5MdFK99FYO44wjmFa/RxwEQtYFXV+RybTJTC0eDpjK1u3w7LVm2JjEVoSfOJIKt9yZQn5Fm0kmueBz5aQ4CzZNoZBMKr7TT0dX9cJoANzd19uM4uCV6HRVJmQyz4Q== your_email@example.com Ed25519 其实，有一些更先进的算法，比 RSA 更安全，公钥更简短，随着区块链的普及，它们正慢慢被更多的人接受，比如 Ed25519，虽然它只有 256 bit，但安全性比 RSA 3072 还要高。
Ed25519 SSH Key 生成：
ssh-keygen -t ed25519 -C &amp;#34;your_email@example.com&amp;#34; 公钥：
cat test_ed25519.pub ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGcMXqCXtcjny9gXV1NDmwArHy0AgJs+R7N6XpOutviw your_email@example.com Github 已经默认推荐大家使用 Ed25519: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
Ed25519 是一个椭圆曲线，非常优美，安全性经过数学严格证明：
By Deirdre Connolly in [State of the Curve] (2016)
这里有一份目前使用 Ed25519 的列表： https://ianix.com/pub/ed25519-deployment.html</description>
    </item>
    
    <item>
      <title>Linux 内核监控在 Android 攻防中的应用</title>
      <link>https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。
背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。
然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:
 Never to wrestle with a pig. You get dirty, and besides, the pig likes it.
 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)
现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。
strace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(&amp;#34;/usr/bin/echo&amp;#34;, [&amp;#34;echo&amp;#34;, &amp;#34;evilpan&amp;#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, &amp;#34;/etc/ld.</description>
    </item>
    
    <item>
      <title>Termux使用指南</title>
      <link>https://10cks.top/posts/termux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 07 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/termux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>前言 很久之前就用过安卓的termux，最近在使用Telegam的API，想做一个追踪丢失手机的功能。不过在我的小米8（root）上从Google Play下载的termux无法进行pkg update，会出现502报错，百思不得其解。
后来在官方论坛找到原因，Google Play上的termux已经好久没有更新了，现在要从F-Droid上下载最新版本。我也懒得更换源了，换源的话就直接按照清华源的教程操作即可。如下：
1 2  sed -i &amp;#39;s@^\(deb.*stable main\)$@#\1\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@&amp;#39; $PREFIX/etc/apt/sources.list apt update &amp;amp;&amp;amp; apt upgrade   目标 开发一款APP，能够实现强制打开GPS并根据telegram指令定时发送GPS数据到指定用户。
实施 </description>
    </item>
    
    <item>
      <title>Botconf 2022 议题速递</title>
      <link>https://10cks.top/posts/botconf-2022-%E8%AE%AE%E9%A2%98%E9%80%9F%E9%80%92/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/botconf-2022-%E8%AE%AE%E9%A2%98%E9%80%9F%E9%80%92/</guid>
      <description>Botconf 2021/22 重新回到线下举办，并且回到了第一届的举办地——法国西海岸的南特。尽管是线下举办，但由于各国的政策要求不一，仍有部分议题的主讲人未能到场进行分享。作为一个在专业领域内比较受认可的会议，本届 Botconf 有来自世界各地的三百多名安全研究人员注册参加。此前，360 Netlab 与绿盟等国内安全公司也有议题在该会议上进行分享，本届也有一个来自阿里云的工作。
下面只挑选部分议题进行介绍，感兴趣的同学可以去官网查看全部议题进一步了解。
PS：Botconf 要求参与会议的人员不要录制视频，只有官方能够录制视频。并且每个主讲人都会对内容做出说明，如果表明是机密信息的情况下，请不要拍照或者对外进行相关内容的讨论。所以在遵守该要求的情况下，在公开议题中选取了部分议题进行简要介绍，完整、详细的内容请查看官网或者联系作者。
监控多个 P2P 僵尸网络的经验见解 来自德国达姆施塔特工业大学、美国马里兰大学和马来西亚理科大学关于监控僵尸网络的研究。研究人员认为监控僵尸网络就像盲人摸象：
P2P 僵尸网络的三个典型模式：非结构化、结构化、寄生。
利用爬虫和传感器构建僵尸网络监控系统，以下是一些系统截图（公众号会对图片进行压缩，原图是非常清晰的）：
该研究监控了 Mozi、Hajime、DDG 等比较大规模的 P2P 僵尸网络，跟踪失陷主机的相关统计信息（如国家、自治系统、地理分布等）。
研究人员通过双队列并行两万个爬虫获取信息。
后续研究人员还会增加对 Bot 生命周期的自动测量、对反监控的措施加以完善等其他功能，该项目也欢迎其他研究人员的合作。
根据通信模式检测利用合法服务进行 C&amp;amp;C 的失陷主机 来自 Akamai 的工作一向扎实。这次内容提到 Akamai 正在努力跟踪发现失陷痕迹，提醒相关用户存在可疑行为。因为很多犯罪分子都会使用合法的 Web 服务来进行攻击。例如 HAMMERTOSS 使用 Twitter、GitHub 和云存储服务进行 C&amp;amp;C 通信。
典型的三类恶意流量模式：Beacon、DGA 与多信道。
研究人员发现，使用功率谱密度（PSD）将时域数据转向频域处理，可能会很有效果。清华在 CCS 2021 上也发表了一篇利用频域分析检测恶意流量的工作《Realtime Robust Malicious Traffic Detection via Frequency Domain Analysis》，利用频域分析可能是有潜力的工作方向，感兴趣的同学可以尝试研究。
正常的设备流量模式与失陷主机的流量模式存在显著差异：
Akamai 使用 DNS 数据来进行检测：
在 Akamai 在应用中发现了许多正常情况下难以发现的恶意攻击，例如 uBlock 恶意插件（仿冒合法广告拦截插件的恶意插件）：
KashmirBlack 僵尸网络的来龙去脉 Imperva 跟踪 PHPUnit 远程代码执行（CVE-2017-9841）漏洞的在野传播，该漏洞影响波及 Drupal、WordPress、PrestaShop 与 Magento 等知名框架。</description>
    </item>
    
    <item>
      <title>CodeQL 编译 AOSP database</title>
      <link>https://10cks.top/posts/codeql-%E7%BC%96%E8%AF%91-aosp-database/</link>
      <pubDate>Wed, 04 May 2022 18:41:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/codeql-%E7%BC%96%E8%AF%91-aosp-database/</guid>
      <description>build aosp   安装aosp需要的编译依赖 https://source.android.com/setup/build/initializing
  下载源码 https://source.android.com/setup/build/downloading
  sudo apt-get updatesudo apt-get install repomkdir aosp_workdircd aosp_workdirrepo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b masterrepo sync 要下很久，可以用sudo iftop来看一下下载速度。
 编译aosp  source build/envsetup.shlunch aosp_x86_64-engmake -j32 build codeql database 到这里首先我们选择我们想看的目录，这里我选择frameworks/av/media，然后递归touch这个目录下的所有文件，这个作用是为了更新时间戳，这样make的时候，这部分文件就会重新被make
➜ aosp_workdir cd frameworks/av/media ➜ media git:(011dbb4bf7) find ./ * -exec touch {} \; 然后设置一个环境变量，并编译db即可，这部分参考自葫芦娃的文章。
export ALLOW_NINJA_ENV=truecodeql database create out/codeql-frameworks \--language=cpp \--command=&amp;#34;`pwd`/build/soong/soong_ui.</description>
    </item>
    
    <item>
      <title>PT 下载从入门到养老篇一：站点介绍及生存指南</title>
      <link>https://10cks.top/posts/pt-%E4%B8%8B%E8%BD%BD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%BB%E8%80%81%E7%AF%87%E4%B8%80%E7%AB%99%E7%82%B9%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 04 May 2022 14:49:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/pt-%E4%B8%8B%E8%BD%BD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%BB%E8%80%81%E7%AF%87%E4%B8%80%E7%AB%99%E7%82%B9%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</guid>
      <description>本文最后更新于 2022 年 2 月。PT 站的前世今生，新手入门指南和概念扫盲。
专题文章目录  PT 下载从入门到养老篇一：站点介绍及生存指南 PT 下载从入门到养老篇二：隐匿的地下通讯 PT 下载从入门到养老篇三：NAS 存储服务器及硬盘选购  介绍 PT (Private Tracker) 是一种基于私有 BT Tracker 服务器的资源传播形式，经授权的用户使用受允许的客户端进行种子制作与下载。相较于传统 BT 和 emule，PT 站往往采取了严格的邀请制度以及免责制度来规避法律风险，同时要求用户客户端开启传输加密以绕过运营商的检测策略。当然，从实际上来说 PT 站的运营、使用仍然是违背了各国版权法的。
许多高清爱好者聚集在 PT 站，发布翻录的蓝光原盘、CD 资源以及录制的高清卫星电视讯号；得益于 Netflix、HBO、Apple TV 等高清流媒体在线视频平台的发展，近年也出现了一些 WEB-DL (Download from Web) 资源。
目前国内使用的 PT 站源码大部分为基于浙江大学 xiazuojie 团队所开发的开源整站项目 NexusPHP，基于 PHP + MySQL + memcached。部分站点使用 Discuz! 进行二次开发。
日前，@burpheart 基于上游项目，开发了新版的 NexuxPHP Safe。其修复了一些已知的安全漏洞，并加入了一些增强用户体验的小功能。
2022 年更新：@burpheart 似乎逐步淡出了项目维护。目前项目迁移至 xiaomlove/nexusphp，由 @xiaomlove 为主的开发者继续维护。
国内 PT 站可以划分为两个系别：教育网 PT 站 与 公网 PT 站。</description>
    </item>
    
    <item>
      <title>关于TCP我学到了什么</title>
      <link>https://10cks.top/posts/%E5%85%B3%E4%BA%8E-tcp-%E6%88%91%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 04 May 2022 14:49:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/%E5%85%B3%E4%BA%8E-tcp-%E6%88%91%E5%AD%A6%E5%88%B0%E4%BB%80%E4%B9%88/</guid>
      <description>TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。
信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况：
 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 ……  我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。
解决问题的办法其实写在了 TCP 报文头上，下面具体分析：
数据损坏  检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法：  1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum    接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。
乱序和冗余  字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。  数据丢失  确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对&amp;quot;确认&amp;quot;进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO &amp;lt; RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。  基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多：</description>
    </item>
    
    <item>
      <title>markdown里写代码块</title>
      <link>https://10cks.top/posts/markdown%E9%87%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%9D%97/</link>
      <pubDate>Fri, 01 Apr 2022 14:49:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/markdown%E9%87%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%9D%97/</guid>
      <description>markdown 里写代码块 这部分用直观的对照一个一个例子来呈现，先展示代码块渲染在页面上的样子，紧接着展示 markdown 源码怎么写。
1. 最普通的用法 渲染效果：
1 2 3  fn main(){println!(&amp;#34;Hello, world!&amp;#34;);}  markdown 写法：
1 2 3 4 5  ```rust fn main() { println!(&amp;#34;Hello, world!&amp;#34;); } ```   对于不带行号的代码块，默认的样式布局可能会显得有些局促，调整一下文章的 CSS：
1 2 3 4 5  /* 不带行号的代码块 */ .highlight&amp;gt;pre { padding: 10px; /* 适当留出边距 */ overflow: auto; /* 代码行太长向右滚动 */ }   2. 带行号的 渲染效果：
1 2 3  fn main(){println!(&amp;#34;Hello, world!&amp;#34;);}  对应的 markdown 写法：</description>
    </item>
    
    <item>
      <title>Hugo博客自定义shortcodes</title>
      <link>https://10cks.top/posts/hugo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89shortcodes/</link>
      <pubDate>Fri, 01 Apr 2022 14:41:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/hugo%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%AE%9A%E4%B9%89shortcodes/</guid>
      <description>hugo博客通过简码的方式插入ppt、bilibili、youtube等功能
创建: 2022-04-16 | 更新: 2022-04-16 | 字数: 676字 | 时长: 2分钟 | 作者: Sulv | 标签:
Hugo 、博客搭建
1. 引入 ppt 功能 定位到 layouts/shortcodes目录，新建一个文件叫 ppt.html，放入如下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; #googleslides_shortcodes { padding-bottom: 66%; position: relative; display: block; width: 100%; border-bottom: 5px solid; } #googleslides_shortcodes iframe { position: absolute; top: 0; left: 0 } &amp;lt;/style&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;googleslides_shortcodes&amp;#34;&amp;gt; &amp;lt;iframe id=&amp;#34;googleSlideIframe&amp;#34; width=&amp;#34;100%&amp;#34; height=&amp;#34;100%&amp;#34; src=&amp;#34;{{ .</description>
    </item>
    
    <item>
      <title>Github_page搭建指南</title>
      <link>https://10cks.top/posts/github_page%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 01 Mar 2022 14:41:48 +0800</pubDate>
      
      <guid>https://10cks.top/posts/github_page%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</guid>
      <description>1 2 3 4 5  git init git add . git commit -m &amp;#34;date&amp;#34; git remote add origin https://github.com/10cks/10cks.github.io.git git push -u -f origin master   </description>
    </item>
    
    <item>
      <title> Django使用指南</title>
      <link>https://10cks.top/posts/django%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/django%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>Django架站有两种架构，一是MVC架构，二是MTV架构。 Django的MTV模式本质上与MVC模式没有什么差别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同. 包含系统中的数据内容，通常以数据库的形式来存储，如果数据有变动，则通知View实时改变现实的内容，还有一些处理数据的程序逻辑也在这里。
MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制） 从结构上看，可以分成三层, 1）最上面的一层，是直接面向最终用户的&amp;quot;视图层&amp;quot;（View）。它是提供给用户的操作界面，是程序的外壳。 2）最底下的一层，是核心的&amp;quot;数据层&amp;quot;（Model），也就是程序需要操作的数据或信息。 3）中间的一层，就是&amp;quot;控制层&amp;quot;（Controller），它负责根据用户从&amp;quot;视图层&amp;quot;输入的指令，选取&amp;quot;数据层&amp;quot;中的数据，然后对其进行相应的操作，产生最终结果。
教程：django-tutorial
创建APP 1 2  python manage.py startapp musics # 创建后要将APP加入setting.py的INSTALLED_APPS里面   1 2 3 4 5 6 7 8 9  INSTALLED_APPS = [ &amp;#39;django.contrib.admin&amp;#39;, &amp;#39;django.contrib.auth&amp;#39;, &amp;#39;django.contrib.contenttypes&amp;#39;, &amp;#39;django.contrib.sessions&amp;#39;, &amp;#39;django.contrib.messages&amp;#39;, &amp;#39;django.contrib.staticfiles&amp;#39;, &amp;#39;musics&amp;#39;, ]   生成目录结构为：
1 2 3 4 5 6 7 8 9  C:. ├─.idea │ └─inspectionProfiles ├─djangoProject │ └─__pycache__ ├─musics │ └─migrations ├─templates └─__pycache__   创建超级用户 1 2 3  # 创建超级用户前要进行migrate：将新生成的迁移脚本，映射到数据库中，创建新的表或者修改表的结构 python manage.</description>
    </item>
    
    <item>
      <title>本博客使用的css</title>
      <link>https://10cks.top/posts/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://10cks.top/posts/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84css/</guid>
      <description>是针对footer.css 这个文件的修改
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  .</description>
    </item>
    
  </channel>
</rss>
