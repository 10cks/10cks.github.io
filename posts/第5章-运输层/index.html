<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>第 5 章 运输层 | 10cks</title>
<meta name="keywords" content=", " />
<meta name="description" content="第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。">
<meta name="author" content="">
<link rel="canonical" href="https://10cks.top/posts/%E7%AC%AC5%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.242075b29caa07ce3add2970fad29fefd91a0a156d0ea24cd3ff0493bcafea27.css" integrity="sha256-JCB1spyqB8463Slw&#43;tKf79kaChVtDqJM0/8Ek7yv6ic=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://10cks.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://10cks.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://10cks.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://10cks.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://10cks.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');

            }
        }
    })();
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
            .post-entry:hover {
				transition: transform 0.5s;
				-webkit-transform: scale(1.2);
				-moz-transform: scale(1.2);
				-ms-transform: scale(1.2);
				-o-transform: scale(1.2);
				transform: scale(1.03) translateZ(0) translate3d(0, 0, 0) rotate(0.01deg);
			}
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js"
    integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg"
    crossorigin="anonymous"
></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css"
    integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE"
    crossorigin="anonymous"
/>
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script><meta property="og:title" content="第 5 章 运输层" />
<meta property="og:description" content="第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://10cks.top/posts/%E7%AC%AC5%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/" /><meta property="og:image" content="https://10cks.top/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-03" />
<meta property="article:modified_time" content="2022-05-03" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://10cks.top/papermod-cover.png"/>

<meta name="twitter:title" content="第 5 章 运输层"/>
<meta name="twitter:description" content="第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://10cks.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "第 5 章 运输层",
      "item": "https://10cks.top/posts/%E7%AC%AC5%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "第 5 章 运输层",
  "name": "第 5 章 运输层",
  "description": "第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。",
  "keywords": [
    "", ""
  ],
  "articleBody": "第 5 章 运输层 运输层协议概述 进程之间的通信  运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 应用进程之间的通信又称为端到端的通信。 运输层协议和网络层协议的主要区别  运输层的两个主要协议  (1) 用户数据报协议 UDP(User Datagram Protocol)  UDP 传送的数据单位协议是 UDP 报文或用户数据报。   (2) 传输控制协议 TCP(Transmission Control Protocol)  TCP 传送的数据单位协议是 TCP 报文段(segment)    运输层的端口  软件端口与硬件端口  在协议栈层间的抽象的协议端口是软件端口。 路由器或交换机上的端口是硬件端口。   三类端口  熟知端口，数值一般为 0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。    用户数据报协议 UDP UDP 概述  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  UDP 的首部格式 传输控制协议 TCP 概述 TCP 最主要的特点  传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  TCP 的连接  TCP 连接的端点叫做套接字(socket)或插口。  套接字 socket = (IP地址: 端口号)    可靠传输的工作原理 停止等待协议 连续 ARQ 协议 TCP 报文段的首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 可靠传输的实现 以字节为单位的滑动窗口  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 * 1 * 2 * 3 * 4\n超时重传时间的选择  超时重传  TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。    一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： * 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：（其中 RTTd 为偏差的加权平均值）\n选择确认 SACK TCP的流量控制 利用滑动窗口实现流量控制  TCP 流量控制  流量控制是为了控制发送方发送速率，保证接收方来得及接收。    接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n 流量控制举例  必须考虑传输效率 TCP 的拥塞控制 拥塞控制的一般原理  如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 拥塞控制所起的作用  几种拥塞控制方法  TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。  发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。    为了便于讨论，做如下假设：\n接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 * 1. 慢开始与拥塞避免 * 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd = ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 * 2. 快重传与快恢复 * 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n随机早期检测 RED TCP 的运输连接管理 TCP 的连接建立  假设 A 为客户端，B 为服务器端。  首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\nA 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。\nB 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。\nA 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\nB 收到 A 的确认后，连接建立。\n 三次握手的原因  第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。    客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\nTCP 的连接释放  以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。  A 发送连接释放报文，FIN=1。\nB 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n当 B 不再需要连接时，发送连接释放报文，FIN=1。\nA 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\nB 收到 A 的确认后释放连接。\n 四次挥手的原因  客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。   TIME_WAIT  客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：  确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。      TCP 的有限状态机  粗实线箭头表示对客户进程的正常变迁。 粗虚线箭头表示对服务器进程的正常变迁。 另一种细线箭头表示异常变迁。  ",
  "wordCount" : "371",
  "inLanguage": "en",
  "datePublished": "2022-05-03T14:41:48+08:00",
  "dateModified": "2022-05-03T14:41:48+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://10cks.top/posts/%E7%AC%AC5%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "10cks",
    "logo": {
      "@type": "ImageObject",
      "url": "https://10cks.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://10cks.top/" accesskey="h" title="10cks (Alt + H)">10cks</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://10cks.top/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/list/" title="List">
                    <span>List</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://10cks.top/">Home</a>&nbsp;»&nbsp;<a href="https://10cks.top/posts/">Posts</a></div>
    <h1 class="post-title">
      第 5 章 运输层
    </h1>
    <div class="post-meta"><span title='2022-05-03 14:41:48 +0800 CST'>2022.05.03</span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>
            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%ac%ac-5-%e7%ab%a0--%e8%bf%90%e8%be%93%e5%b1%82" aria-label="第 5 章  运输层">第 5 章  运输层</a><ul>
                            
                    <li>
                        <a href="#%e8%bf%90%e8%be%93%e5%b1%82%e5%8d%8f%e8%ae%ae%e6%a6%82%e8%bf%b0" aria-label="运输层协议概述">运输层协议概述</a><ul>
                            
                    <li>
                        <a href="#%e8%bf%9b%e7%a8%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1" aria-label="进程之间的通信">进程之间的通信</a></li>
                    <li>
                        <a href="#%e8%bf%90%e8%be%93%e5%b1%82%e7%9a%84%e4%b8%a4%e4%b8%aa%e4%b8%bb%e8%a6%81%e5%8d%8f%e8%ae%ae" aria-label="运输层的两个主要协议">运输层的两个主要协议</a></li>
                    <li>
                        <a href="#%e8%bf%90%e8%be%93%e5%b1%82%e7%9a%84%e7%ab%af%e5%8f%a3" aria-label="运输层的端口">运输层的端口</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%94%a8%e6%88%b7%e6%95%b0%e6%8d%ae%e6%8a%a5%e5%8d%8f%e8%ae%ae-udp" aria-label="用户数据报协议 UDP">用户数据报协议 UDP</a><ul>
                            
                    <li>
                        <a href="#udp-%e6%a6%82%e8%bf%b0" aria-label="UDP 概述">UDP 概述</a></li>
                    <li>
                        <a href="#udp-%e7%9a%84%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f" aria-label="UDP 的首部格式">UDP 的首部格式</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%bc%a0%e8%be%93%e6%8e%a7%e5%88%b6%e5%8d%8f%e8%ae%ae-tcp-%e6%a6%82%e8%bf%b0" aria-label="传输控制协议 TCP 概述">传输控制协议 TCP 概述</a><ul>
                            
                    <li>
                        <a href="#tcp-%e6%9c%80%e4%b8%bb%e8%a6%81%e7%9a%84%e7%89%b9%e7%82%b9" aria-label="TCP 最主要的特点">TCP 最主要的特点</a></li>
                    <li>
                        <a href="#tcp-%e7%9a%84%e8%bf%9e%e6%8e%a5" aria-label="TCP 的连接">TCP 的连接</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="可靠传输的工作原理">可靠传输的工作原理</a><ul>
                            
                    <li>
                        <a href="#%e5%81%9c%e6%ad%a2%e7%ad%89%e5%be%85%e5%8d%8f%e8%ae%ae" aria-label="停止等待协议">停止等待协议</a></li>
                    <li>
                        <a href="#%e8%bf%9e%e7%bb%ad-arq-%e5%8d%8f%e8%ae%ae" aria-label="连续 ARQ 协议">连续 ARQ 协议</a></li></ul>
                    </li>
                    <li>
                        <a href="#tcp-%e6%8a%a5%e6%96%87%e6%ae%b5%e7%9a%84%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f" aria-label="TCP 报文段的首部格式">TCP 报文段的首部格式</a><ul>
                            
                    <li>
                        <a href="#%e5%ba%8f%e5%8f%b7-%e7%94%a8%e4%ba%8e%e5%af%b9%e5%ad%97%e8%8a%82%e6%b5%81%e8%bf%9b%e8%a1%8c%e7%bc%96%e5%8f%b7%e4%be%8b%e5%a6%82%e5%ba%8f%e5%8f%b7%e4%b8%ba-301%e8%a1%a8%e7%a4%ba%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ad%97%e8%8a%82%e7%9a%84%e7%bc%96%e5%8f%b7%e4%b8%ba-301%e5%a6%82%e6%9e%9c%e6%90%ba%e5%b8%a6%e7%9a%84%e6%95%b0%e6%8d%ae%e9%95%bf%e5%ba%a6%e4%b8%ba-100-%e5%ad%97%e8%8a%82%e9%82%a3%e4%b9%88%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%8a%a5%e6%96%87%e6%ae%b5%e7%9a%84%e5%ba%8f%e5%8f%b7%e5%ba%94%e4%b8%ba-401" aria-label="序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。">序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</a></li>
                    <li>
                        <a href="#%e7%a1%ae%e8%ae%a4%e5%8f%b7-%e6%9c%9f%e6%9c%9b%e6%94%b6%e5%88%b0%e7%9a%84%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%8a%a5%e6%96%87%e6%ae%b5%e7%9a%84%e5%ba%8f%e5%8f%b7%e4%be%8b%e5%a6%82-b-%e6%ad%a3%e7%a1%ae%e6%94%b6%e5%88%b0-a-%e5%8f%91%e9%80%81%e6%9d%a5%e7%9a%84%e4%b8%80%e4%b8%aa%e6%8a%a5%e6%96%87%e6%ae%b5%e5%ba%8f%e5%8f%b7%e4%b8%ba-501%e6%90%ba%e5%b8%a6%e7%9a%84%e6%95%b0%e6%8d%ae%e9%95%bf%e5%ba%a6%e4%b8%ba-200-%e5%ad%97%e8%8a%82%e5%9b%a0%e6%ad%a4-b-%e6%9c%9f%e6%9c%9b%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%8a%a5%e6%96%87%e6%ae%b5%e7%9a%84%e5%ba%8f%e5%8f%b7%e4%b8%ba-701b-%e5%8f%91%e9%80%81%e7%bb%99-a-%e7%9a%84%e7%a1%ae%e8%ae%a4%e6%8a%a5%e6%96%87%e6%ae%b5%e4%b8%ad%e7%a1%ae%e8%ae%a4%e5%8f%b7%e5%b0%b1%e4%b8%ba-701" aria-label="确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。">确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</a></li>
                    <li>
                        <a href="#%e6%95%b0%e6%8d%ae%e5%81%8f%e7%a7%bb-%e6%8c%87%e7%9a%84%e6%98%af%e6%95%b0%e6%8d%ae%e9%83%a8%e5%88%86%e8%b7%9d%e7%a6%bb%e6%8a%a5%e6%96%87%e6%ae%b5%e8%b5%b7%e5%a7%8b%e5%a4%84%e7%9a%84%e5%81%8f%e7%a7%bb%e9%87%8f%e5%ae%9e%e9%99%85%e4%b8%8a%e6%8c%87%e7%9a%84%e6%98%af%e9%a6%96%e9%83%a8%e7%9a%84%e9%95%bf%e5%ba%a6" aria-label="数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。">数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</a></li>
                    <li>
                        <a href="#%e7%a1%ae%e8%ae%a4-ack-%e5%bd%93-ack1-%e6%97%b6%e7%a1%ae%e8%ae%a4%e5%8f%b7%e5%ad%97%e6%ae%b5%e6%9c%89%e6%95%88%e5%90%a6%e5%88%99%e6%97%a0%e6%95%88tcp-%e8%a7%84%e5%ae%9a%e5%9c%a8%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b%e5%90%8e%e6%89%80%e6%9c%89%e4%bc%a0%e9%80%81%e7%9a%84%e6%8a%a5%e6%96%87%e6%ae%b5%e9%83%bd%e5%bf%85%e9%a1%bb%e6%8a%8a-ack-%e7%bd%ae-1" aria-label="确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。">确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</a></li>
                    <li>
                        <a href="#%e5%90%8c%e6%ad%a5-syn-%e5%9c%a8%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b%e6%97%b6%e7%94%a8%e6%9d%a5%e5%90%8c%e6%ad%a5%e5%ba%8f%e5%8f%b7%e5%bd%93-syn1ack0-%e6%97%b6%e8%a1%a8%e7%a4%ba%e8%bf%99%e6%98%af%e4%b8%80%e4%b8%aa%e8%bf%9e%e6%8e%a5%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87%e6%ae%b5%e8%8b%a5%e5%af%b9%e6%96%b9%e5%90%8c%e6%84%8f%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e5%88%99%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87%e4%b8%ad-syn1ack1" aria-label="同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。">同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</a></li>
                    <li>
                        <a href="#%e7%bb%88%e6%ad%a2-fin-%e7%94%a8%e6%9d%a5%e9%87%8a%e6%94%be%e4%b8%80%e4%b8%aa%e8%bf%9e%e6%8e%a5%e5%bd%93-fin1-%e6%97%b6%e8%a1%a8%e7%a4%ba%e6%ad%a4%e6%8a%a5%e6%96%87%e6%ae%b5%e7%9a%84%e5%8f%91%e9%80%81%e6%96%b9%e7%9a%84%e6%95%b0%e6%8d%ae%e5%b7%b2%e5%8f%91%e9%80%81%e5%ae%8c%e6%af%95%e5%b9%b6%e8%a6%81%e6%b1%82%e9%87%8a%e6%94%be%e8%bf%9e%e6%8e%a5" aria-label="终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。">终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</a></li>
                    <li>
                        <a href="#%e7%aa%97%e5%8f%a3-%e7%aa%97%e5%8f%a3%e5%80%bc%e4%bd%9c%e4%b8%ba%e6%8e%a5%e6%94%b6%e6%96%b9%e8%ae%a9%e5%8f%91%e9%80%81%e6%96%b9%e8%ae%be%e7%bd%ae%e5%85%b6%e5%8f%91%e9%80%81%e7%aa%97%e5%8f%a3%e7%9a%84%e4%be%9d%e6%8d%ae%e4%b9%8b%e6%89%80%e4%bb%a5%e8%a6%81%e6%9c%89%e8%bf%99%e4%b8%aa%e9%99%90%e5%88%b6%e6%98%af%e5%9b%a0%e4%b8%ba%e6%8e%a5%e6%94%b6%e6%96%b9%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bc%93%e5%ad%98%e7%a9%ba%e9%97%b4%e6%98%af%e6%9c%89%e9%99%90%e7%9a%84" aria-label="窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。">窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</a></li></ul>
                    </li>
                    <li>
                        <a href="#tcp-%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="TCP 可靠传输的实现">TCP 可靠传输的实现</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%a5%e5%ad%97%e8%8a%82%e4%b8%ba%e5%8d%95%e4%bd%8d%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" aria-label="以字节为单位的滑动窗口">以字节为单位的滑动窗口</a></li>
                    <li>
                        <a href="#%e8%b6%85%e6%97%b6%e9%87%8d%e4%bc%a0%e6%97%b6%e9%97%b4%e7%9a%84%e9%80%89%e6%8b%a9" aria-label="超时重传时间的选择">超时重传时间的选择</a></li>
                    <li>
                        <a href="#%e9%80%89%e6%8b%a9%e7%a1%ae%e8%ae%a4-sack" aria-label="选择确认 SACK">选择确认 SACK</a></li></ul>
                    </li>
                    <li>
                        <a href="#tcp%e7%9a%84%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="TCP的流量控制">TCP的流量控制</a><ul>
                            
                    <li>
                        <a href="#%e5%88%a9%e7%94%a8%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%ae%9e%e7%8e%b0%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="利用滑动窗口实现流量控制">利用滑动窗口实现流量控制</a></li>
                    <li>
                        <a href="#%e5%bf%85%e9%a1%bb%e8%80%83%e8%99%91%e4%bc%a0%e8%be%93%e6%95%88%e7%8e%87" aria-label="必须考虑传输效率">必须考虑传输效率</a></li></ul>
                    </li>
                    <li>
                        <a href="#tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="TCP 的拥塞控制">TCP 的拥塞控制</a><ul>
                            
                    <li>
                        <a href="#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e7%9a%84%e4%b8%80%e8%88%ac%e5%8e%9f%e7%90%86" aria-label="拥塞控制的一般原理">拥塞控制的一般原理</a></li>
                    <li>
                        <a href="#%e5%87%a0%e7%a7%8d%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e6%96%b9%e6%b3%95" aria-label="几种拥塞控制方法">几种拥塞控制方法</a></li>
                    <li>
                        <a href="#%e9%9a%8f%e6%9c%ba%e6%97%a9%e6%9c%9f%e6%a3%80%e6%b5%8b-red" aria-label="随机早期检测 RED">随机早期检测 RED</a></li></ul>
                    </li>
                    <li>
                        <a href="#tcp-%e7%9a%84%e8%bf%90%e8%be%93%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86" aria-label="TCP 的运输连接管理">TCP 的运输连接管理</a><ul>
                            
                    <li>
                        <a href="#tcp-%e7%9a%84%e8%bf%9e%e6%8e%a5%e5%bb%ba%e7%ab%8b" aria-label="TCP 的连接建立">TCP 的连接建立</a></li>
                    <li>
                        <a href="#tcp-%e7%9a%84%e8%bf%9e%e6%8e%a5%e9%87%8a%e6%94%be" aria-label="TCP 的连接释放">TCP 的连接释放</a></li>
                    <li>
                        <a href="#tcp-%e7%9a%84%e6%9c%89%e9%99%90%e7%8a%b6%e6%80%81%e6%9c%ba" aria-label="TCP 的有限状态机">TCP 的有限状态机</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="第-5-章--运输层">第 5 章  运输层<a hidden class="anchor" aria-hidden="true" href="#第-5-章--运输层">#</a></h1>
<h2 id="运输层协议概述">运输层协议概述<a hidden class="anchor" aria-hidden="true" href="#运输层协议概述">#</a></h2>
<h3 id="进程之间的通信">进程之间的通信<a hidden class="anchor" aria-hidden="true" href="#进程之间的通信">#</a></h3>
<ul>
<li>运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</li>
<li>两个主机进行通信实际上就是两个主机中的应用进程互相通信。</li>
<li>应用进程之间的通信又称为端到端的通信。</li>
<li>运输层协议和网络层协议的主要区别</li>
</ul>
<h3 id="运输层的两个主要协议">运输层的两个主要协议<a hidden class="anchor" aria-hidden="true" href="#运输层的两个主要协议">#</a></h3>
<ul>
<li>(1) 用户数据报协议 UDP(User Datagram Protocol)
<ul>
<li>UDP 传送的数据单位协议是 UDP 报文或用户数据报。</li>
</ul>
</li>
<li>(2) 传输控制协议 TCP(Transmission Control Protocol)
<ul>
<li>TCP 传送的数据单位协议是 TCP 报文段(segment)</li>
</ul>
</li>
</ul>
<h3 id="运输层的端口">运输层的端口<a hidden class="anchor" aria-hidden="true" href="#运输层的端口">#</a></h3>
<ul>
<li>软件端口与硬件端口
<ul>
<li>在协议栈层间的抽象的协议端口是软件端口。</li>
<li>路由器或交换机上的端口是硬件端口。</li>
</ul>
</li>
<li>三类端口
<ul>
<li>熟知端口，数值一般为 0~1023。</li>
<li>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ul>
</li>
</ul>
<h2 id="用户数据报协议-udp">用户数据报协议 UDP<a hidden class="anchor" aria-hidden="true" href="#用户数据报协议-udp">#</a></h2>
<h3 id="udp-概述">UDP 概述<a hidden class="anchor" aria-hidden="true" href="#udp-概述">#</a></h3>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
</ul>
<h3 id="udp-的首部格式">UDP 的首部格式<a hidden class="anchor" aria-hidden="true" href="#udp-的首部格式">#</a></h3>
<h2 id="传输控制协议-tcp-概述">传输控制协议 TCP 概述<a hidden class="anchor" aria-hidden="true" href="#传输控制协议-tcp-概述">#</a></h2>
<h3 id="tcp-最主要的特点">TCP 最主要的特点<a hidden class="anchor" aria-hidden="true" href="#tcp-最主要的特点">#</a></h3>
<ul>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h3 id="tcp-的连接">TCP 的连接<a hidden class="anchor" aria-hidden="true" href="#tcp-的连接">#</a></h3>
<ul>
<li>TCP 连接的端点叫做套接字(socket)或插口。
<ul>
<li>套接字 socket = (IP地址: 端口号)</li>
</ul>
</li>
</ul>
<h2 id="可靠传输的工作原理">可靠传输的工作原理<a hidden class="anchor" aria-hidden="true" href="#可靠传输的工作原理">#</a></h2>
<h3 id="停止等待协议">停止等待协议<a hidden class="anchor" aria-hidden="true" href="#停止等待协议">#</a></h3>
<h3 id="连续-arq-协议">连续 ARQ 协议<a hidden class="anchor" aria-hidden="true" href="#连续-arq-协议">#</a></h3>
<h2 id="tcp-报文段的首部格式">TCP 报文段的首部格式<a hidden class="anchor" aria-hidden="true" href="#tcp-报文段的首部格式">#</a></h2>
<h3 id="序号-用于对字节流进行编号例如序号为-301表示第一个字节的编号为-301如果携带的数据长度为-100-字节那么下一个报文段的序号应为-401">序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。<a hidden class="anchor" aria-hidden="true" href="#序号-用于对字节流进行编号例如序号为-301表示第一个字节的编号为-301如果携带的数据长度为-100-字节那么下一个报文段的序号应为-401">#</a></h3>
<h3 id="确认号-期望收到的下一个报文段的序号例如-b-正确收到-a-发送来的一个报文段序号为-501携带的数据长度为-200-字节因此-b-期望下一个报文段的序号为-701b-发送给-a-的确认报文段中确认号就为-701">确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。<a hidden class="anchor" aria-hidden="true" href="#确认号-期望收到的下一个报文段的序号例如-b-正确收到-a-发送来的一个报文段序号为-501携带的数据长度为-200-字节因此-b-期望下一个报文段的序号为-701b-发送给-a-的确认报文段中确认号就为-701">#</a></h3>
<h3 id="数据偏移-指的是数据部分距离报文段起始处的偏移量实际上指的是首部的长度">数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。<a hidden class="anchor" aria-hidden="true" href="#数据偏移-指的是数据部分距离报文段起始处的偏移量实际上指的是首部的长度">#</a></h3>
<h3 id="确认-ack-当-ack1-时确认号字段有效否则无效tcp-规定在连接建立后所有传送的报文段都必须把-ack-置-1">确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。<a hidden class="anchor" aria-hidden="true" href="#确认-ack-当-ack1-时确认号字段有效否则无效tcp-规定在连接建立后所有传送的报文段都必须把-ack-置-1">#</a></h3>
<h3 id="同步-syn-在连接建立时用来同步序号当-syn1ack0-时表示这是一个连接请求报文段若对方同意建立连接则响应报文中-syn1ack1">同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<a hidden class="anchor" aria-hidden="true" href="#同步-syn-在连接建立时用来同步序号当-syn1ack0-时表示这是一个连接请求报文段若对方同意建立连接则响应报文中-syn1ack1">#</a></h3>
<h3 id="终止-fin-用来释放一个连接当-fin1-时表示此报文段的发送方的数据已发送完毕并要求释放连接">终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<a hidden class="anchor" aria-hidden="true" href="#终止-fin-用来释放一个连接当-fin1-时表示此报文段的发送方的数据已发送完毕并要求释放连接">#</a></h3>
<h3 id="窗口-窗口值作为接收方让发送方设置其发送窗口的依据之所以要有这个限制是因为接收方的数据缓存空间是有限的">窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<a hidden class="anchor" aria-hidden="true" href="#窗口-窗口值作为接收方让发送方设置其发送窗口的依据之所以要有这个限制是因为接收方的数据缓存空间是有限的">#</a></h3>
<h2 id="tcp-可靠传输的实现">TCP 可靠传输的实现<a hidden class="anchor" aria-hidden="true" href="#tcp-可靠传输的实现">#</a></h2>
<h3 id="以字节为单位的滑动窗口">以字节为单位的滑动窗口<a hidden class="anchor" aria-hidden="true" href="#以字节为单位的滑动窗口">#</a></h3>
<ul>
<li>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</li>
</ul>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。
* 1
* 2
* 3
*  4</p>
<h3 id="超时重传时间的选择">超时重传时间的选择<a hidden class="anchor" aria-hidden="true" href="#超时重传时间的选择">#</a></h3>
<ul>
<li>超时重传
<ul>
<li>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</li>
</ul>
</li>
</ul>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：
* 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p>
<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：（其中 RTTd 为偏差的加权平均值）</p>
<h3 id="选择确认-sack">选择确认 SACK<a hidden class="anchor" aria-hidden="true" href="#选择确认-sack">#</a></h3>
<h2 id="tcp的流量控制">TCP的流量控制<a hidden class="anchor" aria-hidden="true" href="#tcp的流量控制">#</a></h2>
<h3 id="利用滑动窗口实现流量控制">利用滑动窗口实现流量控制<a hidden class="anchor" aria-hidden="true" href="#利用滑动窗口实现流量控制">#</a></h3>
<ul>
<li>TCP 流量控制
<ul>
<li>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</li>
</ul>
</li>
</ul>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<ul>
<li>流量控制举例</li>
</ul>
<h3 id="必须考虑传输效率">必须考虑传输效率<a hidden class="anchor" aria-hidden="true" href="#必须考虑传输效率">#</a></h3>
<h2 id="tcp-的拥塞控制">TCP 的拥塞控制<a hidden class="anchor" aria-hidden="true" href="#tcp-的拥塞控制">#</a></h2>
<h3 id="拥塞控制的一般原理">拥塞控制的一般原理<a hidden class="anchor" aria-hidden="true" href="#拥塞控制的一般原理">#</a></h3>
<ul>
<li>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</li>
<li>拥塞控制所起的作用</li>
</ul>
<h3 id="几种拥塞控制方法">几种拥塞控制方法<a hidden class="anchor" aria-hidden="true" href="#几种拥塞控制方法">#</a></h3>
<ul>
<li>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。
<ul>
<li>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</li>
</ul>
</li>
</ul>
<p>为了便于讨论，做如下假设：</p>
<p>接收方有足够大的接收缓存，因此不会发生流量控制；
虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。
* 1. 慢开始与拥塞避免
* 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 &hellip;</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。
* 2. 快重传与快恢复
* 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<h3 id="随机早期检测-red">随机早期检测 RED<a hidden class="anchor" aria-hidden="true" href="#随机早期检测-red">#</a></h3>
<h2 id="tcp-的运输连接管理">TCP 的运输连接管理<a hidden class="anchor" aria-hidden="true" href="#tcp-的运输连接管理">#</a></h2>
<h3 id="tcp-的连接建立">TCP 的连接建立<a hidden class="anchor" aria-hidden="true" href="#tcp-的连接建立">#</a></h3>
<ul>
<li>假设 A 为客户端，B 为服务器端。</li>
</ul>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
<p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
<p>B 收到 A 的确认后，连接建立。</p>
<ul>
<li>三次握手的原因
<ul>
<li>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</li>
</ul>
</li>
</ul>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h3 id="tcp-的连接释放">TCP 的连接释放<a hidden class="anchor" aria-hidden="true" href="#tcp-的连接释放">#</a></h3>
<ul>
<li>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</li>
</ul>
<p>A 发送连接释放报文，FIN=1。</p>
<p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
<p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
<p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
<p>B 收到 A 的确认后释放连接。</p>
<ul>
<li>四次挥手的原因
<ul>
<li>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</li>
</ul>
</li>
<li>TIME_WAIT
<ul>
<li>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tcp-的有限状态机">TCP 的有限状态机<a hidden class="anchor" aria-hidden="true" href="#tcp-的有限状态机">#</a></h3>
<ul>
<li>粗实线箭头表示对客户进程的正常变迁。
粗虚线箭头表示对服务器进程的正常变迁。
另一种细线箭头表示异常变迁。</li>
</ul>


  </div>

  <footer class="post-footer">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://10cks.top/posts/%E7%AC%AC4%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/">
    <span class="title">« Prev Page</span>
    <br>
    <span>第 4 章 网络层</span>
  </a>
  <a class="next" href="https://10cks.top/posts/%E7%AC%AC6%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/">
    <span class="title">Next Page »</span>
    <br>
    <span>第 6 章 应用层</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://10cks.top/">10cks</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js"
    integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg"
    crossorigin="anonymous"
></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css"
    integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE"
    crossorigin="anonymous"
/>
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>

</body>

</html>
