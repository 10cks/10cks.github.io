<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Linux 内核监控在 Android 攻防中的应用 | 10cks</title>
<meta name="keywords" content="Android, 网络安全, 逆向" />
<meta name="description" content="在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。
背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。
然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:
 Never to wrestle with a pig. You get dirty, and besides, the pig likes it.
 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)
现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。
strace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(&#34;/usr/bin/echo&#34;, [&#34;echo&#34;, &#34;evilpan&#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, &#34;/etc/ld.">
<meta name="author" content="evilpan">
<link rel="canonical" href="https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.8e905f92e5b08be10c422a09bc41029a0cb3d8f4e4eac5bce2d934533b04fae2.css" integrity="sha256-jpBfkuWwi&#43;EMQioJvEECmgyz2PTk6sW84tk0UzsE&#43;uI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://10cks.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://10cks.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://10cks.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://10cks.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://10cks.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');

            }
        }
    })();
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
            .post-entry:hover {
				transition: transform 0.5s;
				-webkit-transform: scale(1.2);
				-moz-transform: scale(1.2);
				-ms-transform: scale(1.2);
				-o-transform: scale(1.2);
				transform: scale(1.03) translateZ(0) translate3d(0, 0, 0) rotate(0.01deg);
			}
        }

    </style>
</noscript><link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js"
    integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg"
    crossorigin="anonymous"
></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css"
    integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE"
    crossorigin="anonymous"
/>
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script><meta property="og:title" content="Linux 内核监控在 Android 攻防中的应用" />
<meta property="og:description" content="在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。
背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。
然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:
 Never to wrestle with a pig. You get dirty, and besides, the pig likes it.
 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)
现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。
strace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(&#34;/usr/bin/echo&#34;, [&#34;echo&#34;, &#34;evilpan&#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, &#34;/etc/ld." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" /><meta property="og:image" content="https://10cks.top/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-09" />
<meta property="article:modified_time" content="2022-05-09" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://10cks.top/papermod-cover.png"/>

<meta name="twitter:title" content="Linux 内核监控在 Android 攻防中的应用"/>
<meta name="twitter:description" content="在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。
背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。
然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:
 Never to wrestle with a pig. You get dirty, and besides, the pig likes it.
 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)
现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。
strace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(&#34;/usr/bin/echo&#34;, [&#34;echo&#34;, &#34;evilpan&#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, &#34;/etc/ld."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://10cks.top/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Linux 内核监控在 Android 攻防中的应用",
      "item": "https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内核监控在 Android 攻防中的应用",
  "name": "Linux 内核监控在 Android 攻防中的应用",
  "description": "在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\u0026#34;/usr/bin/echo\u0026#34;, [\u0026#34;echo\u0026#34;, \u0026#34;evilpan\u0026#34;], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \u0026#34;/etc/ld.",
  "keywords": [
    "Android", "网络安全", "逆向"
  ],
  "articleBody": "在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。\n背景 为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。\n然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。某不知名安全研究员曾经说过:\n Never to wrestle with a pig. You get dirty, and besides, the pig likes it.\n 因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)\n现有方案 在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。\nstrace strace 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ strace echo evilpan execve(\"/usr/bin/echo\", [\"echo\", \"evilpan\"], 0x7fe55d5d18 /* 56 vars */) = 0 brk(NULL) = 0x57b1bd2000 faccessat(AT_FDCWD, \"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=19285, ...}) = 0 mmap(NULL, 19285, PROT_READ, MAP_PRIVATE, 3, 0) = 0x79aecf8000 close(3) = 0 openat(AT_FDCWD, \"/lib/aarch64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 read(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\267\\0\\1\\0\\0\\0p\\16\\2\\0\\0\\0\\0\\0\"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0777, st_size=1439544, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x79aecf6000 mmap(NULL, 1511520, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x79aeb5e000 mprotect(0x79aecb7000, 61440, PROT_NONE) = 0 mmap(0x79aecc6000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x158000) = 0x79aecc6000 mmap(0x79aeccc000, 12384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79aeccc000 close(3) = 0 mprotect(0x79aecc6000, 16384, PROT_READ) = 0 mprotect(0x5787f5f000, 4096, PROT_READ) = 0 mprotect(0x79aecff000, 4096, PROT_READ) = 0 munmap(0x79aecf8000, 19285) = 0 brk(NULL) = 0x57b1bd2000 brk(0x57b1bf3000) = 0x57b1bf3000 fstat(1, {st_mode=S_IFCHR|0600, st_rdev=makedev(0x88, 0x2), ...}) = 0 write(1, \"evilpan\\n\", 8evilpan ) = 8 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++   对于需要监控系统调用的场景，strace 是个非常合适的工具，因为它基于 PTRACE_SYSCALL 去跟踪并基于中断的方式去接管所有系统调用，因此即便目标使用了不依赖 libc 的内联 svc 也可以被识别到。不过这个缺点也很明显，从名称也看出来，本质上该程序是基于 ptrace 对目标进行跟踪，因此如果对方代码中有反调试措施，那么就很有可能被检测到。\n另外在 Android 系统中，APP 进程都是由 zygote fork 而出，因此使用 strace 比较不容易确定跟踪时机，而且由于许多应用有多个进程，就需要对输出结果进行额外的过滤和清洗。\n 更多关于 strace 的实现原理可以参考: How does strace work?\n jtrace 在早期 strace 程序还不支持 arm64，因此 Jonathan Levin 在编写 Android Internal 一书时就写了 jtrace 这个工具，旨在用于对 Android 应用的跟踪。虽然现在 Google 也在 AOSP 中支持了 strace，但 jtrace 仍然有其独特的优点:\n 支持系统属性的访问监控 (setprop/getprop) 支持输入事件的监控 (InputReader) 支持 Binder 信息的解析 支持 AIDL 的解析 ……  虽然 jtrace 是闭源的，但提供了独特的插件功能，用户可以根据其提供的接口去编写一个插件(动态库)，并使用 --plugin 参数或者 JTRACE_EXT_PATH 环境变量指定的路径加载插件，从而实现自定义的系统调用参数解析处理。\n虽然优点比 strace 多了不少，但其缺点并没有解决，jtrace 本身依然是基于 PTRACE_SYSCALL 进行系统调用跟踪的，因此还是很容易被应用的反调试检测到。\n 详见: http://newandroidbook.com/tools/jtrace.html\n Frida frida 是目前全球最为知名的动态跟踪工具集 (Instrumentation)，支持使用 js 脚本来对目标应用程序进行动态跟踪。相信读者对于 frida 已经不陌生，这里也就不再过多介绍。其功能之丰富毋庸置疑，但也有一些硬伤，比如:\n frida-gum 基于 inline-hook 对目标跟踪代码进行实时重编译 (JIT)，对于应用本身有较大的侵入性； frida-inject 需要依赖 ptrace 对目标应用进行第一次注入并加载 agent，有一个较短的注入窗口可能会被反调试应用检测到； frida 目前尚不支持系统调用事件级别的追踪，虽然 frida-stalker 可以做到汇编级别，但是开销过大； frida 太过知名，以至于有很多针对 frida 的特征检测； ……  类似的 Instrumentation 工具还有 QDBI，hookzz 等等。\n其他 除了上面提到的这些工具，还有很多其他工具可以进行动态监控，比如 ltrace、gdb 等但这些工具都不能完美实现我的需求。既要马儿跑得快(开销小)，又要马儿不吃草(无侵入)，那我们就只有把眼光放向内核了。\nKernel Tracing 101 如果目标是为了实现系统调用监控，以及部分系统调用参数的修改(例如 IO 重定向)，那么一个直观的想法是修改内核源码，在我们感兴趣的系统调用入口插入自己的代码实现具体功能。但是这样非常低效，一来我们要在不同的系统调用相关函数中增加代码，引入过多修改后会导致更新内核合并上游提交变得困难；二来我们每次修改后都需要重新编译内核以及对应的 AOSP 代码(因为内核在 boot.img 中，详见后文)，再烧写到手机或模拟器中，流程过于复杂。\n另外一个想法是通过在内核代码中引入一次性的 trampoline，然后在后续增加或者减少系统调用监控入口时通过内核模块的方式去进行修改。这样似乎稍微合理一些，但其实内核中已经有了许多类似的监控方案，这样做纯属重复造轮子，效率低不说还可能随时引入 kernel panic。\n大局观 那么，内核中都有哪些监控方案？这其实不是一个容易回答的问题，我们在日常运维时听说过 kprobe、jprobe、uprobe、eBPF、tracefs、systemtab、perf，……到底他们之间的的关系是什么，分别都有什么用呢？\n这里推荐一篇文章: Linux tracing systems \u0026 how they fit together，根据其中的介绍，这些内核监控方案/工具可以分为三类:\n 数据: 根据监控数据的来源划分 采集: 根据内核提供给用户态的原始事件回调接口进行划分 前端: 获取和解析监控事件数据的用户工具  后面对这些监控方案分别进行简要的介绍。\nkprobe 简单来说，kprobe 可以实现动态内核的注入，基于中断的方法在任意指令中插入追踪代码，并且通过 pre_handler/post_handler/fault_handler 去接收回调。\n使用 参考 Linux 源码中的 samples/kprobes/kprobe_example.c，一个简单的 kprobe 内核模块实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include #include #include  #define MAX_SYMBOL_LEN 64 static char symbol[MAX_SYMBOL_LEN] = \"_do_fork\"; module_param_string(symbol, symbol, sizeof(symbol), 0644); /* For each probe you need to allocate a kprobe structure */ static struct kprobe kp = { .symbol_name = symbol, }; /* kprobe pre_handler: called just before the probed instruction is executed */ static int handler_pre(struct kprobe *p, struct pt_regs *regs) { pr_info(\" pre_handler: p-addr = 0x%p, pc = 0x%lx\\n\", p-symbol_name, p-addr, (long)regs-pc); /* A dump_stack() here will give a stack backtrace */ return 0; } /* kprobe post_handler: called after the probed instruction is executed */ static void handler_post(struct kprobe *p, struct pt_regs *regs, unsigned long flags) { pr_info(\" post_handler: p-addr = 0x%p\\n\", p-symbol_name, p-addr); } /* * fault_handler: this is called if an exception is generated for any * instruction within the pre- or post-handler, or when Kprobes * single-steps the probed instruction. */ static int handler_fault(struct kprobe *p, struct pt_regs *regs, int trapnr) { pr_info(\"fault_handler: p-addr = 0x%p, trap #%dn\", p-addr, trapnr); /* Return 0 because we don't handle the fault. */ return 0; } static int __init kprobe_init(void) { int ret; kp.pre_handler = handler_pre; kp.post_handler = handler_post; kp.fault_handler = handler_fault; ret = register_kprobe(\u0026kp); if (ret  0) { pr_err(\"register_kprobe failed, returned %d\\n\", ret); return ret; } pr_info(\"Planted kprobe at %p\\n\", kp.addr); return 0; } static void __exit kprobe_exit(void) { unregister_kprobe(\u0026kp); pr_info(\"kprobe at %p unregistered\\n\", kp.addr); } module_init(kprobe_init) module_exit(kprobe_exit) MODULE_LICENSE(\"GPL\");   安装该内核模块后，每当系统中的进程调用 fork，就会触发我们的 handler，从而在 dmesg 中输出对应的日志信息。值得注意的是，kprobe 模块依赖于具体的系统架构，上述 pre_handler 中我们打印指令地址使用的是 regs-pc，这是 ARM64 的情况，如果是 X86 环境，则对应 regs-ip，可查看对应 arch 的 struct pt_regs 实现。\n原理 kprobe 框架基于中断实现。当 kprobe 被注册后，内核会将对应地址的指令进行拷贝并替换为断点指令(比如 X86 中的 int 3)，随后当内核执行到对应地址时，中断会被触发从而执行流程会被重定向到我们注册的 pre_handler 函数；当对应地址的原始指令执行完后，内核会再次执行 post_handler (可选)，从而实现指令级别的内核动态监控。也就是说，kprobe 不仅可以跟踪任意带有符号的内核函数，也可以跟踪函数中间的任意指令。\n另一个 kprobe 的同族是 kretprobe，只不过是针对函数级别的内核监控，根据用户注册时提供的 entry_handler 和 ret_handler 来分别在函数进入时和返回前进行回调。当然实现上和 kprobe 也有所不同，不是通过断点而是通过 trampoline 进行实现，可以略为减少运行开销。\n 有人可能听说过 Jprobe，那是早期 Linux 内核的的一个监控实现，现已被 Kprobe 替代。\n 拓展阅读:\n An introduction to KProbes Documentation/trace/kprobetrace.rst samples/kprobes/kprobe_example.c samples/kprobes/kretprobe_example.c  uprobe uprobe 顾名思义，相对于内核函数/地址的监控，主要用于用户态函数/地址的监控。听起来是不是有点神奇，内核怎么监控用户态函数的调用呢？\n使用 站在用户视角，我们先看个简单的例子，假设有这么个一个用户程序:\n1 2 3 4 5 6 7 8 9  // test.c #include void foo() { printf(\"hello, uprobe!\\n\"); } int main() { foo(); return 0; }   编译好之后，查看某个符号的地址，然后告诉内核我要监控这个地址的调用:\n1 2 3 4 5 6  $ gcc test.c -o test $ readelf -s test | grep foo 87: 0000000000000764 32 FUNC GLOBAL DEFAULT 13 foo $ echo 'p /root/test:0x764'  /sys/kernel/debug/tracing/uprobe_events $ echo 1  /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo 1  /sys/kernel/debug/tracing/tracing_on   然后运行用户程序并检查内核的监控返回:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ ./test \u0026\u0026 ./test hello, uprobe! hello, uprobe! $ cat /sys/kernel/debug/tracing/trace # tracer: nop # # WARNING: FUNCTION TRACING IS CORRUPTED # MAY BE MISSING FUNCTION EVENTS # entries-in-buffer/entries-written: 3/3 #P:8 # # _-----= irqs-off # / _----= need-resched # | / _---= hardirq/softirq # || / _--= preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | test-7958 [006] .... 34213.780750: p_test_0x764: (0x6236218764) test-7966 [006] .... 34229.054039: p_test_0x764: (0x5f586cb764)   当然，最后别忘了关闭监控:\n1 2 3  $ echo 0  /sys/kernel/debug/tracing/tracing_on $ echo 0  /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable $ echo  /sys/kernel/debug/tracing/uprobe_events   原理 上面的接口是基于 debugfs (在较新的内核中使用 tracefs)，即读写文件的方式去与内核交互实现 uprobe 监控。其中写入 uprobe_events 时会经过一系列内核调用:\n probes_write create_trace_uprobe kern_path: 打开目标 ELF 文件； alloc_trace_uprobe: 分配 uprobe 结构体； register_trace_uprobe: 注册 uprobe； regiseter_uprobe_event: 将 probe 添加到全局列表中，并创建对应的 uprobe debugfs 目录，即上文示例中的 p_test_0x764；  当已经注册了 uprobe 的 ELF 程序被执行时，可执行文件会被 mmap 映射到进程的地址空间，同时内核会将该进程虚拟地址空间中对应的 uprobe 地址替换成断点指令。当目标程序指向到对应的 uprobe 地址时，会触发断点，从而触发到 uprobe 的中断处理流程 (arch_uprobe_exception_notify)，进而在内核中打印对应的信息。\n与 kprobe 类似，我们可以在触发 uprobe 时候根据对应寄存器去提取当前执行的上下文信息，比如函数的调用参数等。同时 uprobe 也有类似的同族: uretprobe。使用 uprobe 的好处是我们可以获取许多对于内核态比较抽象的信息，比如 bash 中 readline 函数的返回、SSL_read/write 的明文信息等。\n拓展阅读:\n Linux uprobe: User-Level Dynamic Tracing Documentation/trace/uprobetracer.rst Linux tracing - kprobe, uprobe and tracepoint  tracepoints tracepont 是内核中提供的一种轻量级代码监控方案，可以实现动态调用用户提供的监控函数，但需要子系统的维护者根据需要自行添加到自己的代码中。\n使用 tracepoint 的使用和 uprobe 类似，主要基于 debugfs/tracefs 的文件读写去进行实现。一个区别在于 uprobe 使用的的用户自己定义的观察点(event)，而 tracepoint 使用的是内核代码中预置的观察点。\n查看内核(或者驱动)中定义的所有观察点:\n1 2 3 4 5 6 7 8  $ cat /sys/kernel/debug/tracing/available_events sctp:sctp_probe sctp:sctp_probe_path sde:sde_perf_uidle_status .... random:random_read random:urandom_read ...   在 events 对应目录下包含了以子系统结构组织的观察点目录:\n1 2 3 4 5 6 7  $ ls /sys/kernel/debug/tracing/events/random/ add_device_randomness credit_entropy_bits extract_entropy get_random_bytes mix_pool_bytes_nolock urandom_read add_disk_randomness debit_entropy extract_entropy_user get_random_bytes_arch push_to_pool xfer_secondary_pool add_input_randomness enable filter mix_pool_bytes random_read $ ls /sys/kernel/debug/tracing/events/random/random_read/ enable filter format id trigger   以 urandom 为例，这是内核的伪随机数生成函数，对其开启追踪:\n1 2 3 4 5  $ echo 1  /sys/kernel/debug/tracing/events/random/urandom_read/enable $ echo 1  /sys/kernel/debug/tracing/tracing_on $ head -c1 /dev/urandom $ cat /sys/kernel/debug/tracing/trace_pipe head-9949 [006] .... 101453.641087: urandom_read: got_bits 40 nonblocking_pool_entropy_left 0 input_entropy_left 2053   其中 trace_pipe 是输出的管道，以阻塞的方式进行读取，因此需要先开始读取再获取 /dev/urandom，然后就可以看到类似上面的输出。这里输出的格式是在内核中定义的，我们下面会看到。\n 当然，最后记得把 trace 关闭。\n 原理 根据内核文档介绍，子系统的维护者如果想在他们的内核函数中增加跟踪点，需要执行两步操作:\n 定义跟踪点 使用跟踪点  内核为跟踪点的定义提供了 TRACE_EVENT 宏。还是以 urandom_read 这个跟踪点为例，其在内核中的定义在 include/trace/events/random.h:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #undef TRACE_SYSTEM #define TRACE_SYSTEM random  TRACE_EVENT(random_read, TP_PROTO(int got_bits, int need_bits, int pool_left, int input_left), TP_ARGS(got_bits, need_bits, pool_left, input_left), TP_STRUCT__entry( __field( int, got_bits ) __field( int, need_bits ) __field( int, pool_left ) __field( int, input_left ) ), TP_fast_assign( __entry-got_bits = got_bits; __entry-need_bits = need_bits; __entry-pool_left = pool_left; __entry-input_left = input_left; ), TP_printk(\"got_bits %d still_needed_bits %d \" \"blocking_pool_entropy_left %d input_entropy_left %d\", __entry-got_bits, __entry-got_bits, __entry-pool_left, __entry-input_left) );   其中:\n random_read: trace 事件的名称，不一定要内核函数名称一致，但通常为了易于识别会和某个关键的内核函数相关联。隶属于 random 子系统(由 TRACE_SYSTEM 宏定义)； TP_PROTO: 定义了跟踪点的原型，可以理解为入参类型; TP_ARGS: 定义了”函数“的调用参数； TP_STRUCT__entry: 用于 fast binary tracing，可以理解为一个本地 C 结构体的定义； TP_fast_assign: 上述本地 C 结构体的初始化; TP_printk: 类似于 printk 的结构化输出定义，上节中 trace_pipe 的输出结果就是这里定义的；  TRACE_EVENT 宏并不会自动插入对应函数，而是通过展开定义了一个名为 trace_urandom_read 的函数，需要内核开发者自行在代码中进行调用。 上述跟踪点实际上是在 drivers/char/random.c 文件中进行了调用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  static ssize_t urandom_read_nowarn(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { int ret; nbytes = min_t(size_t, nbytes, INT_MAX  (ENTROPY_SHIFT + 3)); ret = extract_crng_user(buf, nbytes); trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(\u0026input_pool)); //  return ret; } static ssize_t urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos) { unsigned long flags; static int maxwarn = 10; if (!crng_ready() \u0026\u0026 maxwarn  0) { maxwarn--; if (__ratelimit(\u0026urandom_warning)) pr_notice(\"%s: uninitialized urandom read (%zd bytes read)\\n\", current-comm, nbytes); spin_lock_irqsave(\u0026primary_crng.lock, flags); crng_init_cnt = 0; spin_unlock_irqrestore(\u0026primary_crng.lock, flags); } return urandom_read_nowarn(file, buf, nbytes, ppos); }   值得注意的是实际上是在 urandom_read_nowarn 函数中而不是 urandom_read 函数中调用的，因此也可见注入点名称和实际被调用的内核函数名称没有直接关系，只需要便于识别和定位即可。\n根据上面的介绍我们可以了解到，tracepoint 相对于 probe 来说各有利弊:\n 缺点是需要开发者自己定义并且加入到内核代码中，对代码略有侵入性； 优点是对于参数格式有明确定义，并且在不同内核版本中相对稳定，kprobe 跟踪的内核函数可能在下个版本就被改名或者优化掉了；  另外，tracepoint 除了在内核代码中直接定义，还可以在驱动中进行动态添加，用于方便驱动开发者进行动态调试，复用已有的 debugfs 最终架构。这里有一个简单的自定义 tracepoint 示例，可用于加深对 tracepoint 使用的理解。\n拓展阅读:\n LWN: Using the TRACE_EVENT() macro (Part 1) Documentation/trace/tracepoints.rst Taming Tracepoints in the Linux Kernel  USDT USDT 表示 Userland Statically Defined Tracing，即用户静态定义追踪 (币圈同志先退下)。最早源于 Sun 的 Dtrace 工具，因此 USDT probe 也常被称为 Dtrace probe。可以理解为 kernel tracepoint 的用户层版本，由应用开发者在自己的程序中关键函数加入自定义的跟踪点，有点类似于 printf 调试法(误)。\n下面是一个简单的示例:\n1 2 3 4 5 6  #include \"sys/sdt.h\"int main() { DTRACE_PROBE(\"hello_usdt\", \"enter\"); int reval = 0; DTRACE_PROBE1(\"hello_usdt\", \"exit\", reval); }   DTRACE_PROBEn 是 UDST (systemtap) 提供的追踪点定义+插入辅助宏，n 表示参数个数。编译上述代码后就可以看到被注入的 USDT probe 信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ apt-get install systemtap-sdt-dev $ gcc hello-usdt.c -o hello-usdt $ readelf -n ./hello-usdt ... Displaying notes found in: .note.stapsdt Owner Data size Description stapsdt 0x0000002e NT_STAPSDT (SystemTap probe descriptors) Provider: \"hello_usdt\" Name: \"enter\" Location: 0x0000000000001131, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: stapsdt 0x00000038 NT_STAPSDT (SystemTap probe descriptors) Provider: \"hello_usdt\" Name: \"exit\" Location: 0x0000000000001139, Base: 0x0000000000002004, Semaphore: 0x0000000000000000 Arguments: -4@-4(%rbp)   readelf -n 表示输出 ELF 中 NOTE 段的信息。\n在使用 trace 工具(如 BCC、SystemTap、dtrace) 对该应用进行追踪时，会在启动过程中修改目标进程的对应地址，将其替换为 probe ，在触发调用时候产生对应事件，供数据收集端使用。通常添加 probe 的方式是 基于 uprobe 实现的。\n使用 USDT 的一个好处是应用开发者可以在自己的程序中定义更加上层的追踪点，方便对于功能级别监控和分析，比如 node.js server 就自带了 USDT probe 点可用于追踪 HTTP 请求，并输出请求的路径等信息。由于 USDT 需要开发者配合使用，不符合我们最初的逆向分析需要，因此就不过多介绍了。(其实是懒得搭环境)\n拓展阅读:\n Exploring USDT Probes on Linux LWN: Using user-space tracepoints with BPF  小结 上述介绍的四种常见内核监控方案，根据静态/动态类型以及面向内核还是用户应用来划分的话，可以用下表进行概况:\n   监控方案 静态 动态 内核 用户     Kprobes  ✔ ✔    Uprobes  ✔  ✔   Tracepoints ✔  ✔    USDT ✔   ✔    准确来说 USDT 不算是一种独立的内核监控数据源，因为其实现还是依赖于 uprobe，不过为了对称还是放在这里，而且这样目录比较好看。\n采集 \u0026 前端 上面我们介绍了几种当今内核中主要的监控数据来源，基本上可以涵盖所有的监控需求。不过从易用性上来看，只是实现了基本的架构，使用上有的是基于内核提供的系统调用/驱动接口，有的是基于 debugfs/tracefs，对用户而言不太友好，因此就有了许多封装再封装的监控前端，本节对这些主要的工具进行简要介绍。\nftrace ftrace 是内核中用于实现内部追踪的一套框架，这么说有点抽象，但实际上我们前面已经用过了，就是 tracefs 中的使用的方法。\n 在旧版本中内核中(4.1 之前)使用 debugfs，一般挂载到 /sys/kernel/debug/tracing；在新版本中使用独立的 tracefs，挂载到 /sys/kernel/tracing。但出于兼容性原因，原来的路径仍然保留，所以我们将其统一称为 tracefs。\n ftrace 通常被叫做 function tracer，但除了函数跟踪，还支持许多其他事件信息的追踪:\n hwlat: 硬件延时追踪 irqsoff: 中断延时追踪 preemptoff: 追踪指定时间片内的 CPU 抢占事件 wakeup: 追踪最高优先级的任务唤醒的延时 branch: 追踪内核中的 likely/unlikely 调用 mmiotrace: 追踪某个二进制模块所有对硬件的读写事件 ……  Android 中提供了一个简略的文档指导如何为内核增加 ftrace 支持，详见: Using ftrace。\nperf perf 是 Linux 发行版中提供的一个性能监控程序，基于内核提供的 perf_event_open 系统调用来对进程进行采样并获取信息。Linux 中的 perf 子系统可以实现对 CPU 指令进行追踪和计数，以及收集 kprobe、uprobe 和 tracepoints 的信息，实现对系统性能的分析。\n在 Android 中提供了一个简单版的 perf 程序 simpleperf，接口和 perf 类似。\n虽然可以监测到系统调用，但缺点是无法获取系统调用的参数，更不可以动态地修改内核。因此对于安全测试而言作用不大，更多是给 APP 开发者和手机厂商用于性能热点分析。值得一提的是，perf 子系统曾经出过不少漏洞，在 Android 内核提权史中也曾经留下过一点足迹 :D\neBPF eBPF 为 extended Berkeley Packet Filter 的缩写，BPF 最早是用于包过滤的精简虚拟机，拥有自己的一套指令集，我们常用的 tcpdump 工具内部就会将输入的过滤规则转换为 BPF 指令，比如:\n1 2 3 4 5 6 7  $ tcpdump -i lo0 'src 1.2.3.4' -d (000) ld [0] (001) jeq #0x2000000 jt 2\tjf 5 (002) ld [16] (003) jeq #0x1020304 jt 4\tjf 5 (004) ret #262144 (005) ret #0   该汇编指令表示令过滤器只接受 IP 包，并且来源 IP 地址为 1.2.3.4。其中的指令集可以参考 Linux Socket Filtering aka Berkeley Packet Filter (BPF)。eBPF 在 BPF 指令集上做了许多增强(extend):\n 寄存器个数从 2 个增加为 10 个 (R0 - R9)； 寄存器大小从 32 位增加为 64 位； 条件指令 jt/jf 的目标替换为 jt/fall-through，简单来说就是 else 分支可以默认忽略； 增加了 bpf_call 指令以及对应的调用约定，减少内核调用的开销； ……  内核存在一个 eBPF 解释器，同时也支持实时编译(JIT)增加其执行速度，但很重要的一个限制是 eBPF 程序不能影响内核正常运行，在 内核加载 eBPF 程序前会对其进行一次语义检查，确保代码的安全性，主要限制为:\n 不能包含循环，这是为了防止 eBPF 程序过度消耗系统资源(5.3 中增加了部分循环支持)； 不能反向跳转，其实也就是不能包含循环； BPF 程序的栈大小限制为 512 字节； ……  具体的限制策略都在内核的 eBPF verifier 中，不同版本略有差异。值得一提的是，最近几年 Linux 内核出过很多 eBPF 的漏洞，大多是 verifier 的验证逻辑错误，其中不少还上了 Pwn2Own，但是由于权限的限制在 Android 中普通应用无法执行 bpf(2) 系统调用，因此并不受影响。\neBPF 和 perf_event 类似，通过内核虚拟机的方式实现监控代码过滤的动态插拔，这在许多场景下十分奏效。对于普通用户而言，基本上不会直接编写 eBPF 的指令去进行监控，虽然内核提供了一些宏来辅助 eBPF 程序的编写，但实际上更多的是使用上层的封装框架去调用，其中最著名的一个就是 BCC。\nBCC BCC (BPF Compiler Collection) 包含了一系列工具来协助运维人员编写监控代码，其中使用较多的是其 Python 绑定。一个简单的示例程序如下:\n1 2 3 4 5 6 7 8  from bcc import BPF prog=\"\"\" int kprobe__sys_clone(void *ctx) { bpf_trace_printk(\"Hello, World!\\\\n\"); return 0; } \"\"\" BPF(text=prog).trace_print()   执行该 python 代码后，每当系统中的进程调用 clone 系统调用，该程序就会打印 “Hello World” 输出信息。 可以看到这对于动态监控代码非常有用，比如我们可以通过 python 传入参数指定打印感兴趣的系统调用及其参数，而无需频繁修改代码。\neBPF 可以获取到内核中几乎所有的监控数据源，包括 kprobes、uprobes、tracepoints 等等，官方 repo 中给出了许多示例程序，比如 opensnoop 监控文件打开行为、execsnoop 监控程序的执行。后文我们会在 Android 系统进行实际演示来感受其威力。\nbpftrace bpftrace 是 eBPF 框架的另一个上层封装，与 BCC 不同的是 bpftrace 定义了一套自己的 DSL 脚本语言，语法(也)类似于 awk，从而可以方便用户直接通过命令行实现丰富的功能，截取几条官方给出的示例:\n1 2 3 4 5  # 监控系统所有的打开文件调用(open/openat)，并打印打开文件的进程以及被打开的文件路径 bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf(\"%s %s\\n\", comm, str(args-filename)); }' # 统计系统中每个进程执行的系统调用总数 bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'   官方同样也给出了许多 .bt 脚本示例，可以通过其代码进行学习和编写。\n拓展阅读:\n LWN: A thorough introduction to eBPF Extending the Kernel with eBPF https://www.opersys.com/downloads/cc-slides/android-debug/slides-main-211122.html#/ http://www.caveman.work/2019/01/29/eBPF-on-Android/  SystemTap SystemTap(stab) 是 Linux 中的一个命令行工具，可以对各种内核监控源信息进行结构化输出。同时也实现了自己的一套 DSL 脚本，语法类似于 awk，可实现系统监控命令的快速编程。\n使用 systemtap 需要包含内核源代码，因为需要动态编译和加载内核模块。在 Android 中还没有官方的支持，不过有一些开源的 systemtap 移植。\n拓展阅读: Comparing SystemTap and bpftrace\n其他 除了上面介绍的这些，还有许多开源的内核监控前端，比如 LTTng、trace-cmd、kernelshark等，内核监控输出以结构化的方式进行保存、处理和可视化，对于大量数据而言是非常实用的。限于篇幅不再对这些工具进行一一介绍，而且笔者使用的也不多，后续有机会再进行研究。\nAndroid 移植 上面说了那么多，终究只是 Linux 发行版上的热闹，那么这些 trace 方法在 Android 上行得通吗？理论上 AOSP 的代码是开源的，内核也是开源的，编译一下不就好了。但实践起来我们会遇到几个方面的困难:\n 许多工具需要编译代码，BCC 工具还需要 Python 运行，这在默认的 Android 环境中不存在； 原厂提供的预编译内核镜像不带有 kprobe 等监控功能支持，需要自行修改配置，烧写和编译内核； Linux 旧版本对于 eBPF 的支持不完善，许多新功能都是在 5.x 后才引进，而 Android 的 Linux 内核都比较旧，需要进行 cherry-pick 甚至手动 backport； AOSP 较新版本引入了 GKI(Generic Kernel Image)，需要保持内核驱动接口的兼容性，因此内核代码不能引入过多修改； ……  由于我们主要目的是进行安卓应用逆向分析，因此最好在真机环境运行，因为许多应用并不支持 x86 环境。当然 ARM 模拟器也可以，但在攻防对抗的时可能需要进行额外的模拟器检测绕过。\n笔者使用的是 Google Pixel 5，使用其他手机的话需要适当进行调整。\n1. Debian over Android Android 系统本身并不是为了开发而设计的，因此只内置了简单的 busybox(toybox) 工具，以及一些包管理相关的程序如 pm/am/dumpsys/input 等。为了在上面构建完整的开发环境，我们需要能在安卓中运行 gcc/clang、python、Makefile 等，一个直观的想法是通过沙盒等方式在上面运行一个常见的 Linux 发行版，比如 Ubuntu 或者 Debian。\nandrodeb 正是这个想法的一个实现，其核心是基于 chroot 在 Android 中运行了一个 Debian aarch64 镜像，并可以通过 apt 等包管理工具安装所需要的编译工具链，从而在上面编译和运行 bcc 等 Linux 项目。\n在 Android 上运行 Debian 系统的示例如下:\nRunning Debian on Android\n其中的关键之处在于正确挂载原生 Android 中的映射，比如 procfs、devfs、debugfs 等。\n2. 自定义内核 解决了在 Android 上运行开发工具的问题之后，我们还需要一个支持动态调试的内核环境。在绝大多数官方固件中自带的内核都没有开启 KPROBES 的支持，这意味着我们自行编译和加载内核。为了能够支持 KPROBES、UPROBES、TRACEPOINTS 等功能，需要在内核的配置中添加以下选项:\n禁用内核的安全特性，开启调试支持:\n-d CONFIG_LTO \\\r-d CONFIG_LTO_CLANG \\\r-d CONFIG_CFI_CLANG \\\r-d CFI_PERMISSIVE \\\r-d CFI_CLANG \\\r-e CONFIG_IRQSOFF_TRACER \\\r-e CONFIG_PREEMPT_TRACER \\\r-e CONFIG_DEBUG_FS \\\r-e CONFIG_CHECKPOINT_RESTORE \\\r-d CONFIG_RANDOMIZE_BASE \\ 开启 eBPF 支持:\n-e CONFIG_BPF \\\r-e CONFIG_BPF_SYSCALL \\\r-e CONFIG_BPF_JIT \\\r-e CONFIG_HAVE_EBPF_JIT \\\r-e CONFIG_IKHEADERS \\ 开启 kprobes 支持:\n-e CONFIG_HAVE_KPROBES \\\r-e CONFIG_KPROBES \\\r-e CONFIG_KPROBE_EVENT \\ 开启 kretprobe 支持:\n-e CONFIG_KRETPROBES \\\r-e CONFIG_HAVE_KRETPROBES \\\r-d CONFIG_SHADOW_CALL_STACK \\\r-e CONFIG_ROP_PROTECTION_NONE \\ 开启 ftrace 支持:\n-e CONFIG_FTRACE_SYSCALLS \\\r-e CONFIG_FUNCTION_TRACER \\\r-e CONFIG_HAVE_DYNAMIC_FTRACE \\\r-e CONFIG_DYNAMIC_FTRACE \\ 开启 uprobes 支持:\n-e CONFIG_UPROBES \\\r-e CONFIG_UPROBE_EVENT \\\r-e CONFIG_BPF_EVENTS BCC 建议设置的选项:\n-e CONFIG_DEBUG_PREEMPT \\\r-e CONFIG_PREEMPTIRQ_EVENTS \\\r-d CONFIG_PROVE_LOCKING \\\r-d CONFIG_LOCKDEP 为了避免各类环境问题，我建议编译环境最好选择干净的虚拟机英文环境，或者直接使用 Docker 镜像，根据官方的指导去编译，见: Building Kernels。\n编译内核常见的依赖:\n1 2 3 4 5 6 7 8 9  $ pkg --add-architecture i386 $ apt install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip   拓展阅读:\n Building a Pixel kernel with KASAN+KCOV eBPF/BCC - A better low-level Instrumentation tool on Android  3. 内核移植 当你成功编译好内核并启动后，很可能会发现有一些内核分析工具比如 BCC 在使用上会出现各种问题，这通常是内核版本的原因。由于 eBPF 目前在内核中也在频繁更新，因此许多新的特性并没有增加到当前内核上。\n例如，在 Pixel 5 最新的支持的内核是 4.19 版本，在这个版本中，bpf_probe_read_user (issue#3175) 函数还没添加进内核，因此使用 BCC 会回退到 bpf_probe_read_kernel，这在内核直接读取用户空间的数据(比如系统调用的参数)时会出现错误，因此我们需要手动去 cherry-pick 对应的 commit，即在 Linux 5.5 中添加的 6ae08ae3dea2。\nBCC 所需的所有内核特性及其引进的版本列表可以参考: BCC/kernel-versions.md，部分列表如下所示:\n因此为了减少可能遇到的兼容性问题，尽量使用最新版本的内核，当然通常厂商都只维护一个较旧的 LTS 版本，只进行必要的安全性更新，如果买机不淑的话就需要自食其力了。\n实战测试 通过在上述 Android Debian 环境编译好 BCC 之后，我们就可以使用 Python 编写对应的应用跟踪分析脚本了。一般是通过应用名去过滤系统调用，但是在 Android 中还有个特别的过滤方式就是通过用户 ID，因为应用是根据动态安装获取的 UID 去进行沙盒隔离的。\n以某个层层加固的恶意 APK 为例，安装后获取其 UID 为 u0_a142，转换成数字是 10142，对其进行 exec 系统调用的监控:\n可以看到目标应用调用了 ps、getprop、pm 等程序，用来检测当前系统的 adb 状态以及所安装的应用，比如其中通过 pm path com.topjohnwu.magisk 来判断 Magisk 工具是否存在，因此存在 root 检测行为。上图中 pm 实际调用了 cmd 程序进行查找，因为 pm 本质上只是一个 shell 脚本:\n1 2 3  $ cat `which pm` #!/system/bin/sh cmd package \"$@\"   使用 UID 进行过滤的好处是可以跟踪所有 fork 的子进程和孙子进程，这是基于 PID 或者进程名跟踪所无法比拟的。除了 exec，我们还可以跟踪其他内核函数，比如 root 检测经常用到的 openat 或 access，如下所示:\n基于内核级别的监控，让应用中所有的加固/隐藏/内联汇编等防御措施形同虚设，而且可以在应用启动的初期进行观察，让应用的一切行为在我们眼中无所遁形。\nPS: 如果在使用 BCC 的过程中发现没有过滤 UID 的选项，那可能需要切换到最新的 release 版本或者 master 分支，因为这个选项是笔者最近才加上去的。\n:D\n拓展阅读:\n eBPF super powers on ARM64 and Android (slides) eBPF - Android Reverse Engineering Superpowers  总结 本文总结并分析了几种内核主要的监控方案，它们通常用于性能监控和内核调试，但我们也可以将其用做安全分析，并在 Android 中进行了实际的移植和攻防测试，并且获得了超出预期的实战效果。除了内核级别监控，我们还可以基于 uprobes 实现应用内任意地址的监控，如在 SSL_read/write 地址处获取所有 SSL 加密的数据。得益于内核提供的丰富监控原语，我们可以实现内核级别移动端沙盒，全面监控移动应用行为，也可以通过内核读写原语去实现系统调用参数修改，从而实现应用运行环境的模拟和伪造。\n",
  "wordCount" : "2389",
  "inLanguage": "en",
  "datePublished": "2022-05-09T00:00:00Z",
  "dateModified": "2022-05-09T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "evilpan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://10cks.top/posts/linux-%E5%86%85%E6%A0%B8%E7%9B%91%E6%8E%A7%E5%9C%A8-android-%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "10cks",
    "logo": {
      "@type": "ImageObject",
      "url": "https://10cks.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://10cks.top/" accesskey="h" title="10cks (Alt + H)">10cks</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://10cks.top/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://10cks.top/index.xml" title="Rss">
                    <span>Rss</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://10cks.top/">Home</a>&nbsp;»&nbsp;<a href="https://10cks.top/posts/">Posts</a></div>
    <h1 class="post-title">
      Linux 内核监控在 Android 攻防中的应用
    </h1>
    <div class="post-meta"><span title='2022-05-09 00:00:00 +0000 UTC'>2022.05.09</span>&nbsp;·&nbsp;evilpan

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>
            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%83%8c%e6%99%af" aria-label="背景">背景</a></li>
                    <li>
                        <a href="#%e7%8e%b0%e6%9c%89%e6%96%b9%e6%a1%88" aria-label="现有方案">现有方案</a><ul>
                            
                    <li>
                        <a href="#strace" aria-label="strace">strace</a></li>
                    <li>
                        <a href="#jtrace" aria-label="jtrace">jtrace</a></li>
                    <li>
                        <a href="#frida" aria-label="Frida">Frida</a></li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96" aria-label="其他">其他</a></li></ul>
                    </li>
                    <li>
                        <a href="#kernel-tracing-101" aria-label="Kernel Tracing 101">Kernel Tracing 101</a><ul>
                            
                    <li>
                        <a href="#%e5%a4%a7%e5%b1%80%e8%a7%82" aria-label="大局观">大局观</a></li>
                    <li>
                        <a href="#kprobe" aria-label="kprobe">kprobe</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8" aria-label="使用">使用</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e7%90%86" aria-label="原理">原理</a></li></ul>
                    </li>
                    <li>
                        <a href="#uprobe" aria-label="uprobe">uprobe</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-1" aria-label="使用">使用</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e7%90%86-1" aria-label="原理">原理</a></li></ul>
                    </li>
                    <li>
                        <a href="#tracepoints" aria-label="tracepoints">tracepoints</a><ul>
                            
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-2" aria-label="使用">使用</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e7%90%86-2" aria-label="原理">原理</a></li></ul>
                    </li>
                    <li>
                        <a href="#usdt" aria-label="USDT">USDT</a></li>
                    <li>
                        <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e9%87%87%e9%9b%86--%e5%89%8d%e7%ab%af" aria-label="采集 &amp;amp; 前端">采集 &amp; 前端</a><ul>
                            
                    <li>
                        <a href="#ftrace" aria-label="ftrace">ftrace</a></li>
                    <li>
                        <a href="#perf" aria-label="perf">perf</a></li>
                    <li>
                        <a href="#ebpf" aria-label="eBPF">eBPF</a><ul>
                            
                    <li>
                        <a href="#bcc" aria-label="BCC">BCC</a></li>
                    <li>
                        <a href="#bpftrace" aria-label="bpftrace">bpftrace</a></li></ul>
                    </li>
                    <li>
                        <a href="#systemtap" aria-label="SystemTap">SystemTap</a></li>
                    <li>
                        <a href="#%e5%85%b6%e4%bb%96-1" aria-label="其他">其他</a></li></ul>
                    </li>
                    <li>
                        <a href="#android-%e7%a7%bb%e6%a4%8d" aria-label="Android 移植">Android 移植</a><ul>
                            
                    <li>
                        <a href="#1-debian-over-android" aria-label="1. Debian over Android">1. Debian over Android</a></li>
                    <li>
                        <a href="#2-%e8%87%aa%e5%ae%9a%e4%b9%89%e5%86%85%e6%a0%b8" aria-label="2. 自定义内核">2. 自定义内核</a></li>
                    <li>
                        <a href="#3-%e5%86%85%e6%a0%b8%e7%a7%bb%e6%a4%8d" aria-label="3. 内核移植">3. 内核移植</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%ae%9e%e6%88%98%e6%b5%8b%e8%af%95" aria-label="实战测试">实战测试</a></li>
                    <li>
                        <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>在日常分析外部软件时，遇到的反调试/反注入防护已经越来越多，之前使用的基于 frida 的轻量级沙盒已经无法满足这类攻防水位的需要，因此需要有一种更加深入且通用的方式来对 APP 进行全面的监测和绕过。本文即为对这类方案的一些探索和实践。</p>
<h1 id="背景">背景<a hidden class="anchor" aria-hidden="true" href="#背景">#</a></h1>
<p>为了实现对安卓 APP 的全面监控，需要知道目标应用访问/打开了哪些文件，执行了哪些操作，并且可以修改控制这些操作的返回结果。一个直观的想法是通过 libc 作为统一收口来对应用行为进行收集，比如接管 open/openat/faccess/fstatat 实现文件访问监控以及进一步的文件重定向。</p>
<p>然而，现今许多聪明的加固 APP 都使用了内联系统调用汇编来绕过 libc 实现暗度陈仓，在 binary 层再加上控制流混淆、花指令、代码加密甚至是 VMP 等成熟的防御措施，使得识别这类隐藏调用变得十分困难。<a href="https://evilpan.com/about/#2018-06-30">某不知名安全研究员</a>曾经说过:</p>
<blockquote>
<p>Never to wrestle with a pig. You get dirty, and besides, the pig likes it.</p>
</blockquote>
<p>因此，我们不应该在应用层上和加固厂商做对抗，而是寻找其他突破点，以四两拨千斤的方式实现目的。当然，如果只是为了练手，那手撕虚拟机也是可以的 :)</p>
<h1 id="现有方案">现有方案<a hidden class="anchor" aria-hidden="true" href="#现有方案">#</a></h1>
<p>在介绍内核监控技术之前，我们先来看看目前已有的一些方案，以及它们的不足之处。</p>
<h2 id="strace">strace<a hidden class="anchor" aria-hidden="true" href="#strace">#</a></h2>
<p><a href="https://man7.org/linux/man-pages/man1/strace.1.html">strace</a> 是 Linux 中一个知名的用户态系统调用跟踪工具，可以输入目标进程所执行的系统调用的名称以及参数，常用于快速的应用调试和诊断。strace 的示例输出如下所示:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ strace <span class="nb">echo</span> evilpan
</span></span><span class="line"><span class="cl">execve<span class="o">(</span><span class="s2">&#34;/usr/bin/echo&#34;</span>, <span class="o">[</span><span class="s2">&#34;echo&#34;</span>, <span class="s2">&#34;evilpan&#34;</span><span class="o">]</span>, 0x7fe55d5d18 /* <span class="m">56</span> vars */<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">brk<span class="o">(</span>NULL<span class="o">)</span>                               <span class="o">=</span> 0x57b1bd2000
</span></span><span class="line"><span class="cl">faccessat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;/etc/ld.so.preload&#34;</span>, R_OK<span class="o">)</span> <span class="o">=</span> -1 ENOENT <span class="o">(</span>No such file or directory<span class="o">)</span>
</span></span><span class="line"><span class="cl">openat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;/etc/ld.so.cache&#34;</span>, O_RDONLY<span class="p">|</span>O_CLOEXEC<span class="o">)</span> <span class="o">=</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">fstat<span class="o">(</span>3, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0644, <span class="nv">st_size</span><span class="o">=</span>19285, ...<span class="o">})</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>NULL, 19285, PROT_READ, MAP_PRIVATE, 3, 0<span class="o">)</span> <span class="o">=</span> 0x79aecf8000
</span></span><span class="line"><span class="cl">close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">openat<span class="o">(</span>AT_FDCWD, <span class="s2">&#34;/lib/aarch64-linux-gnu/libc.so.6&#34;</span>, O_RDONLY<span class="p">|</span>O_CLOEXEC<span class="o">)</span> <span class="o">=</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">read<span class="o">(</span>3, <span class="s2">&#34;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0\267\0\1\0\0\0p\16\2\0\0\0\0\0&#34;</span>..., 832<span class="o">)</span> <span class="o">=</span> <span class="m">832</span>
</span></span><span class="line"><span class="cl">fstat<span class="o">(</span>3, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFREG<span class="p">|</span>0777, <span class="nv">st_size</span><span class="o">=</span>1439544, ...<span class="o">})</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>NULL, 8192, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_ANONYMOUS, -1, 0<span class="o">)</span> <span class="o">=</span> 0x79aecf6000
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>NULL, 1511520, PROT_READ<span class="p">|</span>PROT_EXEC, MAP_PRIVATE<span class="p">|</span>MAP_DENYWRITE, 3, 0<span class="o">)</span> <span class="o">=</span> 0x79aeb5e000
</span></span><span class="line"><span class="cl">mprotect<span class="o">(</span>0x79aecb7000, 61440, PROT_NONE<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>0x79aecc6000, 24576, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_FIXED<span class="p">|</span>MAP_DENYWRITE, 3, 0x158000<span class="o">)</span> <span class="o">=</span> 0x79aecc6000
</span></span><span class="line"><span class="cl">mmap<span class="o">(</span>0x79aeccc000, 12384, PROT_READ<span class="p">|</span>PROT_WRITE, MAP_PRIVATE<span class="p">|</span>MAP_FIXED<span class="p">|</span>MAP_ANONYMOUS, -1, 0<span class="o">)</span> <span class="o">=</span> 0x79aeccc000
</span></span><span class="line"><span class="cl">close<span class="o">(</span>3<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mprotect<span class="o">(</span>0x79aecc6000, 16384, PROT_READ<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mprotect<span class="o">(</span>0x5787f5f000, 4096, PROT_READ<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">mprotect<span class="o">(</span>0x79aecff000, 4096, PROT_READ<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">munmap<span class="o">(</span>0x79aecf8000, 19285<span class="o">)</span>             <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">brk<span class="o">(</span>NULL<span class="o">)</span>                               <span class="o">=</span> 0x57b1bd2000
</span></span><span class="line"><span class="cl">brk<span class="o">(</span>0x57b1bf3000<span class="o">)</span>                       <span class="o">=</span> 0x57b1bf3000
</span></span><span class="line"><span class="cl">fstat<span class="o">(</span>1, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFCHR<span class="p">|</span>0600, <span class="nv">st_rdev</span><span class="o">=</span>makedev<span class="o">(</span>0x88, 0x2<span class="o">)</span>, ...<span class="o">})</span> <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">write<span class="o">(</span>1, <span class="s2">&#34;evilpan\n&#34;</span>, 8evilpan
</span></span><span class="line"><span class="cl"><span class="o">)</span>                <span class="o">=</span> <span class="m">8</span>
</span></span><span class="line"><span class="cl">close<span class="o">(</span>1<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">close<span class="o">(</span>2<span class="o">)</span>                                <span class="o">=</span> <span class="m">0</span>
</span></span><span class="line"><span class="cl">exit_group<span class="o">(</span>0<span class="o">)</span>                           <span class="o">=</span> ?
</span></span><span class="line"><span class="cl">+++ exited with <span class="m">0</span> +++
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于需要监控系统调用的场景，strace 是个非常合适的工具，因为它基于 <code>PTRACE_SYSCALL</code> 去跟踪并基于中断的方式去接管所有系统调用，因此即便目标使用了不依赖 libc 的内联 svc 也可以被识别到。不过这个缺点也很明显，从名称也看出来，本质上该程序是基于 ptrace 对目标进行跟踪，因此如果对方代码中有反调试措施，那么就很有可能被检测到。</p>
<p>另外在 Android 系统中，APP 进程都是由 zygote fork 而出，因此使用 strace 比较不容易确定跟踪时机，而且由于许多应用有多个进程，就需要对输出结果进行额外的过滤和清洗。</p>
<blockquote>
<p>更多关于 strace 的实现原理可以参考: <a href="https://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/">How does strace work?</a></p>
</blockquote>
<h2 id="jtrace">jtrace<a hidden class="anchor" aria-hidden="true" href="#jtrace">#</a></h2>
<p>在早期 strace 程序还不支持 arm64，因此 <em>Jonathan Levin</em> 在编写 <strong>Android Internal</strong> 一书时就写了 jtrace 这个工具，旨在用于对 Android 应用的跟踪。虽然现在 Google 也在 AOSP 中支持了 strace，但 jtrace 仍然有其独特的优点:</p>
<ul>
<li>支持系统属性的访问监控 (setprop/getprop)</li>
<li>支持输入事件的监控 (InputReader)</li>
<li>支持 Binder 信息的解析</li>
<li>支持 AIDL 的解析</li>
<li>……</li>
</ul>
<p>虽然 jtrace 是闭源的，但提供了独特的插件功能，用户可以根据其提供的接口去编写一个插件(动态库)，并使用 <code>--plugin</code> 参数或者 <code>JTRACE_EXT_PATH</code> 环境变量指定的路径加载插件，从而实现自定义的系统调用参数解析处理。</p>
<p>虽然优点比 strace 多了不少，但其缺点并没有解决，jtrace 本身依然是基于 <strong>PTRACE_SYSCALL</strong> 进行系统调用跟踪的，因此还是很容易被应用的反调试检测到。</p>
<blockquote>
<p>详见: <a href="http://newandroidbook.com/tools/jtrace.html">http://newandroidbook.com/tools/jtrace.html</a></p>
</blockquote>
<h2 id="frida">Frida<a hidden class="anchor" aria-hidden="true" href="#frida">#</a></h2>
<p><a href="https://github.com/frida/frida">frida</a> 是目前全球最为知名的动态跟踪工具集 (Instrumentation)，支持使用 js 脚本来对目标应用程序进行动态跟踪。相信读者对于 frida 已经不陌生，这里也就不再过多介绍。其功能之丰富毋庸置疑，但也有一些硬伤，比如:</p>
<ul>
<li>frida-gum 基于 inline-hook 对目标跟踪代码进行实时重编译 (JIT)，对于应用本身有较大的侵入性；</li>
<li>frida-inject 需要依赖 ptrace 对目标应用进行第一次注入并加载 agent，有一个较短的注入窗口可能会被反调试应用检测到；</li>
<li>frida 目前尚不支持系统调用事件级别的追踪，虽然 frida-stalker 可以做到汇编级别，但是开销过大；</li>
<li>frida 太过知名，以至于有很多针对 frida 的特征检测；</li>
<li>……</li>
</ul>
<p>类似的 Instrumentation 工具还有 <a href="https://qbdi.quarkslab.com/">QDBI</a>，<a href="https://github.com/jmpews/Dobby">hookzz</a> 等等。</p>
<h2 id="其他">其他<a hidden class="anchor" aria-hidden="true" href="#其他">#</a></h2>
<p>除了上面提到的这些工具，还有很多其他工具可以进行动态监控，比如 ltrace、gdb 等但这些工具都不能完美实现我的需求。既要马儿跑得快(开销小)，又要马儿不吃草(无侵入)，那我们就只有把眼光放向内核了。</p>
<h1 id="kernel-tracing-101">Kernel Tracing 101<a hidden class="anchor" aria-hidden="true" href="#kernel-tracing-101">#</a></h1>
<p>如果目标是为了实现系统调用监控，以及部分系统调用参数的修改(例如 IO 重定向)，那么一个直观的想法是修改内核源码，在我们感兴趣的系统调用入口插入自己的代码实现具体功能。但是这样非常低效，一来我们要在不同的系统调用相关函数中增加代码，引入过多修改后会导致更新内核合并上游提交变得困难；二来我们每次修改后都需要重新编译内核以及对应的 AOSP 代码(因为内核在 boot.img 中，详见后文)，再烧写到手机或模拟器中，流程过于复杂。</p>
<p>另外一个想法是通过在内核代码中引入一次性的 trampoline，然后在后续增加或者减少系统调用监控入口时通过内核模块的方式去进行修改。这样似乎稍微合理一些，但其实内核中已经有了许多类似的监控方案，这样做纯属重复造轮子，效率低不说还可能随时引入 kernel panic。</p>
<h2 id="大局观">大局观<a hidden class="anchor" aria-hidden="true" href="#大局观">#</a></h2>
<p>那么，内核中都有哪些监控方案？这其实不是一个容易回答的问题，我们在日常运维时听说过 kprobe、jprobe、uprobe、eBPF、tracefs、systemtab、perf，……到底他们之间的的关系是什么，分别都有什么用呢？</p>
<p>这里推荐一篇文章: <a href="https://jvns.ca/blog/2017/07/05/linux-tracing-systems/">Linux tracing systems &amp; how they fit together</a>，根据其中的介绍，这些内核监控方案/工具可以分为三类:</p>
<ol>
<li>数据: 根据监控数据的来源划分</li>
<li>采集: 根据内核提供给用户态的原始事件回调接口进行划分</li>
<li>前端: 获取和解析监控事件数据的用户工具</li>
</ol>
<img src="https://raw.githubusercontent.com/10cks/picture/main/img/202205091955364.png" alt="trace" style="zoom: 67%;" />
<p>后面对这些监控方案分别进行简要的介绍。</p>
<h2 id="kprobe">kprobe<a hidden class="anchor" aria-hidden="true" href="#kprobe">#</a></h2>
<p>简单来说，kprobe 可以实现动态内核的注入，基于中断的方法在任意指令中插入追踪代码，并且通过 pre_handler/post_handler/fault_handler 去接收回调。</p>
<h3 id="使用">使用<a hidden class="anchor" aria-hidden="true" href="#使用">#</a></h3>
<p>参考 Linux 源码中的 <strong>samples/kprobes/kprobe_example.c</strong>，一个简单的 kprobe 内核模块实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/kprobes.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SYMBOL_LEN  64
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="kt">char</span> <span class="n">symbol</span><span class="p">[</span><span class="n">MAX_SYMBOL_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;_do_fork&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">module_param_string</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">symbol</span><span class="p">),</span> <span class="mo">0644</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* For each probe you need to allocate a kprobe structure */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">kprobe</span> <span class="n">kp</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">symbol_name</span>    <span class="o">=</span> <span class="n">symbol</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* kprobe pre_handler: called just before the probed instruction is executed */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">handler_pre</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;&lt;%s&gt; pre_handler: p-&gt;addr = 0x%p, pc = 0x%lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* A dump_stack() here will give a stack backtrace */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/* kprobe post_handler: called after the probed instruction is executed */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">handler_post</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;&lt;%s&gt; post_handler: p-&gt;addr = 0x%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">symbol_name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * fault_handler: this is called if an exception is generated for any
</span></span></span><span class="line"><span class="cl"><span class="cm"> * instruction within the pre- or post-handler, or when Kprobes
</span></span></span><span class="line"><span class="cl"><span class="cm"> * single-steps the probed instruction.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">handler_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">kprobe</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">trapnr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;fault_handler: p-&gt;addr = 0x%p, trap #%dn&#34;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">trapnr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Return 0 because we don&#39;t handle the fault. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">kprobe_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">kp</span><span class="p">.</span><span class="n">pre_handler</span> <span class="o">=</span> <span class="n">handler_pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">kp</span><span class="p">.</span><span class="n">post_handler</span> <span class="o">=</span> <span class="n">handler_post</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">kp</span><span class="p">.</span><span class="n">fault_handler</span> <span class="o">=</span> <span class="n">handler_fault</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="n">register_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;register_kprobe failed, returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;Planted kprobe at %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">kp</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">kprobe_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">unregister_kprobe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;kprobe at %p unregistered</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">kp</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">module_init</span><span class="p">(</span><span class="n">kprobe_init</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">module_exit</span><span class="p">(</span><span class="n">kprobe_exit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&#34;GPL&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装该内核模块后，每当系统中的进程调用 fork，就会触发我们的 handler，从而在 dmesg 中输出对应的日志信息。值得注意的是，kprobe 模块依赖于具体的系统架构，上述 pre_handler 中我们打印指令地址使用的是 <code>regs-&gt;pc</code>，这是 ARM64 的情况，如果是 X86 环境，则对应 <code>regs-&gt;ip</code>，可查看对应 arch 的 <code>struct pt_regs</code> 实现。</p>
<h3 id="原理">原理<a hidden class="anchor" aria-hidden="true" href="#原理">#</a></h3>
<p>kprobe 框架基于中断实现。当 kprobe 被注册后，内核会将对应地址的指令进行拷贝并替换为断点指令(比如 X86 中的 <code>int 3</code>)，随后当内核执行到对应地址时，中断会被触发从而执行流程会被重定向到我们注册的 <code>pre_handler</code> 函数；当对应地址的原始指令执行完后，内核会再次执行 <code>post_handler</code> (可选)，从而实现<strong>指令级别</strong>的内核动态监控。也就是说，kprobe 不仅可以跟踪任意带有符号的内核函数，也可以跟踪函数中间的任意指令。</p>
<p>另一个 kprobe 的同族是 <strong>kretprobe</strong>，只不过是针对函数级别的内核监控，根据用户注册时提供的 <code>entry_handler</code> 和 <code>ret_handler</code> 来分别在函数进入时和返回前进行回调。当然实现上和 kprobe 也有所不同，不是通过断点而是通过 trampoline 进行实现，可以略为减少运行开销。</p>
<blockquote>
<p>有人可能听说过 Jprobe，那是早期 Linux 内核的的一个监控实现，现已被 Kprobe 替代。</p>
</blockquote>
<p>拓展阅读:</p>
<ul>
<li><a href="https://lwn.net/Articles/132196/">An introduction to KProbes</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/trace/kprobes.html">Documentation/trace/kprobetrace.rst</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source/samples/kprobes/kprobe_example.c">samples/kprobes/kprobe_example.c</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source/samples/kprobes/kretprobe_example.c">samples/kprobes/kretprobe_example.c</a></li>
</ul>
<h2 id="uprobe">uprobe<a hidden class="anchor" aria-hidden="true" href="#uprobe">#</a></h2>
<p>uprobe 顾名思义，相对于内核函数/地址的监控，主要用于用户态函数/地址的监控。听起来是不是有点神奇，内核怎么监控用户态函数的调用呢？</p>
<h3 id="使用-1">使用<a hidden class="anchor" aria-hidden="true" href="#使用-1">#</a></h3>
<p>站在用户视角，我们先看个简单的例子，假设有这么个一个用户程序:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// test.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello, uprobe!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译好之后，查看某个符号的地址，然后告诉内核我要监控这个地址的调用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ gcc test.c -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ readelf -s <span class="nb">test</span> <span class="p">|</span> grep foo
</span></span><span class="line"><span class="cl">    87: <span class="m">0000000000000764</span>    <span class="m">32</span> FUNC    GLOBAL DEFAULT   <span class="m">13</span> foo
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="s1">&#39;p /root/test:0x764&#39;</span> &gt; /sys/kernel/debug/tracing/uprobe_events
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">1</span> &gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">1</span> &gt; /sys/kernel/debug/tracing/tracing_on
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后运行用户程序并检查内核的监控返回:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ./test <span class="o">&amp;&amp;</span> ./test
</span></span><span class="line"><span class="cl">hello, uprobe!
</span></span><span class="line"><span class="cl">hello, uprobe!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cat /sys/kernel/debug/tracing/trace
</span></span><span class="line"><span class="cl"><span class="c1"># tracer: nop</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># WARNING: FUNCTION TRACING IS CORRUPTED</span>
</span></span><span class="line"><span class="cl"><span class="c1">#          MAY BE MISSING FUNCTION EVENTS</span>
</span></span><span class="line"><span class="cl"><span class="c1"># entries-in-buffer/entries-written: 3/3   #P:8</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                              _-----=&gt; irqs-off</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                             / _----=&gt; need-resched</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                            | / _---=&gt; hardirq/softirq</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                            || / _--=&gt; preempt-depth</span>
</span></span><span class="line"><span class="cl"><span class="c1">#                            ||| /     delay</span>
</span></span><span class="line"><span class="cl"><span class="c1">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
</span></span><span class="line"><span class="cl"><span class="c1">#              | |       |   ||||       |         |</span>
</span></span><span class="line"><span class="cl">            test-7958  <span class="o">[</span>006<span class="o">]</span> .... 34213.780750: p_test_0x764: <span class="o">(</span>0x6236218764<span class="o">)</span>
</span></span><span class="line"><span class="cl">            test-7966  <span class="o">[</span>006<span class="o">]</span> .... 34229.054039: p_test_0x764: <span class="o">(</span>0x5f586cb764<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，最后别忘了关闭监控:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">0</span> &gt; /sys/kernel/debug/tracing/tracing_on
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">0</span> &gt; /sys/kernel/debug/tracing/events/uprobes/p_test_0x764/enable
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> &gt; /sys/kernel/debug/tracing/uprobe_events
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="原理-1">原理<a hidden class="anchor" aria-hidden="true" href="#原理-1">#</a></h3>
<p>上面的接口是基于 debugfs (在较新的内核中使用 tracefs)，即读写文件的方式去与内核交互实现 uprobe 监控。其中写入 <code>uprobe_events</code> 时会经过一系列内核调用:</p>
<ul>
<li>probes_write</li>
<li>create_trace_uprobe</li>
<li>kern_path: 打开目标 ELF 文件；</li>
<li>alloc_trace_uprobe: 分配 uprobe 结构体；</li>
<li>register_trace_uprobe: 注册 uprobe；</li>
<li>regiseter_uprobe_event: 将 probe 添加到全局列表中，并创建对应的 uprobe debugfs 目录，即上文示例中的 p_test_0x764；</li>
</ul>
<p>当已经注册了 uprobe 的 ELF 程序被执行时，可执行文件会被 mmap 映射到进程的地址空间，同时内核会将该进程虚拟地址空间中对应的 uprobe 地址替换成断点指令。当目标程序指向到对应的 uprobe 地址时，会触发断点，从而触发到 uprobe 的中断处理流程 (arch_uprobe_exception_notify)，进而在内核中打印对应的信息。</p>
<p>与 kprobe 类似，我们可以在触发 uprobe 时候根据对应寄存器去提取当前执行的上下文信息，比如函数的调用参数等。同时 uprobe 也有类似的同族: <strong>uretprobe</strong>。使用 uprobe 的好处是我们可以获取许多对于内核态比较抽象的信息，比如 bash 中 readline 函数的返回、SSL_read/write 的明文信息等。</p>
<p>拓展阅读:</p>
<ul>
<li><a href="https://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html">Linux uprobe: User-Level Dynamic Tracing</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/trace/uprobetracer.html">Documentation/trace/uprobetracer.rst</a></li>
<li><a href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2020/08/05/tracing-basic">Linux tracing - kprobe, uprobe and tracepoint</a></li>
</ul>
<h2 id="tracepoints">tracepoints<a hidden class="anchor" aria-hidden="true" href="#tracepoints">#</a></h2>
<p>tracepont 是内核中提供的一种轻量级代码监控方案，可以实现动态调用用户提供的监控函数，但需要子系统的维护者根据需要自行添加到自己的代码中。</p>
<h3 id="使用-2">使用<a hidden class="anchor" aria-hidden="true" href="#使用-2">#</a></h3>
<p>tracepoint 的使用和 uprobe 类似，主要基于 debugfs/tracefs 的文件读写去进行实现。一个区别在于 uprobe 使用的的用户自己定义的观察点(event)，而 tracepoint 使用的是内核代码中预置的观察点。</p>
<p>查看内核(或者驱动)中定义的所有观察点:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat /sys/kernel/debug/tracing/available_events
</span></span><span class="line"><span class="cl">sctp:sctp_probe
</span></span><span class="line"><span class="cl">sctp:sctp_probe_path
</span></span><span class="line"><span class="cl">sde:sde_perf_uidle_status
</span></span><span class="line"><span class="cl">....
</span></span><span class="line"><span class="cl">random:random_read
</span></span><span class="line"><span class="cl">random:urandom_read
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 events 对应目录下包含了以子系统结构组织的观察点目录:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ls /sys/kernel/debug/tracing/events/random/
</span></span><span class="line"><span class="cl">add_device_randomness  credit_entropy_bits  extract_entropy       get_random_bytes       mix_pool_bytes_nolock  urandom_read
</span></span><span class="line"><span class="cl">add_disk_randomness    debit_entropy        extract_entropy_user  get_random_bytes_arch  push_to_pool           xfer_secondary_pool
</span></span><span class="line"><span class="cl">add_input_randomness   <span class="nb">enable</span>               filter                mix_pool_bytes         random_read
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls /sys/kernel/debug/tracing/events/random/random_read/
</span></span><span class="line"><span class="cl"><span class="nb">enable</span>  filter  format  id  trigger
</span></span></code></pre></td></tr></table>
</div>
</div><p>以 urandom 为例，这是内核的伪随机数生成函数，对其开启追踪:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">1</span> &gt; /sys/kernel/debug/tracing/events/random/urandom_read/enable
</span></span><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">1</span> &gt; /sys/kernel/debug/tracing/tracing_on
</span></span><span class="line"><span class="cl">$ head -c1 /dev/urandom 
</span></span><span class="line"><span class="cl">$ cat /sys/kernel/debug/tracing/trace_pipe
</span></span><span class="line"><span class="cl">            head-9949  <span class="o">[</span>006<span class="o">]</span> .... 101453.641087: urandom_read: got_bits <span class="m">40</span> nonblocking_pool_entropy_left <span class="m">0</span> input_entropy_left <span class="m">2053</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 trace_pipe 是输出的管道，以阻塞的方式进行读取，因此需要先开始读取再获取 <code>/dev/urandom</code>，然后就可以看到类似上面的输出。这里输出的格式是在内核中定义的，我们下面会看到。</p>
<blockquote>
<p>当然，最后记得把 trace 关闭。</p>
</blockquote>
<h3 id="原理-2">原理<a hidden class="anchor" aria-hidden="true" href="#原理-2">#</a></h3>
<p>根据内核文档介绍，子系统的维护者如果想在他们的内核函数中增加跟踪点，需要执行两步操作:</p>
<ol>
<li>定义跟踪点</li>
<li>使用跟踪点</li>
</ol>
<p>内核为跟踪点的定义提供了 <code>TRACE_EVENT</code> 宏。还是以 urandom_read 这个跟踪点为例，其在内核中的定义在 <strong>include/trace/events/random.h</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#undef TRACE_SYSTEM
</span></span></span><span class="line"><span class="cl"><span class="cp">#define TRACE_SYSTEM random
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">TRACE_EVENT</span><span class="p">(</span><span class="n">random_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">TP_PROTO</span><span class="p">(</span><span class="kt">int</span> <span class="n">got_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">need_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input_left</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TP_ARGS</span><span class="p">(</span><span class="n">got_bits</span><span class="p">,</span> <span class="n">need_bits</span><span class="p">,</span> <span class="n">pool_left</span><span class="p">,</span> <span class="n">input_left</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TP_STRUCT__entry</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">__field</span><span class="p">(</span>      <span class="kt">int</span><span class="p">,</span>  <span class="n">got_bits</span>        <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">__field</span><span class="p">(</span>      <span class="kt">int</span><span class="p">,</span>  <span class="n">need_bits</span>       <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">__field</span><span class="p">(</span>      <span class="kt">int</span><span class="p">,</span>  <span class="n">pool_left</span>       <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">__field</span><span class="p">(</span>      <span class="kt">int</span><span class="p">,</span>  <span class="n">input_left</span>      <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TP_fast_assign</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">got_bits</span>   <span class="o">=</span> <span class="n">got_bits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">need_bits</span>  <span class="o">=</span> <span class="n">need_bits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">pool_left</span>  <span class="o">=</span> <span class="n">pool_left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">input_left</span> <span class="o">=</span> <span class="n">input_left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TP_printk</span><span class="p">(</span><span class="s">&#34;got_bits %d still_needed_bits %d &#34;</span>
</span></span><span class="line"><span class="cl">          <span class="s">&#34;blocking_pool_entropy_left %d input_entropy_left %d&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">got_bits</span><span class="p">,</span> <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">got_bits</span><span class="p">,</span> <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">pool_left</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">input_left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中:</p>
<ul>
<li><strong>random_read</strong>: trace 事件的名称，不一定要内核函数名称一致，但通常为了易于识别会和某个关键的内核函数相关联。隶属于 <strong>random</strong> 子系统(由 <code>TRACE_SYSTEM</code> 宏定义)；</li>
<li><strong>TP_PROTO</strong>: 定义了跟踪点的原型，可以理解为入参类型;</li>
<li><strong>TP_ARGS</strong>: 定义了”函数“的调用参数；</li>
<li><strong>TP_STRUCT__entry</strong>: 用于 fast binary tracing，可以理解为一个本地 C 结构体的定义；</li>
<li><strong>TP_fast_assign</strong>: 上述本地 C 结构体的初始化;</li>
<li><strong>TP_printk</strong>: 类似于 printk 的结构化输出定义，上节中 trace_pipe 的输出结果就是这里定义的；</li>
</ul>
<p>TRACE_EVENT 宏并不会自动插入对应函数，而是通过展开定义了一个名为 trace_urandom_read 的函数，需要内核开发者自行在代码中进行调用。 上述跟踪点实际上是在 <strong>drivers/char/random.c</strong> 文件中进行了调用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">ssize_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">urandom_read_nowarn</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nbytes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">nbytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">INT_MAX</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ENTROPY_SHIFT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="n">extract_crng_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">trace_urandom_read</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">nbytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ENTROPY_BITS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_pool</span><span class="p">));</span> <span class="c1">// &lt;-- 这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">ssize_t</span>
</span></span><span class="line"><span class="cl"><span class="nf">urandom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">maxwarn</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crng_ready</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">maxwarn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">maxwarn</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">urandom_warning</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">pr_notice</span><span class="p">(</span><span class="s">&#34;%s: uninitialized urandom read (%zd bytes read)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_crng</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">crng_init_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">primary_crng</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">urandom_read_nowarn</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是实际上是在 urandom_read_nowarn 函数中而不是 urandom_read 函数中调用的，因此也可见注入点名称和实际被调用的内核函数名称没有直接关系，只需要便于识别和定位即可。</p>
<p>根据上面的介绍我们可以了解到，tracepoint 相对于 probe 来说各有利弊:</p>
<ul>
<li>缺点是需要开发者自己定义并且加入到内核代码中，对代码略有侵入性；</li>
<li>优点是对于参数格式有明确定义，并且在不同内核版本中相对稳定，kprobe 跟踪的内核函数可能在下个版本就被改名或者优化掉了；</li>
</ul>
<p>另外，tracepoint 除了在内核代码中直接定义，还可以在驱动中进行动态添加，用于方便驱动开发者进行动态调试，复用已有的 debugfs 最终架构。这里有一个简单的<a href="https://lwn.net/Articles/383362/">自定义 tracepoint 示例</a>，可用于加深对 tracepoint 使用的理解。</p>
<p>拓展阅读:</p>
<ul>
<li><a href="https://lwn.net/Articles/379903/">LWN: Using the TRACE_EVENT() macro (Part 1)</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">Documentation/trace/tracepoints.rst</a></li>
<li><a href="https://blogs.oracle.com/linux/post/taming-tracepoints-in-the-linux-kernel">Taming Tracepoints in the Linux Kernel</a></li>
</ul>
<h2 id="usdt">USDT<a hidden class="anchor" aria-hidden="true" href="#usdt">#</a></h2>
<p>USDT 表示 <strong>Userland Statically Defined Tracing</strong>，即用户静态定义追踪 (币圈同志先退下)。最早源于 Sun 的 Dtrace 工具，因此 USDT probe 也常被称为 Dtrace probe。可以理解为 kernel tracepoint 的用户层版本，由应用开发者在自己的程序中关键函数加入自定义的跟踪点，有点类似于 printf 调试法(误)。</p>
<p>下面是一个简单的示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;sys/sdt.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">DTRACE_PROBE</span><span class="p">(</span><span class="s">&#34;hello_usdt&#34;</span><span class="p">,</span> <span class="s">&#34;enter&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">reval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">DTRACE_PROBE1</span><span class="p">(</span><span class="s">&#34;hello_usdt&#34;</span><span class="p">,</span> <span class="s">&#34;exit&#34;</span><span class="p">,</span> <span class="n">reval</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>DTRACE_PROBEn</code> 是 UDST (systemtap) 提供的追踪点定义+插入辅助宏，n 表示参数个数。编译上述代码后就可以看到被注入的 USDT probe 信息:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ apt-get install systemtap-sdt-dev
</span></span><span class="line"><span class="cl">$ gcc hello-usdt.c -o hello-usdt
</span></span><span class="line"><span class="cl">$ readelf  -n ./hello-usdt
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Displaying notes found in: .note.stapsdt
</span></span><span class="line"><span class="cl">  Owner                Data size        Description
</span></span><span class="line"><span class="cl">  stapsdt              0x0000002e       NT_STAPSDT <span class="o">(</span>SystemTap probe descriptors<span class="o">)</span>
</span></span><span class="line"><span class="cl">    Provider: <span class="s2">&#34;hello_usdt&#34;</span>
</span></span><span class="line"><span class="cl">    Name: <span class="s2">&#34;enter&#34;</span>
</span></span><span class="line"><span class="cl">    Location: 0x0000000000001131, Base: 0x0000000000002004, Semaphore: 0x0000000000000000
</span></span><span class="line"><span class="cl">    Arguments:
</span></span><span class="line"><span class="cl">  stapsdt              0x00000038       NT_STAPSDT <span class="o">(</span>SystemTap probe descriptors<span class="o">)</span>
</span></span><span class="line"><span class="cl">    Provider: <span class="s2">&#34;hello_usdt&#34;</span>
</span></span><span class="line"><span class="cl">    Name: <span class="s2">&#34;exit&#34;</span>
</span></span><span class="line"><span class="cl">    Location: 0x0000000000001139, Base: 0x0000000000002004, Semaphore: 0x0000000000000000
</span></span><span class="line"><span class="cl">    Arguments: -4@-4<span class="o">(</span>%rbp<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>readelf -n</code> 表示输出 ELF 中 NOTE 段的信息。</p>
<p>在使用 trace 工具(如 BCC、SystemTap、dtrace) 对该应用进行追踪时，会在启动过程中修改目标进程的对应地址，将其替换为 probe ，在触发调用时候产生对应事件，供数据收集端使用。通常添加 probe 的方式是 <strong>基于 uprobe</strong> 实现的。</p>
<p>使用 USDT 的一个好处是应用开发者可以在自己的程序中定义更加上层的追踪点，方便对于功能级别监控和分析，比如 node.js server 就自带了 USDT probe 点可用于追踪 HTTP 请求，并输出请求的路径等信息。由于 USDT 需要开发者配合使用，不符合我们最初的逆向分析需要，因此就不过多介绍了。(其实是懒得搭环境)</p>
<p>拓展阅读:</p>
<ul>
<li><a href="https://leezhenghui.github.io/linux/2019/03/05/exploring-usdt-on-linux.html">Exploring USDT Probes on Linux</a></li>
<li><a href="https://lwn.net/Articles/753601/">LWN: Using user-space tracepoints with BPF</a></li>
</ul>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>上述介绍的四种常见内核监控方案，根据静态/动态类型以及面向内核还是用户应用来划分的话，可以用下表进行概况:</p>
<table>
<thead>
<tr>
<th>监控方案</th>
<th>静态</th>
<th>动态</th>
<th>内核</th>
<th>用户</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kprobes</td>
<td></td>
<td>✔</td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>Uprobes</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>Tracepoints</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>USDT</td>
<td>✔</td>
<td></td>
<td></td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>准确来说 USDT 不算是一种独立的内核监控数据源，因为其实现还是依赖于 uprobe，不过为了对称还是放在这里，而且这样目录比较好看。</p>
<h1 id="采集--前端">采集 &amp; 前端<a hidden class="anchor" aria-hidden="true" href="#采集--前端">#</a></h1>
<p>上面我们介绍了几种当今内核中主要的监控数据来源，基本上可以涵盖所有的监控需求。不过从易用性上来看，只是实现了基本的架构，使用上有的是基于内核提供的系统调用/驱动接口，有的是基于 debugfs/tracefs，对用户而言不太友好，因此就有了许多封装再封装的监控前端，本节对这些主要的工具进行简要介绍。</p>
<h2 id="ftrace">ftrace<a hidden class="anchor" aria-hidden="true" href="#ftrace">#</a></h2>
<p>ftrace 是内核中用于实现内部追踪的一套框架，这么说有点抽象，但实际上我们前面已经用过了，就是 tracefs 中的使用的方法。</p>
<blockquote>
<p>在旧版本中内核中(4.1 之前)使用 debugfs，一般挂载到 /sys/kernel/debug/tracing；在新版本中使用独立的 tracefs，挂载到 /sys/kernel/tracing。但出于兼容性原因，原来的路径仍然保留，所以我们将其统一称为 tracefs。</p>
</blockquote>
<p>ftrace 通常被叫做 <strong>function tracer</strong>，但除了函数跟踪，还支持许多其他事件信息的追踪:</p>
<ul>
<li>hwlat: 硬件延时追踪</li>
<li>irqsoff: 中断延时追踪</li>
<li>preemptoff: 追踪指定时间片内的 CPU 抢占事件</li>
<li>wakeup: 追踪最高优先级的任务唤醒的延时</li>
<li>branch: 追踪内核中的 likely/unlikely 调用</li>
<li>mmiotrace: 追踪某个二进制模块所有对硬件的读写事件</li>
<li>……</li>
</ul>
<p>Android 中提供了一个简略的文档指导如何为内核增加 ftrace 支持，详见: <a href="https://source.android.google.cn/devices/tech/debug/ftrace">Using ftrace</a>。</p>
<h2 id="perf">perf<a hidden class="anchor" aria-hidden="true" href="#perf">#</a></h2>
<p><a href="https://perf.wiki.kernel.org/index.php/Tutorial">perf</a> 是 Linux 发行版中提供的一个性能监控程序，基于内核提供的 <a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html">perf_event_open</a> 系统调用来对进程进行采样并获取信息。Linux 中的 perf 子系统可以实现对 CPU 指令进行追踪和计数，以及收集 kprobe、uprobe 和 tracepoints 的信息，实现对系统性能的分析。</p>
<p>在 Android 中提供了一个简单版的 perf 程序 <a href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc">simpleperf</a>，接口和 perf 类似。</p>
<p>虽然可以监测到系统调用，但缺点是无法获取系统调用的参数，更不可以动态地修改内核。因此对于安全测试而言作用不大，更多是给 APP 开发者和手机厂商用于性能热点分析。值得一提的是，perf 子系统曾经出过不少漏洞，在 Android 内核提权史中也曾经留下过一点足迹 :D</p>
<h2 id="ebpf">eBPF<a hidden class="anchor" aria-hidden="true" href="#ebpf">#</a></h2>
<p>eBPF 为 <strong>extended Berkeley Packet Filter</strong> 的缩写，BPF 最早是用于包过滤的精简虚拟机，拥有自己的一套指令集，我们常用的 <code>tcpdump</code> 工具内部就会将输入的过滤规则转换为 BPF 指令，比如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ tcpdump -i lo0 <span class="s1">&#39;src 1.2.3.4&#39;</span> -d
</span></span><span class="line"><span class="cl"><span class="o">(</span>000<span class="o">)</span> ld       <span class="o">[</span>0<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>001<span class="o">)</span> jeq      <span class="c1">#0x2000000       jt 2	jf 5</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>002<span class="o">)</span> ld       <span class="o">[</span>16<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>003<span class="o">)</span> jeq      <span class="c1">#0x1020304       jt 4	jf 5</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>004<span class="o">)</span> ret      <span class="c1">#262144</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>005<span class="o">)</span> ret      <span class="c1">#0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该汇编指令表示令过滤器只接受 IP 包，并且来源 IP 地址为 1.2.3.4。其中的指令集可以参考 <a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a>。eBPF 在 BPF 指令集上做了许多增强(extend):</p>
<ul>
<li>寄存器个数从 2 个增加为 10 个 (R0 - R9)；</li>
<li>寄存器大小从 32 位增加为 64 位；</li>
<li>条件指令 jt/jf 的目标替换为 jt/fall-through，简单来说就是 else 分支可以默认忽略；</li>
<li>增加了 bpf_call 指令以及对应的调用约定，减少内核调用的开销；</li>
<li>……</li>
</ul>
<p>内核存在一个 eBPF 解释器，同时也支持实时编译(JIT)增加其执行速度，但很重要的一个限制是 eBPF 程序不能影响内核正常运行，在 内核加载 eBPF 程序前会对其进行一次语义检查，确保代码的安全性，主要限制为:</p>
<ul>
<li>不能包含循环，这是为了防止 eBPF 程序过度消耗系统资源(5.3 中增加了部分循环支持)；</li>
<li>不能反向跳转，其实也就是不能包含循环；</li>
<li>BPF 程序的栈大小限制为 512 字节；</li>
<li>……</li>
</ul>
<p>具体的限制策略都在内核的 <strong>eBPF verifier</strong> 中，不同版本略有差异。值得一提的是，最近几年 Linux 内核出过很多 eBPF 的漏洞，大多是 verifier 的验证逻辑错误，其中不少还上了 <a href="https://flatt.tech/assets/reports/210401_pwn2own/whitepaper.pdf">Pwn2Own</a>，但是由于权限的限制在 Android 中普通应用无法执行 <code>bpf(2)</code> 系统调用，因此并不受影响。</p>
<p>eBPF 和 perf_event 类似，通过内核虚拟机的方式实现监控代码过滤的动态插拔，这在许多场景下十分奏效。对于普通用户而言，基本上不会直接编写 eBPF 的指令去进行监控，虽然内核提供了一些宏来辅助 eBPF 程序的编写，但实际上更多的是使用上层的封装框架去调用，其中最著名的一个就是 BCC。</p>
<h3 id="bcc">BCC<a hidden class="anchor" aria-hidden="true" href="#bcc">#</a></h3>
<p><a href="https://github.com/iovisor/bcc">BCC (BPF Compiler Collection)</a> 包含了一系列工具来协助运维人员编写监控代码，其中使用较多的是其 Python 绑定。一个简单的示例程序如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bcc</span> <span class="kn">import</span> <span class="n">BPF</span>
</span></span><span class="line"><span class="cl"><span class="n">prog</span><span class="o">=</span><span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">int kprobe__sys_clone(void *ctx) {
</span></span></span><span class="line"><span class="cl"><span class="s2">    bpf_trace_printk(&#34;Hello, World!</span><span class="se">\\</span><span class="s2">n&#34;);
</span></span></span><span class="line"><span class="cl"><span class="s2">    return 0;
</span></span></span><span class="line"><span class="cl"><span class="s2">}
</span></span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">trace_print</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行该 python 代码后，每当系统中的进程调用 clone 系统调用，该程序就会打印 “Hello World” 输出信息。 可以看到这对于动态监控代码非常有用，比如我们可以通过 python 传入参数指定打印感兴趣的系统调用及其参数，而无需频繁修改代码。</p>
<p>eBPF 可以获取到内核中几乎所有的监控数据源，包括 kprobes、uprobes、tracepoints 等等，官方 repo 中给出了许多示例程序，比如 opensnoop 监控文件打开行为、execsnoop 监控程序的执行。后文我们会在 Android 系统进行实际演示来感受其威力。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205091957385.png" alt="https://img-blog.csdnimg.cn/d17f010b50fc4e13a74ea0a667ec8c40.png"  />
</p>
<h3 id="bpftrace">bpftrace<a hidden class="anchor" aria-hidden="true" href="#bpftrace">#</a></h3>
<p><a href="https://github.com/iovisor/bpftrace">bpftrace</a> 是 eBPF 框架的另一个上层封装，与 BCC 不同的是 bpftrace 定义了一套自己的 DSL 脚本语言，语法(也)类似于 awk，从而可以方便用户直接通过命令行实现丰富的功能，截取几条官方给出的示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 监控系统所有的打开文件调用(open/openat)，并打印打开文件的进程以及被打开的文件路径</span>
</span></span><span class="line"><span class="cl">bpftrace -e <span class="s1">&#39;tracepoint:syscalls:sys_enter_open { printf(&#34;%s %s\n&#34;, comm, str(args-&gt;filename)); }&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 统计系统中每个进程执行的系统调用总数</span>
</span></span><span class="line"><span class="cl">bpftrace -e <span class="s1">&#39;tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>官方同样也给出了许多 <strong>.bt</strong> 脚本示例，可以通过其代码进行学习和编写。</p>
<p>拓展阅读:</p>
<ul>
<li><a href="https://lwn.net/Articles/740157/">LWN: A thorough introduction to eBPF</a></li>
<li><a href="https://source.android.com/devices/architecture/kernel/bpf">Extending the Kernel with eBPF</a></li>
<li><a href="https://www.opersys.com/downloads/cc-slides/android-debug/slides-main-211122.html#/">https://www.opersys.com/downloads/cc-slides/android-debug/slides-main-211122.html#/</a></li>
<li><a href="http://www.caveman.work/2019/01/29/eBPF-on-Android/">http://www.caveman.work/2019/01/29/eBPF-on-Android/</a></li>
</ul>
<h2 id="systemtap">SystemTap<a hidden class="anchor" aria-hidden="true" href="#systemtap">#</a></h2>
<p><a href="https://sourceware.org/systemtap/wiki">SystemTap(stab)</a> 是 Linux 中的一个命令行工具，可以对各种内核监控源信息进行结构化输出。同时也实现了自己的一套 DSL 脚本，语法类似于 awk，可实现系统监控命令的快速编程。</p>
<p>使用 systemtap 需要包含内核源代码，因为需要动态编译和加载内核模块。在 Android 中还没有官方的支持，不过有一些<a href="https://github.com/flipreverse/systemtap-android">开源的 systemtap 移植</a>。</p>
<p>拓展阅读: <a href="https://lwn.net/Articles/852112/">Comparing SystemTap and bpftrace</a></p>
<h2 id="其他-1">其他<a hidden class="anchor" aria-hidden="true" href="#其他-1">#</a></h2>
<p>除了上面介绍的这些，还有许多开源的内核监控前端，比如 LTTng、<a href="https://git.kernel.org/pub/scm/linux/kernel/git/rostedt/trace-cmd.git">trace-cmd</a>、<a href="https://kernelshark.org/Documentation.html">kernelshark</a>等，内核监控输出以结构化的方式进行保存、处理和可视化，对于大量数据而言是非常实用的。限于篇幅不再对这些工具进行一一介绍，而且笔者使用的也不多，后续有机会再进行研究。</p>
<h1 id="android-移植">Android 移植<a hidden class="anchor" aria-hidden="true" href="#android-移植">#</a></h1>
<p>上面说了那么多，终究只是 Linux 发行版上的热闹，那么这些 trace 方法在 Android 上行得通吗？理论上 AOSP 的代码是开源的，内核也是开源的，编译一下不就好了。但实践起来我们会遇到几个方面的困难:</p>
<ol>
<li>许多工具需要编译代码，BCC 工具还需要 Python 运行，这在默认的 Android 环境中不存在；</li>
<li>原厂提供的预编译内核镜像不带有 kprobe 等监控功能支持，需要自行修改配置，烧写和编译内核；</li>
<li>Linux 旧版本对于 eBPF 的支持不完善，许多新功能都是在 5.x 后才引进，而 Android 的 Linux 内核都比较旧，需要进行 <strong>cherry-pick</strong> 甚至手动 backport；</li>
<li>AOSP 较新版本引入了 <a href="https://source.android.com/devices/architecture/kernel/generic-kernel-image">GKI(Generic Kernel Image)</a>，需要保持内核驱动接口的兼容性，因此内核代码不能引入过多修改；</li>
<li>……</li>
</ol>
<p>由于我们主要目的是进行安卓应用逆向分析，因此最好在真机环境运行，因为许多应用并不支持 x86 环境。当然 ARM 模拟器也可以，但在攻防对抗的时可能需要进行额外的模拟器检测绕过。</p>
<p>笔者使用的是 <strong>Google Pixel 5</strong>，使用其他手机的话需要适当进行调整。</p>
<h2 id="1-debian-over-android">1. Debian over Android<a hidden class="anchor" aria-hidden="true" href="#1-debian-over-android">#</a></h2>
<p>Android 系统本身并不是为了开发而设计的，因此只内置了简单的 busybox(toybox) 工具，以及一些包管理相关的程序如 pm/am/dumpsys/input 等。为了在上面构建完整的开发环境，我们需要能在安卓中运行 gcc/clang、python、Makefile 等，一个直观的想法是通过沙盒等方式在上面运行一个常见的 Linux 发行版，比如 Ubuntu 或者 Debian。</p>
<p><a href="https://github.com/joelagnel/adeb">androdeb</a> 正是这个想法的一个实现，其核心是基于 <strong>chroot</strong> 在 Android 中运行了一个 Debian aarch64 镜像，并可以通过 apt 等包管理工具安装所需要的编译工具链，从而在上面编译和运行 bcc 等 Linux 项目。</p>
<p>在 Android 上运行 Debian 系统的示例如下:</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205091958875.png" alt="https://img-blog.csdnimg.cn/3bc76ac08d814cef86c9ab0648b41998.png"  />
</p>
<p>Running Debian on Android</p>
<p>其中的关键之处在于正确挂载原生 Android 中的映射，比如 procfs、devfs、debugfs 等。</p>
<h2 id="2-自定义内核">2. 自定义内核<a hidden class="anchor" aria-hidden="true" href="#2-自定义内核">#</a></h2>
<p>解决了在 Android 上运行开发工具的问题之后，我们还需要一个支持动态调试的内核环境。在绝大多数官方固件中自带的内核都没有开启 KPROBES 的支持，这意味着我们自行编译和加载内核。为了能够支持 KPROBES、UPROBES、TRACEPOINTS 等功能，需要在内核的配置中添加以下选项:</p>
<p>禁用内核的安全特性，开启调试支持:</p>
<pre tabindex="0"><code>-d CONFIG_LTO \
-d CONFIG_LTO_CLANG \
-d CONFIG_CFI_CLANG \
-d CFI_PERMISSIVE \
-d CFI_CLANG \
-e CONFIG_IRQSOFF_TRACER \
-e CONFIG_PREEMPT_TRACER \
-e CONFIG_DEBUG_FS \
-e CONFIG_CHECKPOINT_RESTORE \
-d CONFIG_RANDOMIZE_BASE \
</code></pre><p>开启 eBPF 支持:</p>
<pre tabindex="0"><code>-e CONFIG_BPF \
-e CONFIG_BPF_SYSCALL \
-e CONFIG_BPF_JIT \
-e CONFIG_HAVE_EBPF_JIT \
-e CONFIG_IKHEADERS \
</code></pre><p>开启 kprobes 支持:</p>
<pre tabindex="0"><code>-e CONFIG_HAVE_KPROBES \
-e CONFIG_KPROBES \
-e CONFIG_KPROBE_EVENT \
</code></pre><p>开启 kretprobe 支持:</p>
<pre tabindex="0"><code>-e CONFIG_KRETPROBES \
-e CONFIG_HAVE_KRETPROBES \
-d CONFIG_SHADOW_CALL_STACK \
-e CONFIG_ROP_PROTECTION_NONE \
</code></pre><p>开启 ftrace 支持:</p>
<pre tabindex="0"><code>-e CONFIG_FTRACE_SYSCALLS \
-e CONFIG_FUNCTION_TRACER \
-e CONFIG_HAVE_DYNAMIC_FTRACE \
-e CONFIG_DYNAMIC_FTRACE \
</code></pre><p>开启 uprobes 支持:</p>
<pre tabindex="0"><code>-e CONFIG_UPROBES \
-e CONFIG_UPROBE_EVENT \
-e CONFIG_BPF_EVENTS 
</code></pre><p>BCC 建议设置的选项:</p>
<pre tabindex="0"><code>-e CONFIG_DEBUG_PREEMPT \
-e CONFIG_PREEMPTIRQ_EVENTS \
-d CONFIG_PROVE_LOCKING \
-d CONFIG_LOCKDEP
</code></pre><p>为了避免各类环境问题，我建议编译环境最好选择干净的虚拟机英文环境，或者直接使用 Docker 镜像，根据官方的指导去编译，见: <a href="https://source.android.com/setup/build/building-kernels">Building Kernels</a>。</p>
<p>编译内核常见的依赖:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ pkg --add-architecture i386
</span></span><span class="line"><span class="cl">$ apt install git ccache automake flex lzop bison <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip
</span></span></code></pre></td></tr></table>
</div>
</div><p>拓展阅读:</p>
<ul>
<li><a href="https://source.android.com/devices/tech/debug/kasan-kcov">Building a Pixel kernel with KASAN+KCOV</a></li>
<li><a href="https://blog.senyuuri.info/2021/06/30/ebpf-bcc-android-instrumentation/#_1-choose-kernel-features">eBPF/BCC - A better low-level Instrumentation tool on Android</a></li>
</ul>
<h2 id="3-内核移植">3. 内核移植<a hidden class="anchor" aria-hidden="true" href="#3-内核移植">#</a></h2>
<p>当你成功编译好内核并启动后，很可能会发现有一些内核分析工具比如 BCC 在使用上会出现各种问题，这通常是内核版本的原因。由于 eBPF 目前在内核中也在频繁更新，因此许多新的特性并没有增加到当前内核上。</p>
<p>例如，在 Pixel 5 最新的支持的内核是 4.19 版本，在这个版本中，<a href="https://github.com/iovisor/bcc/issues/3175">bpf_probe_read_user (issue#3175)</a> 函数还没添加进内核，因此使用 BCC 会回退到 <code>bpf_probe_read_kernel</code>，这在内核直接读取用户空间的数据(比如系统调用的参数)时会出现错误，因此我们需要手动去 cherry-pick 对应的 commit，即在 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?id=6ae08ae3dea2cfa03dd3665a3c8475c2d429ef47">Linux 5.5 中添加的 6ae08ae3dea2</a>。</p>
<p>BCC 所需的所有内核特性及其引进的版本列表可以参考: <a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">BCC/kernel-versions.md</a>，部分列表如下所示:</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205091959722.png" alt="https://img-blog.csdnimg.cn/86359125d2c24bfdbd8b92a54bc0db38.png"  />
</p>
<p>因此为了减少可能遇到的兼容性问题，尽量使用最新版本的内核，当然通常厂商都只维护一个较旧的 LTS 版本，只进行必要的安全性更新，如果买机不淑的话就需要自食其力了。</p>
<h1 id="实战测试">实战测试<a hidden class="anchor" aria-hidden="true" href="#实战测试">#</a></h1>
<p>通过在上述 Android Debian 环境编译好 BCC 之后，我们就可以使用 Python 编写对应的应用跟踪分析脚本了。一般是通过应用名去过滤系统调用，但是在 Android 中还有个特别的过滤方式就是通过用户 ID，因为应用是根据动态安装获取的 UID 去进行沙盒隔离的。</p>
<p>以某个层层加固的恶意 APK 为例，安装后获取其 UID 为 <code>u0_a142</code>，转换成数字是 <code>10142</code>，对其进行 exec 系统调用的监控:</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205091959066.png" alt="https://img-blog.csdnimg.cn/3f3f415bce354a0aaaca49d5777ce6a1.png"  />
</p>
<p>可以看到目标应用调用了 ps、getprop、pm 等程序，用来检测当前系统的 adb 状态以及所安装的应用，比如其中通过 <code>pm path com.topjohnwu.magisk</code> 来判断 Magisk 工具是否存在，因此存在 root 检测行为。上图中 <code>pm</code> 实际调用了 <code>cmd</code> 程序进行查找，因为 pm 本质上只是一个 shell 脚本:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat <span class="sb">`</span>which pm<span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="c1">#!/system/bin/sh</span>
</span></span><span class="line"><span class="cl">cmd package <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 UID 进行过滤的好处是可以跟踪所有 fork 的子进程和孙子进程，这是基于 PID 或者进程名跟踪所无法比拟的。除了 exec，我们还可以跟踪其他内核函数，比如 root 检测经常用到的 openat 或 access，如下所示:</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205092000639.png" alt="https://img-blog.csdnimg.cn/2f5f05c920ca416eb395640c0480e1db.png"  />
</p>
<p>基于内核级别的监控，让应用中所有的加固/隐藏/内联汇编等防御措施形同虚设，而且可以在应用启动的初期进行观察，让应用的一切行为在我们眼中无所遁形。</p>
<p>PS: 如果在使用 BCC 的过程中发现没有过滤 UID 的选项，那可能需要切换到最新的 release 版本或者 master 分支，因为这个选项是笔者最近才加上去的。</p>
<p><img loading="lazy" src="https://raw.githubusercontent.com/10cks/picture/main/img/202205092000615.png" alt="https://img-blog.csdnimg.cn/ae8086d95105480dbf92a9126bc52ab6.png"  />
</p>
<p>:D</p>
<p>拓展阅读:</p>
<ul>
<li><a href="http://www.joelfernandes.org/resources/bcc-ospm.pdf">eBPF super powers on ARM64 and Android (slides)</a></li>
<li><a href="https://www.aisp.sg/cyberfest/document/CRESTConSpeaker/eBPF.pdf">eBPF - Android Reverse Engineering Superpowers</a></li>
</ul>
<h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>本文总结并分析了几种内核主要的监控方案，它们通常用于性能监控和内核调试，但我们也可以将其用做安全分析，并在 Android 中进行了实际的移植和攻防测试，并且获得了超出预期的实战效果。除了内核级别监控，我们还可以基于 uprobes 实现应用内任意地址的监控，如在 SSL_read/write 地址处获取所有 SSL 加密的数据。得益于内核提供的丰富监控原语，我们可以实现内核级别移动端沙盒，全面监控移动应用行为，也可以通过内核读写原语去实现系统调用参数修改，从而实现应用运行环境的模拟和伪造。</p>


  </div>

  <footer class="post-footer">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <ul class="post-tags">
      <li><a href="https://10cks.top/tags/android/">Android</a></li>
      <li><a href="https://10cks.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></li>
      <li><a href="https://10cks.top/tags/%E9%80%86%E5%90%91/">逆向</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://10cks.top/posts/%E4%BD%BF%E7%94%A8-ecdsa-%E6%9B%BF%E6%8D%A2-rsa-%E7%94%9F%E6%88%90-ssh-key/">
    <span class="title">« Prev Page</span>
    <br>
    <span>使用 ECDSA 替换 RSA 生成 SSH Key</span>
  </a>
  <a class="next" href="https://10cks.top/posts/termux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
    <span class="title">Next Page »</span>
    <br>
    <span>Termux使用指南</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://10cks.top/">10cks</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js"
    integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg"
    crossorigin="anonymous"
></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css"
    integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE"
    crossorigin="anonymous"
/>
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>

</body>

</html>
